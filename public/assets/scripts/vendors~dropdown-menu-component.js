(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~dropdown-menu-component"],{

/***/ "./node_modules/element-ui/lib/dropdown-menu.js":
/*!******************************************************!*\
  !*** ./node_modules/element-ui/lib/dropdown-menu.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId]) {\n      /******/\n      return installedModules[moduleId].exports;\n      /******/\n    }\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n\n    var module = installedModules[moduleId] = {\n      /******/\n      i: moduleId,\n\n      /******/\n      l: false,\n\n      /******/\n      exports: {}\n      /******/\n\n    };\n    /******/\n\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.l = true;\n    /******/\n\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n\n  /******/\n\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n\n  /******/\n  // define getter function for harmony exports\n\n  /******/\n\n  __webpack_require__.d = function (exports, name, getter) {\n    /******/\n    if (!__webpack_require__.o(exports, name)) {\n      /******/\n      Object.defineProperty(exports, name, {\n        enumerable: true,\n        get: getter\n      });\n      /******/\n    }\n    /******/\n\n  };\n  /******/\n\n  /******/\n  // define __esModule on exports\n\n  /******/\n\n\n  __webpack_require__.r = function (exports) {\n    /******/\n    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n      /******/\n      Object.defineProperty(exports, Symbol.toStringTag, {\n        value: 'Module'\n      });\n      /******/\n    }\n    /******/\n\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    /******/\n  };\n  /******/\n\n  /******/\n  // create a fake namespace object\n\n  /******/\n  // mode & 1: value is a module id, require it\n\n  /******/\n  // mode & 2: merge all properties of value into the ns\n\n  /******/\n  // mode & 4: return value when already ns object\n\n  /******/\n  // mode & 8|1: behave like require\n\n  /******/\n\n\n  __webpack_require__.t = function (value, mode) {\n    /******/\n    if (mode & 1) value = __webpack_require__(value);\n    /******/\n\n    if (mode & 8) return value;\n    /******/\n\n    if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;\n    /******/\n\n    var ns = Object.create(null);\n    /******/\n\n    __webpack_require__.r(ns);\n    /******/\n\n\n    Object.defineProperty(ns, 'default', {\n      enumerable: true,\n      value: value\n    });\n    /******/\n\n    if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) {\n      return value[key];\n    }.bind(null, key));\n    /******/\n\n    return ns;\n    /******/\n  };\n  /******/\n\n  /******/\n  // getDefaultExport function for compatibility with non-harmony modules\n\n  /******/\n\n\n  __webpack_require__.n = function (module) {\n    /******/\n    var getter = module && module.__esModule ?\n    /******/\n    function getDefault() {\n      return module['default'];\n    } :\n    /******/\n    function getModuleExports() {\n      return module;\n    };\n    /******/\n\n    __webpack_require__.d(getter, 'a', getter);\n    /******/\n\n\n    return getter;\n    /******/\n  };\n  /******/\n\n  /******/\n  // Object.prototype.hasOwnProperty.call\n\n  /******/\n\n\n  __webpack_require__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  };\n  /******/\n\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n\n  __webpack_require__.p = \"/dist/\";\n  /******/\n\n  /******/\n\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(__webpack_require__.s = 82);\n  /******/\n}(\n/************************************************************************/\n\n/******/\n{\n  /***/\n  0:\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n    /* harmony export (binding) */\n\n    __webpack_require__.d(__webpack_exports__, \"a\", function () {\n      return normalizeComponent;\n    });\n    /* globals __VUE_SSR_CONTEXT__ */\n    // IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n    // This module is a runtime utility for cleaner component module output and will\n    // be included in the final webpack user bundle.\n\n\n    function normalizeComponent(scriptExports, render, staticRenderFns, functionalTemplate, injectStyles, scopeId, moduleIdentifier,\n    /* server only */\n    shadowMode\n    /* vue-cli only */\n    ) {\n      // Vue.extend constructor export interop\n      var options = typeof scriptExports === 'function' ? scriptExports.options : scriptExports; // render functions\n\n      if (render) {\n        options.render = render;\n        options.staticRenderFns = staticRenderFns;\n        options._compiled = true;\n      } // functional template\n\n\n      if (functionalTemplate) {\n        options.functional = true;\n      } // scopedId\n\n\n      if (scopeId) {\n        options._scopeId = 'data-v-' + scopeId;\n      }\n\n      var hook;\n\n      if (moduleIdentifier) {\n        // server build\n        hook = function (context) {\n          // 2.3 injection\n          context = context || // cached call\n          this.$vnode && this.$vnode.ssrContext || // stateful\n          this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional\n          // 2.2 with runInNewContext: true\n\n          if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n            context = __VUE_SSR_CONTEXT__;\n          } // inject component styles\n\n\n          if (injectStyles) {\n            injectStyles.call(this, context);\n          } // register component module identifier for async chunk inferrence\n\n\n          if (context && context._registeredComponents) {\n            context._registeredComponents.add(moduleIdentifier);\n          }\n        }; // used by ssr in case component is cached and beforeCreate\n        // never gets called\n\n\n        options._ssrRegister = hook;\n      } else if (injectStyles) {\n        hook = shadowMode ? function () {\n          injectStyles.call(this, this.$root.$options.shadowRoot);\n        } : injectStyles;\n      }\n\n      if (hook) {\n        if (options.functional) {\n          // for template-only hot-reload because in that case the render fn doesn't\n          // go through the normalizer\n          options._injectStyles = hook; // register for functioal component in vue file\n\n          var originalRender = options.render;\n\n          options.render = function renderWithStyleInjection(h, context) {\n            hook.call(context);\n            return originalRender(h, context);\n          };\n        } else {\n          // inject component registration as beforeCreate hook\n          var existing = options.beforeCreate;\n          options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\n        }\n      }\n\n      return {\n        exports: scriptExports,\n        options: options\n      };\n    }\n    /***/\n\n  },\n\n  /***/\n  5:\n  /***/\n  function (module, exports) {\n    module.exports = __webpack_require__(/*! element-ui/lib/utils/vue-popper */ \"./node_modules/element-ui/lib/utils/vue-popper.js\");\n    /***/\n  },\n\n  /***/\n  82:\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__); // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/dropdown/src/dropdown-menu.vue?vue&type=template&id=0da6b714&\n\n\n    var render = function () {\n      var _vm = this;\n\n      var _h = _vm.$createElement;\n\n      var _c = _vm._self._c || _h;\n\n      return _c(\"transition\", {\n        attrs: {\n          name: \"el-zoom-in-top\"\n        },\n        on: {\n          \"after-leave\": _vm.doDestroy\n        }\n      }, [_c(\"ul\", {\n        directives: [{\n          name: \"show\",\n          rawName: \"v-show\",\n          value: _vm.showPopper,\n          expression: \"showPopper\"\n        }],\n        staticClass: \"el-dropdown-menu el-popper\",\n        class: [_vm.size && \"el-dropdown-menu--\" + _vm.size]\n      }, [_vm._t(\"default\")], 2)]);\n    };\n\n    var staticRenderFns = [];\n    render._withStripped = true; // CONCATENATED MODULE: ./packages/dropdown/src/dropdown-menu.vue?vue&type=template&id=0da6b714&\n    // EXTERNAL MODULE: external \"element-ui/lib/utils/vue-popper\"\n\n    var vue_popper_ = __webpack_require__(5);\n\n    var vue_popper_default = /*#__PURE__*/__webpack_require__.n(vue_popper_); // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/dropdown/src/dropdown-menu.vue?vue&type=script&lang=js&\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n\n    /* harmony default export */\n\n\n    var dropdown_menuvue_type_script_lang_js_ = {\n      name: 'ElDropdownMenu',\n      componentName: 'ElDropdownMenu',\n      mixins: [vue_popper_default.a],\n      props: {\n        visibleArrow: {\n          type: Boolean,\n          default: true\n        },\n        arrowOffset: {\n          type: Number,\n          default: 0\n        }\n      },\n      data: function data() {\n        return {\n          size: this.dropdown.dropdownSize\n        };\n      },\n      inject: ['dropdown'],\n      created: function created() {\n        var _this = this;\n\n        this.$on('updatePopper', function () {\n          if (_this.showPopper) _this.updatePopper();\n        });\n        this.$on('visible', function (val) {\n          _this.showPopper = val;\n        });\n      },\n      mounted: function mounted() {\n        this.dropdown.popperElm = this.popperElm = this.$el;\n        this.referenceElm = this.dropdown.$el; // compatible with 2.6 new v-slot syntax\n        // issue link https://github.com/ElemeFE/element/issues/14345\n\n        this.dropdown.initDomOperation();\n      },\n      watch: {\n        'dropdown.placement': {\n          immediate: true,\n          handler: function handler(val) {\n            this.currentPlacement = val;\n          }\n        }\n      }\n    }; // CONCATENATED MODULE: ./packages/dropdown/src/dropdown-menu.vue?vue&type=script&lang=js&\n\n    /* harmony default export */\n\n    var src_dropdown_menuvue_type_script_lang_js_ = dropdown_menuvue_type_script_lang_js_; // EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\n\n    var componentNormalizer = __webpack_require__(0); // CONCATENATED MODULE: ./packages/dropdown/src/dropdown-menu.vue\n\n    /* normalize component */\n\n\n    var component = Object(componentNormalizer[\"a\"\n    /* default */\n    ])(src_dropdown_menuvue_type_script_lang_js_, render, staticRenderFns, false, null, null, null);\n    /* hot reload */\n\n    if (false) { var api; }\n\n    component.options.__file = \"packages/dropdown/src/dropdown-menu.vue\";\n    /* harmony default export */\n\n    var dropdown_menu = component.exports; // CONCATENATED MODULE: ./packages/dropdown-menu/index.js\n\n    /* istanbul ignore next */\n\n    dropdown_menu.install = function (Vue) {\n      Vue.component(dropdown_menu.name, dropdown_menu);\n    };\n    /* harmony default export */\n\n\n    var packages_dropdown_menu = __webpack_exports__[\"default\"] = dropdown_menu;\n    /***/\n  }\n  /******/\n\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvZHJvcGRvd24tbWVudS5qcz9kZWZiIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJtb2R1bGVzIiwiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImkiLCJsIiwiY2FsbCIsIm0iLCJjIiwiZCIsIm5hbWUiLCJnZXR0ZXIiLCJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiciIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwidmFsdWUiLCJ0IiwibW9kZSIsIl9fZXNNb2R1bGUiLCJucyIsImNyZWF0ZSIsImtleSIsImJpbmQiLCJuIiwiZ2V0RGVmYXVsdCIsImdldE1vZHVsZUV4cG9ydHMiLCJvYmplY3QiLCJwcm9wZXJ0eSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwicCIsInMiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwibm9ybWFsaXplQ29tcG9uZW50Iiwic2NyaXB0RXhwb3J0cyIsInJlbmRlciIsInN0YXRpY1JlbmRlckZucyIsImZ1bmN0aW9uYWxUZW1wbGF0ZSIsImluamVjdFN0eWxlcyIsInNjb3BlSWQiLCJtb2R1bGVJZGVudGlmaWVyIiwic2hhZG93TW9kZSIsIm9wdGlvbnMiLCJfY29tcGlsZWQiLCJmdW5jdGlvbmFsIiwiX3Njb3BlSWQiLCJob29rIiwiY29udGV4dCIsIiR2bm9kZSIsInNzckNvbnRleHQiLCJwYXJlbnQiLCJfX1ZVRV9TU1JfQ09OVEVYVF9fIiwiX3JlZ2lzdGVyZWRDb21wb25lbnRzIiwiYWRkIiwiX3NzclJlZ2lzdGVyIiwiJHJvb3QiLCIkb3B0aW9ucyIsInNoYWRvd1Jvb3QiLCJfaW5qZWN0U3R5bGVzIiwib3JpZ2luYWxSZW5kZXIiLCJyZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24iLCJoIiwiZXhpc3RpbmciLCJiZWZvcmVDcmVhdGUiLCJjb25jYXQiLCJyZXF1aXJlIiwiX3ZtIiwiX2giLCIkY3JlYXRlRWxlbWVudCIsIl9jIiwiX3NlbGYiLCJhdHRycyIsIm9uIiwiZG9EZXN0cm95IiwiZGlyZWN0aXZlcyIsInJhd05hbWUiLCJzaG93UG9wcGVyIiwiZXhwcmVzc2lvbiIsInN0YXRpY0NsYXNzIiwiY2xhc3MiLCJzaXplIiwiX3QiLCJfd2l0aFN0cmlwcGVkIiwidnVlX3BvcHBlcl8iLCJ2dWVfcG9wcGVyX2RlZmF1bHQiLCJkcm9wZG93bl9tZW51dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfIiwiY29tcG9uZW50TmFtZSIsIm1peGlucyIsImEiLCJwcm9wcyIsInZpc2libGVBcnJvdyIsInR5cGUiLCJCb29sZWFuIiwiZGVmYXVsdCIsImFycm93T2Zmc2V0IiwiTnVtYmVyIiwiZGF0YSIsImRyb3Bkb3duIiwiZHJvcGRvd25TaXplIiwiaW5qZWN0IiwiY3JlYXRlZCIsIl90aGlzIiwiJG9uIiwidXBkYXRlUG9wcGVyIiwidmFsIiwibW91bnRlZCIsInBvcHBlckVsbSIsIiRlbCIsInJlZmVyZW5jZUVsbSIsImluaXREb21PcGVyYXRpb24iLCJ3YXRjaCIsImltbWVkaWF0ZSIsImhhbmRsZXIiLCJjdXJyZW50UGxhY2VtZW50Iiwic3JjX2Ryb3Bkb3duX21lbnV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18iLCJjb21wb25lbnROb3JtYWxpemVyIiwiY29tcG9uZW50IiwiX19maWxlIiwiZHJvcGRvd25fbWVudSIsImluc3RhbGwiLCJWdWUiLCJwYWNrYWdlc19kcm9wZG93bl9tZW51Il0sIm1hcHBpbmdzIjoiQUFBQUEsTUFBTSxDQUFDQyxPQUFQO0FBQ0E7QUFBVSxVQUFTQyxPQUFULEVBQWtCO0FBQUU7O0FBQzlCO0FBQVU7O0FBQ1Y7QUFBVSxNQUFJQyxnQkFBZ0IsR0FBRyxFQUF2QjtBQUNWOztBQUNBO0FBQVU7O0FBQ1Y7O0FBQVUsV0FBU0MsbUJBQVQsQ0FBNkJDLFFBQTdCLEVBQXVDO0FBQ2pEOztBQUNBO0FBQVc7O0FBQ1g7QUFB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d0JULEdBQXhCO0FBQ0Q7QUFKbUI7QUFEakI7QUE5Q2lFLEtBQTdDLENBdkRxQyxDQThHbEU7O0FBQ0M7O0FBQTZCLFFBQUlVLHlDQUF5QyxHQUFJN0IscUNBQWpELENBL0dvQyxDQWdIbEU7O0FBQ0EsUUFBSThCLG1CQUFtQixHQUFHdEgsbUJBQW1CLENBQUMsQ0FBRCxDQUE3QyxDQWpIa0UsQ0FtSGxFOztBQU1BOzs7QUFFQSxRQUFJdUgsU0FBUyxHQUFHNUcsTUFBTSxDQUFDMkcsbUJBQW1CLENBQUM7QUFBSTtBQUFMLEtBQXBCLENBQU4sQ0FDZEQseUNBRGMsRUFFZC9FLE1BRmMsRUFHZEMsZUFIYyxFQUlkLEtBSmMsRUFLZCxJQUxjLEVBTWQsSUFOYyxFQU9kLElBUGMsQ0FBaEI7QUFXQTs7QUFDQSxRQUFJLEtBQUosRUFBVyxZQUFZOztBQUN2QmdGLGFBQVMsQ0FBQzFFLE9BQVYsQ0FBa0IyRSxNQUFsQixHQUEyQix5Q0FBM0I7QUFDQTs7QUFBNkIsUUFBSUMsYUFBYSxHQUFJRixTQUFTLENBQUMxSCxPQUEvQixDQXpJcUMsQ0EwSWxFOztBQUdBOztBQUNBNEgsaUJBQWEsQ0FBQ0MsT0FBZCxHQUF3QixVQUFVQyxHQUFWLEVBQWU7QUFDckNBLFNBQUcsQ0FBQ0osU0FBSixDQUFjRSxhQUFhLENBQUNqSCxJQUE1QixFQUFrQ2lILGFBQWxDO0FBQ0QsS0FGRDtBQUlBOzs7QUFBNkIsUUFBSUcsc0JBQXNCLEdBQUd6RixtQkFBbUIsQ0FBQyxTQUFELENBQW5CLEdBQWtDc0YsYUFBL0Q7QUFFN0I7QUFBTztBQUVQOztBQXRRVSxDQXRGRCxDQURUIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvbGliL2Ryb3Bkb3duLW1lbnUuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9XG4vKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiL2Rpc3QvXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDgyKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKHtcblxuLyoqKi8gMDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiYVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIG5vcm1hbGl6ZUNvbXBvbmVudDsgfSk7XG4vKiBnbG9iYWxzIF9fVlVFX1NTUl9DT05URVhUX18gKi9cblxuLy8gSU1QT1JUQU5UOiBEbyBOT1QgdXNlIEVTMjAxNSBmZWF0dXJlcyBpbiB0aGlzIGZpbGUgKGV4Y2VwdCBmb3IgbW9kdWxlcykuXG4vLyBUaGlzIG1vZHVsZSBpcyBhIHJ1bnRpbWUgdXRpbGl0eSBmb3IgY2xlYW5lciBjb21wb25lbnQgbW9kdWxlIG91dHB1dCBhbmQgd2lsbFxuLy8gYmUgaW5jbHVkZWQgaW4gdGhlIGZpbmFsIHdlYnBhY2sgdXNlciBidW5kbGUuXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXG4gIHNjcmlwdEV4cG9ydHMsXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmdW5jdGlvbmFsVGVtcGxhdGUsXG4gIGluamVjdFN0eWxlcyxcbiAgc2NvcGVJZCxcbiAgbW9kdWxlSWRlbnRpZmllciwgLyogc2VydmVyIG9ubHkgKi9cbiAgc2hhZG93TW9kZSAvKiB2dWUtY2xpIG9ubHkgKi9cbikge1xuICAvLyBWdWUuZXh0ZW5kIGNvbnN0cnVjdG9yIGV4cG9ydCBpbnRlcm9wXG4gIHZhciBvcHRpb25zID0gdHlwZW9mIHNjcmlwdEV4cG9ydHMgPT09ICdmdW5jdGlvbidcbiAgICA/IHNjcmlwdEV4cG9ydHMub3B0aW9uc1xuICAgIDogc2NyaXB0RXhwb3J0c1xuXG4gIC8vIHJlbmRlciBmdW5jdGlvbnNcbiAgaWYgKHJlbmRlcikge1xuICAgIG9wdGlvbnMucmVuZGVyID0gcmVuZGVyXG4gICAgb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnMgPSBzdGF0aWNSZW5kZXJGbnNcbiAgICBvcHRpb25zLl9jb21waWxlZCA9IHRydWVcbiAgfVxuXG4gIC8vIGZ1bmN0aW9uYWwgdGVtcGxhdGVcbiAgaWYgKGZ1bmN0aW9uYWxUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMuZnVuY3Rpb25hbCA9IHRydWVcbiAgfVxuXG4gIC8vIHNjb3BlZElkXG4gIGlmIChzY29wZUlkKSB7XG4gICAgb3B0aW9ucy5fc2NvcGVJZCA9ICdkYXRhLXYtJyArIHNjb3BlSWRcbiAgfVxuXG4gIHZhciBob29rXG4gIGlmIChtb2R1bGVJZGVudGlmaWVyKSB7IC8vIHNlcnZlciBidWlsZFxuICAgIGhvb2sgPSBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgLy8gMi4zIGluamVjdGlvblxuICAgICAgY29udGV4dCA9XG4gICAgICAgIGNvbnRleHQgfHwgLy8gY2FjaGVkIGNhbGxcbiAgICAgICAgKHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHQpIHx8IC8vIHN0YXRlZnVsXG4gICAgICAgICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC4kdm5vZGUgJiYgdGhpcy5wYXJlbnQuJHZub2RlLnNzckNvbnRleHQpIC8vIGZ1bmN0aW9uYWxcbiAgICAgIC8vIDIuMiB3aXRoIHJ1bkluTmV3Q29udGV4dDogdHJ1ZVxuICAgICAgaWYgKCFjb250ZXh0ICYmIHR5cGVvZiBfX1ZVRV9TU1JfQ09OVEVYVF9fICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb250ZXh0ID0gX19WVUVfU1NSX0NPTlRFWFRfX1xuICAgICAgfVxuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCBzdHlsZXNcbiAgICAgIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICAgICAgaW5qZWN0U3R5bGVzLmNhbGwodGhpcywgY29udGV4dClcbiAgICAgIH1cbiAgICAgIC8vIHJlZ2lzdGVyIGNvbXBvbmVudCBtb2R1bGUgaWRlbnRpZmllciBmb3IgYXN5bmMgY2h1bmsgaW5mZXJyZW5jZVxuICAgICAgaWYgKGNvbnRleHQgJiYgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMpIHtcbiAgICAgICAgY29udGV4dC5fcmVnaXN0ZXJlZENvbXBvbmVudHMuYWRkKG1vZHVsZUlkZW50aWZpZXIpXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVzZWQgYnkgc3NyIGluIGNhc2UgY29tcG9uZW50IGlzIGNhY2hlZCBhbmQgYmVmb3JlQ3JlYXRlXG4gICAgLy8gbmV2ZXIgZ2V0cyBjYWxsZWRcbiAgICBvcHRpb25zLl9zc3JSZWdpc3RlciA9IGhvb2tcbiAgfSBlbHNlIGlmIChpbmplY3RTdHlsZXMpIHtcbiAgICBob29rID0gc2hhZG93TW9kZVxuICAgICAgPyBmdW5jdGlvbiAoKSB7IGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIHRoaXMuJHJvb3QuJG9wdGlvbnMuc2hhZG93Um9vdCkgfVxuICAgICAgOiBpbmplY3RTdHlsZXNcbiAgfVxuXG4gIGlmIChob29rKSB7XG4gICAgaWYgKG9wdGlvbnMuZnVuY3Rpb25hbCkge1xuICAgICAgLy8gZm9yIHRlbXBsYXRlLW9ubHkgaG90LXJlbG9hZCBiZWNhdXNlIGluIHRoYXQgY2FzZSB0aGUgcmVuZGVyIGZuIGRvZXNuJ3RcbiAgICAgIC8vIGdvIHRocm91Z2ggdGhlIG5vcm1hbGl6ZXJcbiAgICAgIG9wdGlvbnMuX2luamVjdFN0eWxlcyA9IGhvb2tcbiAgICAgIC8vIHJlZ2lzdGVyIGZvciBmdW5jdGlvYWwgY29tcG9uZW50IGluIHZ1ZSBmaWxlXG4gICAgICB2YXIgb3JpZ2luYWxSZW5kZXIgPSBvcHRpb25zLnJlbmRlclxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBvcmlnaW5hbFJlbmRlcihoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbmplY3QgY29tcG9uZW50IHJlZ2lzdHJhdGlvbiBhcyBiZWZvcmVDcmVhdGUgaG9va1xuICAgICAgdmFyIGV4aXN0aW5nID0gb3B0aW9ucy5iZWZvcmVDcmVhdGVcbiAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmdcbiAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spXG4gICAgICAgIDogW2hvb2tdXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBleHBvcnRzOiBzY3JpcHRFeHBvcnRzLFxuICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgfVxufVxuXG5cbi8qKiovIH0pLFxuXG4vKioqLyA1OlxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCJlbGVtZW50LXVpL2xpYi91dGlscy92dWUtcG9wcGVyXCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gODI6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9sb2FkZXJzL3RlbXBsYXRlTG9hZGVyLmpzPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWI/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL3BhY2thZ2VzL2Ryb3Bkb3duL3NyYy9kcm9wZG93bi1tZW51LnZ1ZT92dWUmdHlwZT10ZW1wbGF0ZSZpZD0wZGE2YjcxNCZcbnZhciByZW5kZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIF92bSA9IHRoaXNcbiAgdmFyIF9oID0gX3ZtLiRjcmVhdGVFbGVtZW50XG4gIHZhciBfYyA9IF92bS5fc2VsZi5fYyB8fCBfaFxuICByZXR1cm4gX2MoXG4gICAgXCJ0cmFuc2l0aW9uXCIsXG4gICAgeyBhdHRyczogeyBuYW1lOiBcImVsLXpvb20taW4tdG9wXCIgfSwgb246IHsgXCJhZnRlci1sZWF2ZVwiOiBfdm0uZG9EZXN0cm95IH0gfSxcbiAgICBbXG4gICAgICBfYyhcbiAgICAgICAgXCJ1bFwiLFxuICAgICAgICB7XG4gICAgICAgICAgZGlyZWN0aXZlczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBuYW1lOiBcInNob3dcIixcbiAgICAgICAgICAgICAgcmF3TmFtZTogXCJ2LXNob3dcIixcbiAgICAgICAgICAgICAgdmFsdWU6IF92bS5zaG93UG9wcGVyLFxuICAgICAgICAgICAgICBleHByZXNzaW9uOiBcInNob3dQb3BwZXJcIlxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZWwtZHJvcGRvd24tbWVudSBlbC1wb3BwZXJcIixcbiAgICAgICAgICBjbGFzczogW192bS5zaXplICYmIFwiZWwtZHJvcGRvd24tbWVudS0tXCIgKyBfdm0uc2l6ZV1cbiAgICAgICAgfSxcbiAgICAgICAgW192bS5fdChcImRlZmF1bHRcIildLFxuICAgICAgICAyXG4gICAgICApXG4gICAgXVxuICApXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxuXG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvZHJvcGRvd24vc3JjL2Ryb3Bkb3duLW1lbnUudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTBkYTZiNzE0JlxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIFwiZWxlbWVudC11aS9saWIvdXRpbHMvdnVlLXBvcHBlclwiXG52YXIgdnVlX3BvcHBlcl8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xudmFyIHZ1ZV9wb3BwZXJfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4odnVlX3BvcHBlcl8pO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9wYWNrYWdlcy9kcm9wZG93bi9zcmMvZHJvcGRvd24tbWVudS52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG4vL1xuLy9cbi8vXG4vL1xuLy9cbi8vXG4vL1xuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgZHJvcGRvd25fbWVudXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdFbERyb3Bkb3duTWVudScsXG5cbiAgY29tcG9uZW50TmFtZTogJ0VsRHJvcGRvd25NZW51JyxcblxuICBtaXhpbnM6IFt2dWVfcG9wcGVyX2RlZmF1bHQuYV0sXG5cbiAgcHJvcHM6IHtcbiAgICB2aXNpYmxlQXJyb3c6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBhcnJvd09mZnNldDoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogMFxuICAgIH1cbiAgfSxcblxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzaXplOiB0aGlzLmRyb3Bkb3duLmRyb3Bkb3duU2l6ZVxuICAgIH07XG4gIH0sXG5cblxuICBpbmplY3Q6IFsnZHJvcGRvd24nXSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICB0aGlzLiRvbigndXBkYXRlUG9wcGVyJywgZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKF90aGlzLnNob3dQb3BwZXIpIF90aGlzLnVwZGF0ZVBvcHBlcigpO1xuICAgIH0pO1xuICAgIHRoaXMuJG9uKCd2aXNpYmxlJywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgX3RoaXMuc2hvd1BvcHBlciA9IHZhbDtcbiAgICB9KTtcbiAgfSxcbiAgbW91bnRlZDogZnVuY3Rpb24gbW91bnRlZCgpIHtcbiAgICB0aGlzLmRyb3Bkb3duLnBvcHBlckVsbSA9IHRoaXMucG9wcGVyRWxtID0gdGhpcy4kZWw7XG4gICAgdGhpcy5yZWZlcmVuY2VFbG0gPSB0aGlzLmRyb3Bkb3duLiRlbDtcbiAgICAvLyBjb21wYXRpYmxlIHdpdGggMi42IG5ldyB2LXNsb3Qgc3ludGF4XG4gICAgLy8gaXNzdWUgbGluayBodHRwczovL2dpdGh1Yi5jb20vRWxlbWVGRS9lbGVtZW50L2lzc3Vlcy8xNDM0NVxuICAgIHRoaXMuZHJvcGRvd24uaW5pdERvbU9wZXJhdGlvbigpO1xuICB9LFxuXG5cbiAgd2F0Y2g6IHtcbiAgICAnZHJvcGRvd24ucGxhY2VtZW50Jzoge1xuICAgICAgaW1tZWRpYXRlOiB0cnVlLFxuICAgICAgaGFuZGxlcjogZnVuY3Rpb24gaGFuZGxlcih2YWwpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50UGxhY2VtZW50ID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2Ryb3Bkb3duL3NyYy9kcm9wZG93bi1tZW51LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfZHJvcGRvd25fbWVudXZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9IChkcm9wZG93bl9tZW51dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1xudmFyIGNvbXBvbmVudE5vcm1hbGl6ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL2Ryb3Bkb3duL3NyYy9kcm9wZG93bi1tZW51LnZ1ZVxuXG5cblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIGNvbXBvbmVudCA9IE9iamVjdChjb21wb25lbnROb3JtYWxpemVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKShcbiAgc3JjX2Ryb3Bkb3duX21lbnV2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18sXG4gIHJlbmRlcixcbiAgc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciBhcGk7IH1cbmNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwicGFja2FnZXMvZHJvcGRvd24vc3JjL2Ryb3Bkb3duLW1lbnUudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGRyb3Bkb3duX21lbnUgPSAoY29tcG9uZW50LmV4cG9ydHMpO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy9kcm9wZG93bi1tZW51L2luZGV4LmpzXG5cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmRyb3Bkb3duX21lbnUuaW5zdGFsbCA9IGZ1bmN0aW9uIChWdWUpIHtcbiAgVnVlLmNvbXBvbmVudChkcm9wZG93bl9tZW51Lm5hbWUsIGRyb3Bkb3duX21lbnUpO1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcGFja2FnZXNfZHJvcGRvd25fbWVudSA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKGRyb3Bkb3duX21lbnUpO1xuXG4vKioqLyB9KVxuXG4vKioqKioqLyB9KTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/element-ui/lib/dropdown-menu.js\n");

/***/ }),

/***/ "./node_modules/element-ui/lib/utils/dom.js":
/*!**************************************************!*\
  !*** ./node_modules/element-ui/lib/utils/dom.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.isInContainer = exports.getScrollContainer = exports.isScroll = exports.getStyle = exports.once = exports.off = exports.on = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n/* istanbul ignore next */\n\n\nexports.hasClass = hasClass;\nexports.addClass = addClass;\nexports.removeClass = removeClass;\nexports.setStyle = setStyle;\n\nvar _vue = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm.js\");\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar isServer = _vue2.default.prototype.$isServer;\nvar SPECIAL_CHARS_REGEXP = /([\\:\\-\\_]+(.))/g;\nvar MOZ_HACK_REGEXP = /^moz([A-Z])/;\nvar ieVersion = isServer ? 0 : Number(document.documentMode);\n/* istanbul ignore next */\n\nvar trim = function trim(string) {\n  return (string || '').replace(/^[\\s\\uFEFF]+|[\\s\\uFEFF]+$/g, '');\n};\n/* istanbul ignore next */\n\n\nvar camelCase = function camelCase(name) {\n  return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {\n    return offset ? letter.toUpperCase() : letter;\n  }).replace(MOZ_HACK_REGEXP, 'Moz$1');\n};\n/* istanbul ignore next */\n\n\nvar on = exports.on = function () {\n  if (!isServer && document.addEventListener) {\n    return function (element, event, handler) {\n      if (element && event && handler) {\n        element.addEventListener(event, handler, false);\n      }\n    };\n  } else {\n    return function (element, event, handler) {\n      if (element && event && handler) {\n        element.attachEvent('on' + event, handler);\n      }\n    };\n  }\n}();\n/* istanbul ignore next */\n\n\nvar off = exports.off = function () {\n  if (!isServer && document.removeEventListener) {\n    return function (element, event, handler) {\n      if (element && event) {\n        element.removeEventListener(event, handler, false);\n      }\n    };\n  } else {\n    return function (element, event, handler) {\n      if (element && event) {\n        element.detachEvent('on' + event, handler);\n      }\n    };\n  }\n}();\n/* istanbul ignore next */\n\n\nvar once = exports.once = function once(el, event, fn) {\n  var listener = function listener() {\n    if (fn) {\n      fn.apply(this, arguments);\n    }\n\n    off(el, event, listener);\n  };\n\n  on(el, event, listener);\n};\n/* istanbul ignore next */\n\n\nfunction hasClass(el, cls) {\n  if (!el || !cls) return false;\n  if (cls.indexOf(' ') !== -1) throw new Error('className should not contain space.');\n\n  if (el.classList) {\n    return el.classList.contains(cls);\n  } else {\n    return (' ' + el.className + ' ').indexOf(' ' + cls + ' ') > -1;\n  }\n}\n\n;\n/* istanbul ignore next */\n\nfunction addClass(el, cls) {\n  if (!el) return;\n  var curClass = el.className;\n  var classes = (cls || '').split(' ');\n\n  for (var i = 0, j = classes.length; i < j; i++) {\n    var clsName = classes[i];\n    if (!clsName) continue;\n\n    if (el.classList) {\n      el.classList.add(clsName);\n    } else if (!hasClass(el, clsName)) {\n      curClass += ' ' + clsName;\n    }\n  }\n\n  if (!el.classList) {\n    el.className = curClass;\n  }\n}\n\n;\n/* istanbul ignore next */\n\nfunction removeClass(el, cls) {\n  if (!el || !cls) return;\n  var classes = cls.split(' ');\n  var curClass = ' ' + el.className + ' ';\n\n  for (var i = 0, j = classes.length; i < j; i++) {\n    var clsName = classes[i];\n    if (!clsName) continue;\n\n    if (el.classList) {\n      el.classList.remove(clsName);\n    } else if (hasClass(el, clsName)) {\n      curClass = curClass.replace(' ' + clsName + ' ', ' ');\n    }\n  }\n\n  if (!el.classList) {\n    el.className = trim(curClass);\n  }\n}\n\n;\n/* istanbul ignore next */\n\nvar getStyle = exports.getStyle = ieVersion < 9 ? function (element, styleName) {\n  if (isServer) return;\n  if (!element || !styleName) return null;\n  styleName = camelCase(styleName);\n\n  if (styleName === 'float') {\n    styleName = 'styleFloat';\n  }\n\n  try {\n    switch (styleName) {\n      case 'opacity':\n        try {\n          return element.filters.item('alpha').opacity / 100;\n        } catch (e) {\n          return 1.0;\n        }\n\n      default:\n        return element.style[styleName] || element.currentStyle ? element.currentStyle[styleName] : null;\n    }\n  } catch (e) {\n    return element.style[styleName];\n  }\n} : function (element, styleName) {\n  if (isServer) return;\n  if (!element || !styleName) return null;\n  styleName = camelCase(styleName);\n\n  if (styleName === 'float') {\n    styleName = 'cssFloat';\n  }\n\n  try {\n    var computed = document.defaultView.getComputedStyle(element, '');\n    return element.style[styleName] || computed ? computed[styleName] : null;\n  } catch (e) {\n    return element.style[styleName];\n  }\n};\n/* istanbul ignore next */\n\nfunction setStyle(element, styleName, value) {\n  if (!element || !styleName) return;\n\n  if ((typeof styleName === 'undefined' ? 'undefined' : _typeof(styleName)) === 'object') {\n    for (var prop in styleName) {\n      if (styleName.hasOwnProperty(prop)) {\n        setStyle(element, prop, styleName[prop]);\n      }\n    }\n  } else {\n    styleName = camelCase(styleName);\n\n    if (styleName === 'opacity' && ieVersion < 9) {\n      element.style.filter = isNaN(value) ? '' : 'alpha(opacity=' + value * 100 + ')';\n    } else {\n      element.style[styleName] = value;\n    }\n  }\n}\n\n;\n\nvar isScroll = exports.isScroll = function isScroll(el, vertical) {\n  if (isServer) return;\n  var determinedDirection = vertical !== null || vertical !== undefined;\n  var overflow = determinedDirection ? vertical ? getStyle(el, 'overflow-y') : getStyle(el, 'overflow-x') : getStyle(el, 'overflow');\n  return overflow.match(/(scroll|auto)/);\n};\n\nvar getScrollContainer = exports.getScrollContainer = function getScrollContainer(el, vertical) {\n  if (isServer) return;\n  var parent = el;\n\n  while (parent) {\n    if ([window, document, document.documentElement].includes(parent)) {\n      return window;\n    }\n\n    if (isScroll(parent, vertical)) {\n      return parent;\n    }\n\n    parent = parent.parentNode;\n  }\n\n  return parent;\n};\n\nvar isInContainer = exports.isInContainer = function isInContainer(el, container) {\n  if (isServer || !el || !container) return false;\n  var elRect = el.getBoundingClientRect();\n  var containerRect = void 0;\n\n  if ([window, document, document.documentElement, null, undefined].includes(container)) {\n    containerRect = {\n      top: 0,\n      right: window.innerWidth,\n      bottom: window.innerHeight,\n      left: 0\n    };\n  } else {\n    containerRect = container.getBoundingClientRect();\n  }\n\n  return elRect.top < containerRect.bottom && elRect.bottom > containerRect.top && elRect.right > containerRect.left && elRect.left < containerRect.right;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdXRpbHMvZG9tLmpzPzU5MjQiXSwibmFtZXMiOlsiZXhwb3J0cyIsIl9fZXNNb2R1bGUiLCJpc0luQ29udGFpbmVyIiwiZ2V0U2Nyb2xsQ29udGFpbmVyIiwiaXNTY3JvbGwiLCJnZXRTdHlsZSIsIm9uY2UiLCJvZmYiLCJvbiIsInVuZGVmaW5lZCIsIl90eXBlb2YiLCJTeW1ib2wiLCJpdGVyYXRvciIsIm9iaiIsImNvbnN0cnVjdG9yIiwicHJvdG90eXBlIiwiaGFzQ2xhc3MiLCJhZGRDbGFzcyIsInJlbW92ZUNsYXNzIiwic2V0U3R5bGUiLCJfdnVlIiwicmVxdWlyZSIsIl92dWUyIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsImRlZmF1bHQiLCJpc1NlcnZlciIsIiRpc1NlcnZlciIsIlNQRUNJQUxfQ0hBUlNfUkVHRVhQIiwiTU9aX0hBQ0tfUkVHRVhQIiwiaWVWZXJzaW9uIiwiTnVtYmVyIiwiZG9jdW1lbnQiLCJkb2N1bWVudE1vZGUiLCJ0cmltIiwic3RyaW5nIiwicmVwbGFjZSIsImNhbWVsQ2FzZSIsIm5hbWUiLCJfIiwic2VwYXJhdG9yIiwibGV0dGVyIiwib2Zmc2V0IiwidG9VcHBlckNhc2UiLCJhZGRFdmVudExpc3RlbmVyIiwiZWxlbWVudCIsImV2ZW50IiwiaGFuZGxlciIsImF0dGFjaEV2ZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRldGFjaEV2ZW50IiwiZWwiLCJmbiIsImxpc3RlbmVyIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJjbHMiLCJpbmRleE9mIiwiRXJyb3IiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsImNsYXNzTmFtZSIsImN1ckNsYXNzIiwiY2xhc3NlcyIsInNwbGl0IiwiaSIsImoiLCJsZW5ndGgiLCJjbHNOYW1lIiwiYWRkIiwicmVtb3ZlIiwic3R5bGVOYW1lIiwiZmlsdGVycyIsIml0ZW0iLCJvcGFjaXR5IiwiZSIsInN0eWxlIiwiY3VycmVudFN0eWxlIiwiY29tcHV0ZWQiLCJkZWZhdWx0VmlldyIsImdldENvbXB1dGVkU3R5bGUiLCJ2YWx1ZSIsInByb3AiLCJoYXNPd25Qcm9wZXJ0eSIsImZpbHRlciIsImlzTmFOIiwidmVydGljYWwiLCJkZXRlcm1pbmVkRGlyZWN0aW9uIiwib3ZlcmZsb3ciLCJtYXRjaCIsInBhcmVudCIsIndpbmRvdyIsImRvY3VtZW50RWxlbWVudCIsImluY2x1ZGVzIiwicGFyZW50Tm9kZSIsImNvbnRhaW5lciIsImVsUmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNvbnRhaW5lclJlY3QiLCJ0b3AiLCJyaWdodCIsImlubmVyV2lkdGgiLCJib3R0b20iLCJpbm5lckhlaWdodCIsImxlZnQiXSwibWFwcGluZ3MiOiJBQUFhOztBQUViQSxPQUFPLENBQUNDLFVBQVIsR0FBcUIsSUFBckI7QUFDQUQsT0FBTyxDQUFDRSxhQUFSLEdBQXdCRixPQUFPLENBQUNHLGtCQUFSLEdBQTZCSCxPQUFPLENBQUNJLFFBQVIsR0FBbUJKLE9BQU8sQ0FBQ0ssUUFBUixHQUFtQkwsT0FBTyxDQUFDTSxJQUFSLEdBQWVOLE9BQU8sQ0FBQ08sR0FBUixHQUFjUCxPQUFPLENBQUNRLEVBQVIsR0FBYUMsU0FBckk7O0FBRUEsSUFBSUMsT0FBTyxHQUFHLE9BQU9DLE1BQVAsS0FBa0IsVUFBbEIsSUFBZ0MsT0FBT0EsTUFBTSxDQUFDQyxRQUFkLEtBQTJCLFFBQTNELEdBQXNFLFVBQVVDLEdBQVYsRUFBZTtBQUFFLFNBQU8sT0FBT0EsR0FBZDtBQUFvQixDQUEzRyxHQUE4RyxVQUFVQSxHQUFWLEVBQWU7QUFBRSxTQUFPQSxHQUFHLElBQUksT0FBT0YsTUFBUCxLQUFrQixVQUF6QixJQUF1Q0UsR0FBRyxDQUFDQyxXQUFKLEtBQW9CSCxNQUEzRCxJQUFxRUUsR0FBRyxLQUFLRixNQUFNLENBQUNJLFNBQXBGLEdBQWdHLFFBQWhHLEdBQTJHLE9BQU9GLEdBQXpIO0FBQStILENBQTVRO0FBQThROzs7QUFFOVFiLE9BQU8s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R0FBRztBQUNkQyxTQUFHLEVBQUUsQ0FEUztBQUVkQyxXQUFLLEVBQUVULE1BQU0sQ0FBQ1UsVUFGQTtBQUdkQyxZQUFNLEVBQUVYLE1BQU0sQ0FBQ1ksV0FIRDtBQUlkQyxVQUFJLEVBQUU7QUFKUSxLQUFoQjtBQU1ELEdBUEQsTUFPTztBQUNMTixpQkFBYSxHQUFHSCxTQUFTLENBQUNFLHFCQUFWLEVBQWhCO0FBQ0Q7O0FBRUQsU0FBT0QsTUFBTSxDQUFDRyxHQUFQLEdBQWFELGFBQWEsQ0FBQ0ksTUFBM0IsSUFBcUNOLE1BQU0sQ0FBQ00sTUFBUCxHQUFnQkosYUFBYSxDQUFDQyxHQUFuRSxJQUEwRUgsTUFBTSxDQUFDSSxLQUFQLEdBQWVGLGFBQWEsQ0FBQ00sSUFBdkcsSUFBK0dSLE1BQU0sQ0FBQ1EsSUFBUCxHQUFjTixhQUFhLENBQUNFLEtBQWxKO0FBQ0QsQ0FsQkQiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdXRpbHMvZG9tLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5pc0luQ29udGFpbmVyID0gZXhwb3J0cy5nZXRTY3JvbGxDb250YWluZXIgPSBleHBvcnRzLmlzU2Nyb2xsID0gZXhwb3J0cy5nZXRTdHlsZSA9IGV4cG9ydHMub25jZSA9IGV4cG9ydHMub2ZmID0gZXhwb3J0cy5vbiA9IHVuZGVmaW5lZDtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9OyAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuXG5leHBvcnRzLmhhc0NsYXNzID0gaGFzQ2xhc3M7XG5leHBvcnRzLmFkZENsYXNzID0gYWRkQ2xhc3M7XG5leHBvcnRzLnJlbW92ZUNsYXNzID0gcmVtb3ZlQ2xhc3M7XG5leHBvcnRzLnNldFN0eWxlID0gc2V0U3R5bGU7XG5cbnZhciBfdnVlID0gcmVxdWlyZSgndnVlJyk7XG5cbnZhciBfdnVlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Z1ZSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBpc1NlcnZlciA9IF92dWUyLmRlZmF1bHQucHJvdG90eXBlLiRpc1NlcnZlcjtcbnZhciBTUEVDSUFMX0NIQVJTX1JFR0VYUCA9IC8oW1xcOlxcLVxcX10rKC4pKS9nO1xudmFyIE1PWl9IQUNLX1JFR0VYUCA9IC9ebW96KFtBLVpdKS87XG52YXIgaWVWZXJzaW9uID0gaXNTZXJ2ZXIgPyAwIDogTnVtYmVyKGRvY3VtZW50LmRvY3VtZW50TW9kZSk7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG52YXIgdHJpbSA9IGZ1bmN0aW9uIHRyaW0oc3RyaW5nKSB7XG4gIHJldHVybiAoc3RyaW5nIHx8ICcnKS5yZXBsYWNlKC9eW1xcc1xcdUZFRkZdK3xbXFxzXFx1RkVGRl0rJC9nLCAnJyk7XG59O1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnZhciBjYW1lbENhc2UgPSBmdW5jdGlvbiBjYW1lbENhc2UobmFtZSkge1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKFNQRUNJQUxfQ0hBUlNfUkVHRVhQLCBmdW5jdGlvbiAoXywgc2VwYXJhdG9yLCBsZXR0ZXIsIG9mZnNldCkge1xuICAgIHJldHVybiBvZmZzZXQgPyBsZXR0ZXIudG9VcHBlckNhc2UoKSA6IGxldHRlcjtcbiAgfSkucmVwbGFjZShNT1pfSEFDS19SRUdFWFAsICdNb3okMScpO1xufTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnZhciBvbiA9IGV4cG9ydHMub24gPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghaXNTZXJ2ZXIgJiYgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgIGlmIChlbGVtZW50ICYmIGV2ZW50ICYmIGhhbmRsZXIpIHtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyKSB7XG4gICAgICBpZiAoZWxlbWVudCAmJiBldmVudCAmJiBoYW5kbGVyKSB7XG4gICAgICAgIGVsZW1lbnQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBoYW5kbGVyKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59KCk7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG52YXIgb2ZmID0gZXhwb3J0cy5vZmYgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICghaXNTZXJ2ZXIgJiYgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIpIHtcbiAgICAgIGlmIChlbGVtZW50ICYmIGV2ZW50KSB7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgaGFuZGxlciwgZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlbGVtZW50LCBldmVudCwgaGFuZGxlcikge1xuICAgICAgaWYgKGVsZW1lbnQgJiYgZXZlbnQpIHtcbiAgICAgICAgZWxlbWVudC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGhhbmRsZXIpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn0oKTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbnZhciBvbmNlID0gZXhwb3J0cy5vbmNlID0gZnVuY3Rpb24gb25jZShlbCwgZXZlbnQsIGZuKSB7XG4gIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIGxpc3RlbmVyKCkge1xuICAgIGlmIChmbikge1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgb2ZmKGVsLCBldmVudCwgbGlzdGVuZXIpO1xuICB9O1xuICBvbihlbCwgZXZlbnQsIGxpc3RlbmVyKTtcbn07XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBoYXNDbGFzcyhlbCwgY2xzKSB7XG4gIGlmICghZWwgfHwgIWNscykgcmV0dXJuIGZhbHNlO1xuICBpZiAoY2xzLmluZGV4T2YoJyAnKSAhPT0gLTEpIHRocm93IG5ldyBFcnJvcignY2xhc3NOYW1lIHNob3VsZCBub3QgY29udGFpbiBzcGFjZS4nKTtcbiAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgIHJldHVybiBlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xzKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gKCcgJyArIGVsLmNsYXNzTmFtZSArICcgJykuaW5kZXhPZignICcgKyBjbHMgKyAnICcpID4gLTE7XG4gIH1cbn07XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBhZGRDbGFzcyhlbCwgY2xzKSB7XG4gIGlmICghZWwpIHJldHVybjtcbiAgdmFyIGN1ckNsYXNzID0gZWwuY2xhc3NOYW1lO1xuICB2YXIgY2xhc3NlcyA9IChjbHMgfHwgJycpLnNwbGl0KCcgJyk7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgIHZhciBjbHNOYW1lID0gY2xhc3Nlc1tpXTtcbiAgICBpZiAoIWNsc05hbWUpIGNvbnRpbnVlO1xuXG4gICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgZWwuY2xhc3NMaXN0LmFkZChjbHNOYW1lKTtcbiAgICB9IGVsc2UgaWYgKCFoYXNDbGFzcyhlbCwgY2xzTmFtZSkpIHtcbiAgICAgIGN1ckNsYXNzICs9ICcgJyArIGNsc05hbWU7XG4gICAgfVxuICB9XG4gIGlmICghZWwuY2xhc3NMaXN0KSB7XG4gICAgZWwuY2xhc3NOYW1lID0gY3VyQ2xhc3M7XG4gIH1cbn07XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiByZW1vdmVDbGFzcyhlbCwgY2xzKSB7XG4gIGlmICghZWwgfHwgIWNscykgcmV0dXJuO1xuICB2YXIgY2xhc3NlcyA9IGNscy5zcGxpdCgnICcpO1xuICB2YXIgY3VyQ2xhc3MgPSAnICcgKyBlbC5jbGFzc05hbWUgKyAnICc7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSBjbGFzc2VzLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgIHZhciBjbHNOYW1lID0gY2xhc3Nlc1tpXTtcbiAgICBpZiAoIWNsc05hbWUpIGNvbnRpbnVlO1xuXG4gICAgaWYgKGVsLmNsYXNzTGlzdCkge1xuICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZShjbHNOYW1lKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NsYXNzKGVsLCBjbHNOYW1lKSkge1xuICAgICAgY3VyQ2xhc3MgPSBjdXJDbGFzcy5yZXBsYWNlKCcgJyArIGNsc05hbWUgKyAnICcsICcgJyk7XG4gICAgfVxuICB9XG4gIGlmICghZWwuY2xhc3NMaXN0KSB7XG4gICAgZWwuY2xhc3NOYW1lID0gdHJpbShjdXJDbGFzcyk7XG4gIH1cbn07XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG52YXIgZ2V0U3R5bGUgPSBleHBvcnRzLmdldFN0eWxlID0gaWVWZXJzaW9uIDwgOSA/IGZ1bmN0aW9uIChlbGVtZW50LCBzdHlsZU5hbWUpIHtcbiAgaWYgKGlzU2VydmVyKSByZXR1cm47XG4gIGlmICghZWxlbWVudCB8fCAhc3R5bGVOYW1lKSByZXR1cm4gbnVsbDtcbiAgc3R5bGVOYW1lID0gY2FtZWxDYXNlKHN0eWxlTmFtZSk7XG4gIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICBzdHlsZU5hbWUgPSAnc3R5bGVGbG9hdCc7XG4gIH1cbiAgdHJ5IHtcbiAgICBzd2l0Y2ggKHN0eWxlTmFtZSkge1xuICAgICAgY2FzZSAnb3BhY2l0eSc6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnQuZmlsdGVycy5pdGVtKCdhbHBoYScpLm9wYWNpdHkgLyAxMDA7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICByZXR1cm4gMS4wO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZWxlbWVudC5zdHlsZVtzdHlsZU5hbWVdIHx8IGVsZW1lbnQuY3VycmVudFN0eWxlID8gZWxlbWVudC5jdXJyZW50U3R5bGVbc3R5bGVOYW1lXSA6IG51bGw7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuc3R5bGVbc3R5bGVOYW1lXTtcbiAgfVxufSA6IGZ1bmN0aW9uIChlbGVtZW50LCBzdHlsZU5hbWUpIHtcbiAgaWYgKGlzU2VydmVyKSByZXR1cm47XG4gIGlmICghZWxlbWVudCB8fCAhc3R5bGVOYW1lKSByZXR1cm4gbnVsbDtcbiAgc3R5bGVOYW1lID0gY2FtZWxDYXNlKHN0eWxlTmFtZSk7XG4gIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICBzdHlsZU5hbWUgPSAnY3NzRmxvYXQnO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGNvbXB1dGVkID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50LCAnJyk7XG4gICAgcmV0dXJuIGVsZW1lbnQuc3R5bGVbc3R5bGVOYW1lXSB8fCBjb21wdXRlZCA/IGNvbXB1dGVkW3N0eWxlTmFtZV0gOiBudWxsO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuc3R5bGVbc3R5bGVOYW1lXTtcbiAgfVxufTtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIHNldFN0eWxlKGVsZW1lbnQsIHN0eWxlTmFtZSwgdmFsdWUpIHtcbiAgaWYgKCFlbGVtZW50IHx8ICFzdHlsZU5hbWUpIHJldHVybjtcblxuICBpZiAoKHR5cGVvZiBzdHlsZU5hbWUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKHN0eWxlTmFtZSkpID09PSAnb2JqZWN0Jykge1xuICAgIGZvciAodmFyIHByb3AgaW4gc3R5bGVOYW1lKSB7XG4gICAgICBpZiAoc3R5bGVOYW1lLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIHNldFN0eWxlKGVsZW1lbnQsIHByb3AsIHN0eWxlTmFtZVtwcm9wXSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0eWxlTmFtZSA9IGNhbWVsQ2FzZShzdHlsZU5hbWUpO1xuICAgIGlmIChzdHlsZU5hbWUgPT09ICdvcGFjaXR5JyAmJiBpZVZlcnNpb24gPCA5KSB7XG4gICAgICBlbGVtZW50LnN0eWxlLmZpbHRlciA9IGlzTmFOKHZhbHVlKSA/ICcnIDogJ2FscGhhKG9wYWNpdHk9JyArIHZhbHVlICogMTAwICsgJyknO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnN0eWxlW3N0eWxlTmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBpc1Njcm9sbCA9IGV4cG9ydHMuaXNTY3JvbGwgPSBmdW5jdGlvbiBpc1Njcm9sbChlbCwgdmVydGljYWwpIHtcbiAgaWYgKGlzU2VydmVyKSByZXR1cm47XG5cbiAgdmFyIGRldGVybWluZWREaXJlY3Rpb24gPSB2ZXJ0aWNhbCAhPT0gbnVsbCB8fCB2ZXJ0aWNhbCAhPT0gdW5kZWZpbmVkO1xuICB2YXIgb3ZlcmZsb3cgPSBkZXRlcm1pbmVkRGlyZWN0aW9uID8gdmVydGljYWwgPyBnZXRTdHlsZShlbCwgJ292ZXJmbG93LXknKSA6IGdldFN0eWxlKGVsLCAnb3ZlcmZsb3cteCcpIDogZ2V0U3R5bGUoZWwsICdvdmVyZmxvdycpO1xuXG4gIHJldHVybiBvdmVyZmxvdy5tYXRjaCgvKHNjcm9sbHxhdXRvKS8pO1xufTtcblxudmFyIGdldFNjcm9sbENvbnRhaW5lciA9IGV4cG9ydHMuZ2V0U2Nyb2xsQ29udGFpbmVyID0gZnVuY3Rpb24gZ2V0U2Nyb2xsQ29udGFpbmVyKGVsLCB2ZXJ0aWNhbCkge1xuICBpZiAoaXNTZXJ2ZXIpIHJldHVybjtcblxuICB2YXIgcGFyZW50ID0gZWw7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAoW3dpbmRvdywgZG9jdW1lbnQsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudF0uaW5jbHVkZXMocGFyZW50KSkge1xuICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gICAgaWYgKGlzU2Nyb2xsKHBhcmVudCwgdmVydGljYWwpKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50Tm9kZTtcbiAgfVxuXG4gIHJldHVybiBwYXJlbnQ7XG59O1xuXG52YXIgaXNJbkNvbnRhaW5lciA9IGV4cG9ydHMuaXNJbkNvbnRhaW5lciA9IGZ1bmN0aW9uIGlzSW5Db250YWluZXIoZWwsIGNvbnRhaW5lcikge1xuICBpZiAoaXNTZXJ2ZXIgfHwgIWVsIHx8ICFjb250YWluZXIpIHJldHVybiBmYWxzZTtcblxuICB2YXIgZWxSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBjb250YWluZXJSZWN0ID0gdm9pZCAwO1xuXG4gIGlmIChbd2luZG93LCBkb2N1bWVudCwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBudWxsLCB1bmRlZmluZWRdLmluY2x1ZGVzKGNvbnRhaW5lcikpIHtcbiAgICBjb250YWluZXJSZWN0ID0ge1xuICAgICAgdG9wOiAwLFxuICAgICAgcmlnaHQ6IHdpbmRvdy5pbm5lcldpZHRoLFxuICAgICAgYm90dG9tOiB3aW5kb3cuaW5uZXJIZWlnaHQsXG4gICAgICBsZWZ0OiAwXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXJSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG5cbiAgcmV0dXJuIGVsUmVjdC50b3AgPCBjb250YWluZXJSZWN0LmJvdHRvbSAmJiBlbFJlY3QuYm90dG9tID4gY29udGFpbmVyUmVjdC50b3AgJiYgZWxSZWN0LnJpZ2h0ID4gY29udGFpbmVyUmVjdC5sZWZ0ICYmIGVsUmVjdC5sZWZ0IDwgY29udGFpbmVyUmVjdC5yaWdodDtcbn07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/element-ui/lib/utils/dom.js\n");

/***/ }),

/***/ "./node_modules/element-ui/lib/utils/merge.js":
/*!****************************************************!*\
  !*** ./node_modules/element-ui/lib/utils/merge.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nexports.default = function (target) {\n  for (var i = 1, j = arguments.length; i < j; i++) {\n    var source = arguments[i] || {};\n\n    for (var prop in source) {\n      if (source.hasOwnProperty(prop)) {\n        var value = source[prop];\n\n        if (value !== undefined) {\n          target[prop] = value;\n        }\n      }\n    }\n  }\n\n  return target;\n};\n\n;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdXRpbHMvbWVyZ2UuanM/N2Y0ZCJdLCJuYW1lcyI6WyJleHBvcnRzIiwiX19lc01vZHVsZSIsImRlZmF1bHQiLCJ0YXJnZXQiLCJpIiwiaiIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNvdXJjZSIsInByb3AiLCJoYXNPd25Qcm9wZXJ0eSIsInZhbHVlIiwidW5kZWZpbmVkIl0sIm1hcHBpbmdzIjoiQUFBYTs7QUFFYkEsT0FBTyxDQUFDQyxVQUFSLEdBQXFCLElBQXJCOztBQUVBRCxPQUFPLENBQUNFLE9BQVIsR0FBa0IsVUFBVUMsTUFBVixFQUFrQjtBQUNsQyxPQUFLLElBQUlDLENBQUMsR0FBRyxDQUFSLEVBQVdDLENBQUMsR0FBR0MsU0FBUyxDQUFDQyxNQUE5QixFQUFzQ0gsQ0FBQyxHQUFHQyxDQUExQyxFQUE2Q0QsQ0FBQyxFQUE5QyxFQUFrRDtBQUNoRCxRQUFJSSxNQUFNLEdBQUdGLFNBQVMsQ0FBQ0YsQ0FBRCxDQUFULElBQWdCLEVBQTdCOztBQUNBLFNBQUssSUFBSUssSUFBVCxJQUFpQkQsTUFBakIsRUFBeUI7QUFDdkIsVUFBSUEsTUFBTSxDQUFDRSxjQUFQLENBQXNCRCxJQUF0QixDQUFKLEVBQWlDO0FBQy9CLFlBQUlFLEtBQUssR0FBR0gsTUFBTSxDQUFDQyxJQUFELENBQWxCOztBQUNBLFlBQUlFLEtBQUssS0FBS0MsU0FBZCxFQUF5QjtBQUN2QlQsZ0JBQU0sQ0FBQ00sSUFBRCxDQUFOLEdBQWVFLEtBQWY7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRCxTQUFPUixNQUFQO0FBQ0QsQ0FkRDs7QUFnQkEiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdXRpbHMvbWVyZ2UuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICBmb3IgKHZhciBpID0gMSwgaiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldIHx8IHt9O1xuICAgIGZvciAodmFyIHByb3AgaW4gc291cmNlKSB7XG4gICAgICBpZiAoc291cmNlLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtwcm9wXTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG47Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/element-ui/lib/utils/merge.js\n");

/***/ }),

/***/ "./node_modules/element-ui/lib/utils/popper.js":
/*!*****************************************************!*\
  !*** ./node_modules/element-ui/lib/utils/popper.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n/**\n * @fileOverview Kickass library to create and place poppers near their reference elements.\n * @version {{version}}\n * @license\n * Copyright (c) 2016 Federico Zivolo and contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n//\n// Cross module loader\n// Supported: Node, AMD, Browser globals\n//\n\n\n;\n\n(function (root, factory) {\n  if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(undefined, function () {\n  'use strict';\n\n  var root = window; // default options\n\n  var DEFAULTS = {\n    // placement of the popper\n    placement: 'bottom',\n    gpuAcceleration: true,\n    // shift popper from its origin by the given amount of pixels (can be negative)\n    offset: 0,\n    // the element which will act as boundary of the popper\n    boundariesElement: 'viewport',\n    // amount of pixel used to define a minimum distance between the boundaries and the popper\n    boundariesPadding: 5,\n    // popper will try to prevent overflow following this order,\n    // by default, then, it could overflow on the left and on top of the boundariesElement\n    preventOverflowOrder: ['left', 'right', 'top', 'bottom'],\n    // the behavior used by flip to change the placement of the popper\n    flipBehavior: 'flip',\n    arrowElement: '[x-arrow]',\n    arrowOffset: 0,\n    // list of functions used to modify the offsets before they are applied to the popper\n    modifiers: ['shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle'],\n    modifiersIgnored: [],\n    forceAbsolute: false\n  };\n  /**\n   * Create a new Popper.js instance\n   * @constructor Popper\n   * @param {HTMLElement} reference - The reference element used to position the popper\n   * @param {HTMLElement|Object} popper\n   *      The HTML element used as popper, or a configuration used to generate the popper.\n   * @param {String} [popper.tagName='div'] The tag name of the generated popper.\n   * @param {Array} [popper.classNames=['popper']] Array of classes to apply to the generated popper.\n   * @param {Array} [popper.attributes] Array of attributes to apply, specify `attr:value` to assign a value to it.\n   * @param {HTMLElement|String} [popper.parent=window.document.body] The parent element, given as HTMLElement or as query string.\n   * @param {String} [popper.content=''] The content of the popper, it can be text, html, or node; if it is not text, set `contentType` to `html` or `node`.\n   * @param {String} [popper.contentType='text'] If `html`, the `content` will be parsed as HTML. If `node`, it will be appended as-is.\n   * @param {String} [popper.arrowTagName='div'] Same as `popper.tagName` but for the arrow element.\n   * @param {Array} [popper.arrowClassNames='popper__arrow'] Same as `popper.classNames` but for the arrow element.\n   * @param {String} [popper.arrowAttributes=['x-arrow']] Same as `popper.attributes` but for the arrow element.\n   * @param {Object} options\n   * @param {String} [options.placement=bottom]\n   *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -right),\n   *      left(-start, -end)`\n   *\n   * @param {HTMLElement|String} [options.arrowElement='[x-arrow]']\n   *      The DOM Node used as arrow for the popper, or a CSS selector used to get the DOM node. It must be child of\n   *      its parent Popper. Popper.js will apply to the given element the style required to align the arrow with its\n   *      reference element.\n   *      By default, it will look for a child node of the popper with the `x-arrow` attribute.\n   *\n   * @param {Boolean} [options.gpuAcceleration=true]\n   *      When this property is set to true, the popper position will be applied using CSS3 translate3d, allowing the\n   *      browser to use the GPU to accelerate the rendering.\n   *      If set to false, the popper will be placed using `top` and `left` properties, not using the GPU.\n   *\n   * @param {Number} [options.offset=0]\n   *      Amount of pixels the popper will be shifted (can be negative).\n   *\n   * @param {String|Element} [options.boundariesElement='viewport']\n   *      The element which will define the boundaries of the popper position, the popper will never be placed outside\n   *      of the defined boundaries (except if `keepTogether` is enabled)\n   *\n   * @param {Number} [options.boundariesPadding=5]\n   *      Additional padding for the boundaries\n   *\n   * @param {Array} [options.preventOverflowOrder=['left', 'right', 'top', 'bottom']]\n   *      Order used when Popper.js tries to avoid overflows from the boundaries, they will be checked in order,\n   *      this means that the last ones will never overflow\n   *\n   * @param {String|Array} [options.flipBehavior='flip']\n   *      The behavior used by the `flip` modifier to change the placement of the popper when the latter is trying to\n   *      overlap its reference element. Defining `flip` as value, the placement will be flipped on\n   *      its axis (`right - left`, `top - bottom`).\n   *      You can even pass an array of placements (eg: `['right', 'left', 'top']` ) to manually specify\n   *      how alter the placement when a flip is needed. (eg. in the above example, it would first flip from right to left,\n   *      then, if even in its new placement, the popper is overlapping its reference element, it will be moved to top)\n   *\n   * @param {Array} [options.modifiers=[ 'shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle']]\n   *      List of functions used to modify the data before they are applied to the popper, add your custom functions\n   *      to this array to edit the offsets and placement.\n   *      The function should reflect the @params and @returns of preventOverflow\n   *\n   * @param {Array} [options.modifiersIgnored=[]]\n   *      Put here any built-in modifier name you want to exclude from the modifiers list\n   *      The function should reflect the @params and @returns of preventOverflow\n   *\n   * @param {Boolean} [options.removeOnDestroy=false]\n   *      Set to true if you want to automatically remove the popper when you call the `destroy` method.\n   */\n\n  function Popper(reference, popper, options) {\n    this._reference = reference.jquery ? reference[0] : reference;\n    this.state = {}; // if the popper variable is a configuration object, parse it to generate an HTMLElement\n    // generate a default popper if is not defined\n\n    var isNotDefined = typeof popper === 'undefined' || popper === null;\n    var isConfig = popper && Object.prototype.toString.call(popper) === '[object Object]';\n\n    if (isNotDefined || isConfig) {\n      this._popper = this.parse(isConfig ? popper : {});\n    } // otherwise, use the given HTMLElement as popper\n    else {\n        this._popper = popper.jquery ? popper[0] : popper;\n      } // with {} we create a new object with the options inside it\n\n\n    this._options = Object.assign({}, DEFAULTS, options); // refactoring modifiers' list\n\n    this._options.modifiers = this._options.modifiers.map(function (modifier) {\n      // remove ignored modifiers\n      if (this._options.modifiersIgnored.indexOf(modifier) !== -1) return; // set the x-placement attribute before everything else because it could be used to add margins to the popper\n      // margins needs to be calculated to get the correct popper offsets\n\n      if (modifier === 'applyStyle') {\n        this._popper.setAttribute('x-placement', this._options.placement);\n      } // return predefined modifier identified by string or keep the custom one\n\n\n      return this.modifiers[modifier] || modifier;\n    }.bind(this)); // make sure to apply the popper position before any computation\n\n    this.state.position = this._getPosition(this._popper, this._reference);\n    setStyle(this._popper, {\n      position: this.state.position,\n      top: 0\n    }); // fire the first update to position the popper in the right place\n\n    this.update(); // setup event listeners, they will take care of update the position in specific situations\n\n    this._setupEventListeners();\n\n    return this;\n  } //\n  // Methods\n  //\n\n  /**\n   * Destroy the popper\n   * @method\n   * @memberof Popper\n   */\n\n\n  Popper.prototype.destroy = function () {\n    this._popper.removeAttribute('x-placement');\n\n    this._popper.style.left = '';\n    this._popper.style.position = '';\n    this._popper.style.top = '';\n    this._popper.style[getSupportedPropertyName('transform')] = '';\n\n    this._removeEventListeners(); // remove the popper if user explicity asked for the deletion on destroy\n\n\n    if (this._options.removeOnDestroy) {\n      this._popper.remove();\n    }\n\n    return this;\n  };\n  /**\n   * Updates the position of the popper, computing the new offsets and applying the new style\n   * @method\n   * @memberof Popper\n   */\n\n\n  Popper.prototype.update = function () {\n    var data = {\n      instance: this,\n      styles: {}\n    }; // store placement inside the data object, modifiers will be able to edit `placement` if needed\n    // and refer to _originalPlacement to know the original value\n\n    data.placement = this._options.placement;\n    data._originalPlacement = this._options.placement; // compute the popper and reference offsets and put them inside data.offsets\n\n    data.offsets = this._getOffsets(this._popper, this._reference, data.placement); // get boundaries\n\n    data.boundaries = this._getBoundaries(data, this._options.boundariesPadding, this._options.boundariesElement);\n    data = this.runModifiers(data, this._options.modifiers);\n\n    if (typeof this.state.updateCallback === 'function') {\n      this.state.updateCallback(data);\n    }\n  };\n  /**\n   * If a function is passed, it will be executed after the initialization of popper with as first argument the Popper instance.\n   * @method\n   * @memberof Popper\n   * @param {Function} callback\n   */\n\n\n  Popper.prototype.onCreate = function (callback) {\n    // the createCallbacks return as first argument the popper instance\n    callback(this);\n    return this;\n  };\n  /**\n   * If a function is passed, it will be executed after each update of popper with as first argument the set of coordinates and informations\n   * used to style popper and its arrow.\n   * NOTE: it doesn't get fired on the first call of the `Popper.update()` method inside the `Popper` constructor!\n   * @method\n   * @memberof Popper\n   * @param {Function} callback\n   */\n\n\n  Popper.prototype.onUpdate = function (callback) {\n    this.state.updateCallback = callback;\n    return this;\n  };\n  /**\n   * Helper used to generate poppers from a configuration file\n   * @method\n   * @memberof Popper\n   * @param config {Object} configuration\n   * @returns {HTMLElement} popper\n   */\n\n\n  Popper.prototype.parse = function (config) {\n    var defaultConfig = {\n      tagName: 'div',\n      classNames: ['popper'],\n      attributes: [],\n      parent: root.document.body,\n      content: '',\n      contentType: 'text',\n      arrowTagName: 'div',\n      arrowClassNames: ['popper__arrow'],\n      arrowAttributes: ['x-arrow']\n    };\n    config = Object.assign({}, defaultConfig, config);\n    var d = root.document;\n    var popper = d.createElement(config.tagName);\n    addClassNames(popper, config.classNames);\n    addAttributes(popper, config.attributes);\n\n    if (config.contentType === 'node') {\n      popper.appendChild(config.content.jquery ? config.content[0] : config.content);\n    } else if (config.contentType === 'html') {\n      popper.innerHTML = config.content;\n    } else {\n      popper.textContent = config.content;\n    }\n\n    if (config.arrowTagName) {\n      var arrow = d.createElement(config.arrowTagName);\n      addClassNames(arrow, config.arrowClassNames);\n      addAttributes(arrow, config.arrowAttributes);\n      popper.appendChild(arrow);\n    }\n\n    var parent = config.parent.jquery ? config.parent[0] : config.parent; // if the given parent is a string, use it to match an element\n    // if more than one element is matched, the first one will be used as parent\n    // if no elements are matched, the script will throw an error\n\n    if (typeof parent === 'string') {\n      parent = d.querySelectorAll(config.parent);\n\n      if (parent.length > 1) {\n        console.warn('WARNING: the given `parent` query(' + config.parent + ') matched more than one element, the first one will be used');\n      }\n\n      if (parent.length === 0) {\n        throw 'ERROR: the given `parent` doesn\\'t exists!';\n      }\n\n      parent = parent[0];\n    } // if the given parent is a DOM nodes list or an array of nodes with more than one element,\n    // the first one will be used as parent\n\n\n    if (parent.length > 1 && parent instanceof Element === false) {\n      console.warn('WARNING: you have passed as parent a list of elements, the first one will be used');\n      parent = parent[0];\n    } // append the generated popper to its parent\n\n\n    parent.appendChild(popper);\n    return popper;\n    /**\n     * Adds class names to the given element\n     * @function\n     * @ignore\n     * @param {HTMLElement} target\n     * @param {Array} classes\n     */\n\n    function addClassNames(element, classNames) {\n      classNames.forEach(function (className) {\n        element.classList.add(className);\n      });\n    }\n    /**\n     * Adds attributes to the given element\n     * @function\n     * @ignore\n     * @param {HTMLElement} target\n     * @param {Array} attributes\n     * @example\n     * addAttributes(element, [ 'data-info:foobar' ]);\n     */\n\n\n    function addAttributes(element, attributes) {\n      attributes.forEach(function (attribute) {\n        element.setAttribute(attribute.split(':')[0], attribute.split(':')[1] || '');\n      });\n    }\n  };\n  /**\n   * Helper used to get the position which will be applied to the popper\n   * @method\n   * @memberof Popper\n   * @param config {HTMLElement} popper element\n   * @param reference {HTMLElement} reference element\n   * @returns {String} position\n   */\n\n\n  Popper.prototype._getPosition = function (popper, reference) {\n    var container = getOffsetParent(reference);\n\n    if (this._options.forceAbsolute) {\n      return 'absolute';\n    } // Decide if the popper will be fixed\n    // If the reference element is inside a fixed context, the popper will be fixed as well to allow them to scroll together\n\n\n    var isParentFixed = isFixed(reference, container);\n    return isParentFixed ? 'fixed' : 'absolute';\n  };\n  /**\n   * Get offsets to the popper\n   * @method\n   * @memberof Popper\n   * @access private\n   * @param {Element} popper - the popper element\n   * @param {Element} reference - the reference element (the popper will be relative to this)\n   * @returns {Object} An object containing the offsets which will be applied to the popper\n   */\n\n\n  Popper.prototype._getOffsets = function (popper, reference, placement) {\n    placement = placement.split('-')[0];\n    var popperOffsets = {};\n    popperOffsets.position = this.state.position;\n    var isParentFixed = popperOffsets.position === 'fixed'; //\n    // Get reference element position\n    //\n\n    var referenceOffsets = getOffsetRectRelativeToCustomParent(reference, getOffsetParent(popper), isParentFixed); //\n    // Get popper sizes\n    //\n\n    var popperRect = getOuterSizes(popper); //\n    // Compute offsets of popper\n    //\n    // depending by the popper placement we have to compute its offsets slightly differently\n\n    if (['right', 'left'].indexOf(placement) !== -1) {\n      popperOffsets.top = referenceOffsets.top + referenceOffsets.height / 2 - popperRect.height / 2;\n\n      if (placement === 'left') {\n        popperOffsets.left = referenceOffsets.left - popperRect.width;\n      } else {\n        popperOffsets.left = referenceOffsets.right;\n      }\n    } else {\n      popperOffsets.left = referenceOffsets.left + referenceOffsets.width / 2 - popperRect.width / 2;\n\n      if (placement === 'top') {\n        popperOffsets.top = referenceOffsets.top - popperRect.height;\n      } else {\n        popperOffsets.top = referenceOffsets.bottom;\n      }\n    } // Add width and height to our offsets object\n\n\n    popperOffsets.width = popperRect.width;\n    popperOffsets.height = popperRect.height;\n    return {\n      popper: popperOffsets,\n      reference: referenceOffsets\n    };\n  };\n  /**\n   * Setup needed event listeners used to update the popper position\n   * @method\n   * @memberof Popper\n   * @access private\n   */\n\n\n  Popper.prototype._setupEventListeners = function () {\n    // NOTE: 1 DOM access here\n    this.state.updateBound = this.update.bind(this);\n    root.addEventListener('resize', this.state.updateBound); // if the boundariesElement is window we don't need to listen for the scroll event\n\n    if (this._options.boundariesElement !== 'window') {\n      var target = getScrollParent(this._reference); // here it could be both `body` or `documentElement` thanks to Firefox, we then check both\n\n      if (target === root.document.body || target === root.document.documentElement) {\n        target = root;\n      }\n\n      target.addEventListener('scroll', this.state.updateBound);\n      this.state.scrollTarget = target;\n    }\n  };\n  /**\n   * Remove event listeners used to update the popper position\n   * @method\n   * @memberof Popper\n   * @access private\n   */\n\n\n  Popper.prototype._removeEventListeners = function () {\n    // NOTE: 1 DOM access here\n    root.removeEventListener('resize', this.state.updateBound);\n\n    if (this._options.boundariesElement !== 'window' && this.state.scrollTarget) {\n      this.state.scrollTarget.removeEventListener('scroll', this.state.updateBound);\n      this.state.scrollTarget = null;\n    }\n\n    this.state.updateBound = null;\n  };\n  /**\n   * Computed the boundaries limits and return them\n   * @method\n   * @memberof Popper\n   * @access private\n   * @param {Object} data - Object containing the property \"offsets\" generated by `_getOffsets`\n   * @param {Number} padding - Boundaries padding\n   * @param {Element} boundariesElement - Element used to define the boundaries\n   * @returns {Object} Coordinates of the boundaries\n   */\n\n\n  Popper.prototype._getBoundaries = function (data, padding, boundariesElement) {\n    // NOTE: 1 DOM access here\n    var boundaries = {};\n    var width, height;\n\n    if (boundariesElement === 'window') {\n      var body = root.document.body,\n          html = root.document.documentElement;\n      height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);\n      width = Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);\n      boundaries = {\n        top: 0,\n        right: width,\n        bottom: height,\n        left: 0\n      };\n    } else if (boundariesElement === 'viewport') {\n      var offsetParent = getOffsetParent(this._popper);\n      var scrollParent = getScrollParent(this._popper);\n      var offsetParentRect = getOffsetRect(offsetParent); // Thanks the fucking native API, `document.body.scrollTop` & `document.documentElement.scrollTop`\n\n      var getScrollTopValue = function getScrollTopValue(element) {\n        return element == document.body ? Math.max(document.documentElement.scrollTop, document.body.scrollTop) : element.scrollTop;\n      };\n\n      var getScrollLeftValue = function getScrollLeftValue(element) {\n        return element == document.body ? Math.max(document.documentElement.scrollLeft, document.body.scrollLeft) : element.scrollLeft;\n      }; // if the popper is fixed we don't have to substract scrolling from the boundaries\n\n\n      var scrollTop = data.offsets.popper.position === 'fixed' ? 0 : getScrollTopValue(scrollParent);\n      var scrollLeft = data.offsets.popper.position === 'fixed' ? 0 : getScrollLeftValue(scrollParent);\n      boundaries = {\n        top: 0 - (offsetParentRect.top - scrollTop),\n        right: root.document.documentElement.clientWidth - (offsetParentRect.left - scrollLeft),\n        bottom: root.document.documentElement.clientHeight - (offsetParentRect.top - scrollTop),\n        left: 0 - (offsetParentRect.left - scrollLeft)\n      };\n    } else {\n      if (getOffsetParent(this._popper) === boundariesElement) {\n        boundaries = {\n          top: 0,\n          left: 0,\n          right: boundariesElement.clientWidth,\n          bottom: boundariesElement.clientHeight\n        };\n      } else {\n        boundaries = getOffsetRect(boundariesElement);\n      }\n    }\n\n    boundaries.left += padding;\n    boundaries.right -= padding;\n    boundaries.top = boundaries.top + padding;\n    boundaries.bottom = boundaries.bottom - padding;\n    return boundaries;\n  };\n  /**\n   * Loop trough the list of modifiers and run them in order, each of them will then edit the data object\n   * @method\n   * @memberof Popper\n   * @access public\n   * @param {Object} data\n   * @param {Array} modifiers\n   * @param {Function} ends\n   */\n\n\n  Popper.prototype.runModifiers = function (data, modifiers, ends) {\n    var modifiersToRun = modifiers.slice();\n\n    if (ends !== undefined) {\n      modifiersToRun = this._options.modifiers.slice(0, getArrayKeyIndex(this._options.modifiers, ends));\n    }\n\n    modifiersToRun.forEach(function (modifier) {\n      if (isFunction(modifier)) {\n        data = modifier.call(this, data);\n      }\n    }.bind(this));\n    return data;\n  };\n  /**\n   * Helper used to know if the given modifier depends from another one.\n   * @method\n   * @memberof Popper\n   * @param {String} requesting - name of requesting modifier\n   * @param {String} requested - name of requested modifier\n   * @returns {Boolean}\n   */\n\n\n  Popper.prototype.isModifierRequired = function (requesting, requested) {\n    var index = getArrayKeyIndex(this._options.modifiers, requesting);\n    return !!this._options.modifiers.slice(0, index).filter(function (modifier) {\n      return modifier === requested;\n    }).length;\n  }; //\n  // Modifiers\n  //\n\n  /**\n   * Modifiers list\n   * @namespace Popper.modifiers\n   * @memberof Popper\n   * @type {Object}\n   */\n\n\n  Popper.prototype.modifiers = {};\n  /**\n   * Apply the computed styles to the popper element\n   * @method\n   * @memberof Popper.modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @returns {Object} The same data object\n   */\n\n  Popper.prototype.modifiers.applyStyle = function (data) {\n    // apply the final offsets to the popper\n    // NOTE: 1 DOM access here\n    var styles = {\n      position: data.offsets.popper.position\n    }; // round top and left to avoid blurry text\n\n    var left = Math.round(data.offsets.popper.left);\n    var top = Math.round(data.offsets.popper.top); // if gpuAcceleration is set to true and transform is supported, we use `translate3d` to apply the position to the popper\n    // we automatically use the supported prefixed version if needed\n\n    var prefixedProperty;\n\n    if (this._options.gpuAcceleration && (prefixedProperty = getSupportedPropertyName('transform'))) {\n      styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n      styles.top = 0;\n      styles.left = 0;\n    } // othwerise, we use the standard `left` and `top` properties\n    else {\n        styles.left = left;\n        styles.top = top;\n      } // any property present in `data.styles` will be applied to the popper,\n    // in this way we can make the 3rd party modifiers add custom styles to it\n    // Be aware, modifiers could override the properties defined in the previous\n    // lines of this modifier!\n\n\n    Object.assign(styles, data.styles);\n    setStyle(this._popper, styles); // set an attribute which will be useful to style the tooltip (use it to properly position its arrow)\n    // NOTE: 1 DOM access here\n\n    this._popper.setAttribute('x-placement', data.placement); // if the arrow modifier is required and the arrow style has been computed, apply the arrow style\n\n\n    if (this.isModifierRequired(this.modifiers.applyStyle, this.modifiers.arrow) && data.offsets.arrow) {\n      setStyle(data.arrowElement, data.offsets.arrow);\n    }\n\n    return data;\n  };\n  /**\n   * Modifier used to shift the popper on the start or end of its reference element side\n   * @method\n   * @memberof Popper.modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @returns {Object} The data object, properly modified\n   */\n\n\n  Popper.prototype.modifiers.shift = function (data) {\n    var placement = data.placement;\n    var basePlacement = placement.split('-')[0];\n    var shiftVariation = placement.split('-')[1]; // if shift shiftVariation is specified, run the modifier\n\n    if (shiftVariation) {\n      var reference = data.offsets.reference;\n      var popper = getPopperClientRect(data.offsets.popper);\n      var shiftOffsets = {\n        y: {\n          start: {\n            top: reference.top\n          },\n          end: {\n            top: reference.top + reference.height - popper.height\n          }\n        },\n        x: {\n          start: {\n            left: reference.left\n          },\n          end: {\n            left: reference.left + reference.width - popper.width\n          }\n        }\n      };\n      var axis = ['bottom', 'top'].indexOf(basePlacement) !== -1 ? 'x' : 'y';\n      data.offsets.popper = Object.assign(popper, shiftOffsets[axis][shiftVariation]);\n    }\n\n    return data;\n  };\n  /**\n   * Modifier used to make sure the popper does not overflows from it's boundaries\n   * @method\n   * @memberof Popper.modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @returns {Object} The data object, properly modified\n   */\n\n\n  Popper.prototype.modifiers.preventOverflow = function (data) {\n    var order = this._options.preventOverflowOrder;\n    var popper = getPopperClientRect(data.offsets.popper);\n    var check = {\n      left: function left() {\n        var left = popper.left;\n\n        if (popper.left < data.boundaries.left) {\n          left = Math.max(popper.left, data.boundaries.left);\n        }\n\n        return {\n          left: left\n        };\n      },\n      right: function right() {\n        var left = popper.left;\n\n        if (popper.right > data.boundaries.right) {\n          left = Math.min(popper.left, data.boundaries.right - popper.width);\n        }\n\n        return {\n          left: left\n        };\n      },\n      top: function top() {\n        var top = popper.top;\n\n        if (popper.top < data.boundaries.top) {\n          top = Math.max(popper.top, data.boundaries.top);\n        }\n\n        return {\n          top: top\n        };\n      },\n      bottom: function bottom() {\n        var top = popper.top;\n\n        if (popper.bottom > data.boundaries.bottom) {\n          top = Math.min(popper.top, data.boundaries.bottom - popper.height);\n        }\n\n        return {\n          top: top\n        };\n      }\n    };\n    order.forEach(function (direction) {\n      data.offsets.popper = Object.assign(popper, check[direction]());\n    });\n    return data;\n  };\n  /**\n   * Modifier used to make sure the popper is always near its reference\n   * @method\n   * @memberof Popper.modifiers\n   * @argument {Object} data - The data object generated by _update method\n   * @returns {Object} The data object, properly modified\n   */\n\n\n  Popper.prototype.modifiers.keepTogether = function (data) {\n    var popper = getPopperClientRect(data.offsets.popper);\n    var reference = data.offsets.reference;\n    var f = Math.floor;\n\n    if (popper.right < f(reference.left)) {\n      data.offsets.popper.left = f(reference.left) - popper.width;\n    }\n\n    if (popper.left > f(reference.right)) {\n      data.offsets.popper.left = f(reference.right);\n    }\n\n    if (popper.bottom < f(reference.top)) {\n      data.offsets.popper.top = f(reference.top) - popper.height;\n    }\n\n    if (popper.top > f(reference.bottom)) {\n      data.offsets.popper.top = f(reference.bottom);\n    }\n\n    return data;\n  };\n  /**\n   * Modifier used to flip the placement of the popper when the latter is starting overlapping its reference element.\n   * Requires the `preventOverflow` modifier before it in order to work.\n   * **NOTE:** This modifier will run all its previous modifiers everytime it tries to flip the popper!\n   * @method\n   * @memberof Popper.modifiers\n   * @argument {Object} data - The data object generated by _update method\n   * @returns {Object} The data object, properly modified\n   */\n\n\n  Popper.prototype.modifiers.flip = function (data) {\n    // check if preventOverflow is in the list of modifiers before the flip modifier.\n    // otherwise flip would not work as expected.\n    if (!this.isModifierRequired(this.modifiers.flip, this.modifiers.preventOverflow)) {\n      console.warn('WARNING: preventOverflow modifier is required by flip modifier in order to work, be sure to include it before flip!');\n      return data;\n    }\n\n    if (data.flipped && data.placement === data._originalPlacement) {\n      // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n      return data;\n    }\n\n    var placement = data.placement.split('-')[0];\n    var placementOpposite = getOppositePlacement(placement);\n    var variation = data.placement.split('-')[1] || '';\n    var flipOrder = [];\n\n    if (this._options.flipBehavior === 'flip') {\n      flipOrder = [placement, placementOpposite];\n    } else {\n      flipOrder = this._options.flipBehavior;\n    }\n\n    flipOrder.forEach(function (step, index) {\n      if (placement !== step || flipOrder.length === index + 1) {\n        return;\n      }\n\n      placement = data.placement.split('-')[0];\n      placementOpposite = getOppositePlacement(placement);\n      var popperOffsets = getPopperClientRect(data.offsets.popper); // this boolean is used to distinguish right and bottom from top and left\n      // they need different computations to get flipped\n\n      var a = ['right', 'bottom'].indexOf(placement) !== -1; // using Math.floor because the reference offsets may contain decimals we are not going to consider here\n\n      if (a && Math.floor(data.offsets.reference[placement]) > Math.floor(popperOffsets[placementOpposite]) || !a && Math.floor(data.offsets.reference[placement]) < Math.floor(popperOffsets[placementOpposite])) {\n        // we'll use this boolean to detect any flip loop\n        data.flipped = true;\n        data.placement = flipOrder[index + 1];\n\n        if (variation) {\n          data.placement += '-' + variation;\n        }\n\n        data.offsets.popper = this._getOffsets(this._popper, this._reference, data.placement).popper;\n        data = this.runModifiers(data, this._options.modifiers, this._flip);\n      }\n    }.bind(this));\n    return data;\n  };\n  /**\n   * Modifier used to add an offset to the popper, useful if you more granularity positioning your popper.\n   * The offsets will shift the popper on the side of its reference element.\n   * @method\n   * @memberof Popper.modifiers\n   * @argument {Object} data - The data object generated by _update method\n   * @returns {Object} The data object, properly modified\n   */\n\n\n  Popper.prototype.modifiers.offset = function (data) {\n    var offset = this._options.offset;\n    var popper = data.offsets.popper;\n\n    if (data.placement.indexOf('left') !== -1) {\n      popper.top -= offset;\n    } else if (data.placement.indexOf('right') !== -1) {\n      popper.top += offset;\n    } else if (data.placement.indexOf('top') !== -1) {\n      popper.left -= offset;\n    } else if (data.placement.indexOf('bottom') !== -1) {\n      popper.left += offset;\n    }\n\n    return data;\n  };\n  /**\n   * Modifier used to move the arrows on the edge of the popper to make sure them are always between the popper and the reference element\n   * It will use the CSS outer size of the arrow element to know how many pixels of conjuction are needed\n   * @method\n   * @memberof Popper.modifiers\n   * @argument {Object} data - The data object generated by _update method\n   * @returns {Object} The data object, properly modified\n   */\n\n\n  Popper.prototype.modifiers.arrow = function (data) {\n    var arrow = this._options.arrowElement;\n    var arrowOffset = this._options.arrowOffset; // if the arrowElement is a string, suppose it's a CSS selector\n\n    if (typeof arrow === 'string') {\n      arrow = this._popper.querySelector(arrow);\n    } // if arrow element is not found, don't run the modifier\n\n\n    if (!arrow) {\n      return data;\n    } // the arrow element must be child of its popper\n\n\n    if (!this._popper.contains(arrow)) {\n      console.warn('WARNING: `arrowElement` must be child of its popper element!');\n      return data;\n    } // arrow depends on keepTogether in order to work\n\n\n    if (!this.isModifierRequired(this.modifiers.arrow, this.modifiers.keepTogether)) {\n      console.warn('WARNING: keepTogether modifier is required by arrow modifier in order to work, be sure to include it before arrow!');\n      return data;\n    }\n\n    var arrowStyle = {};\n    var placement = data.placement.split('-')[0];\n    var popper = getPopperClientRect(data.offsets.popper);\n    var reference = data.offsets.reference;\n    var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n    var len = isVertical ? 'height' : 'width';\n    var side = isVertical ? 'top' : 'left';\n    var translate = isVertical ? 'translateY' : 'translateX';\n    var altSide = isVertical ? 'left' : 'top';\n    var opSide = isVertical ? 'bottom' : 'right';\n    var arrowSize = getOuterSizes(arrow)[len]; //\n    // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction\n    //\n    // top/left side\n\n    if (reference[opSide] - arrowSize < popper[side]) {\n      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowSize);\n    } // bottom/right side\n\n\n    if (reference[side] + arrowSize > popper[opSide]) {\n      data.offsets.popper[side] += reference[side] + arrowSize - popper[opSide];\n    } // compute center of the popper\n\n\n    var center = reference[side] + (arrowOffset || reference[len] / 2 - arrowSize / 2);\n    var sideValue = center - popper[side]; // prevent arrow from being placed not contiguously to its popper\n\n    sideValue = Math.max(Math.min(popper[len] - arrowSize - 8, sideValue), 8);\n    arrowStyle[side] = sideValue;\n    arrowStyle[altSide] = ''; // make sure to remove any old style from the arrow\n\n    data.offsets.arrow = arrowStyle;\n    data.arrowElement = arrow;\n    return data;\n  }; //\n  // Helpers\n  //\n\n  /**\n   * Get the outer sizes of the given element (offset size + margins)\n   * @function\n   * @ignore\n   * @argument {Element} element\n   * @returns {Object} object containing width and height properties\n   */\n\n\n  function getOuterSizes(element) {\n    // NOTE: 1 DOM access here\n    var _display = element.style.display,\n        _visibility = element.style.visibility;\n    element.style.display = 'block';\n    element.style.visibility = 'hidden';\n    var calcWidthToForceRepaint = element.offsetWidth; // original method\n\n    var styles = root.getComputedStyle(element);\n    var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);\n    var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);\n    var result = {\n      width: element.offsetWidth + y,\n      height: element.offsetHeight + x\n    }; // reset element styles\n\n    element.style.display = _display;\n    element.style.visibility = _visibility;\n    return result;\n  }\n  /**\n   * Get the opposite placement of the given one/\n   * @function\n   * @ignore\n   * @argument {String} placement\n   * @returns {String} flipped placement\n   */\n\n\n  function getOppositePlacement(placement) {\n    var hash = {\n      left: 'right',\n      right: 'left',\n      bottom: 'top',\n      top: 'bottom'\n    };\n    return placement.replace(/left|right|bottom|top/g, function (matched) {\n      return hash[matched];\n    });\n  }\n  /**\n   * Given the popper offsets, generate an output similar to getBoundingClientRect\n   * @function\n   * @ignore\n   * @argument {Object} popperOffsets\n   * @returns {Object} ClientRect like output\n   */\n\n\n  function getPopperClientRect(popperOffsets) {\n    var offsets = Object.assign({}, popperOffsets);\n    offsets.right = offsets.left + offsets.width;\n    offsets.bottom = offsets.top + offsets.height;\n    return offsets;\n  }\n  /**\n   * Given an array and the key to find, returns its index\n   * @function\n   * @ignore\n   * @argument {Array} arr\n   * @argument keyToFind\n   * @returns index or null\n   */\n\n\n  function getArrayKeyIndex(arr, keyToFind) {\n    var i = 0,\n        key;\n\n    for (key in arr) {\n      if (arr[key] === keyToFind) {\n        return i;\n      }\n\n      i++;\n    }\n\n    return null;\n  }\n  /**\n   * Get CSS computed property of the given element\n   * @function\n   * @ignore\n   * @argument {Eement} element\n   * @argument {String} property\n   */\n\n\n  function getStyleComputedProperty(element, property) {\n    // NOTE: 1 DOM access here\n    var css = root.getComputedStyle(element, null);\n    return css[property];\n  }\n  /**\n   * Returns the offset parent of the given element\n   * @function\n   * @ignore\n   * @argument {Element} element\n   * @returns {Element} offset parent\n   */\n\n\n  function getOffsetParent(element) {\n    // NOTE: 1 DOM access here\n    var offsetParent = element.offsetParent;\n    return offsetParent === root.document.body || !offsetParent ? root.document.documentElement : offsetParent;\n  }\n  /**\n   * Returns the scrolling parent of the given element\n   * @function\n   * @ignore\n   * @argument {Element} element\n   * @returns {Element} offset parent\n   */\n\n\n  function getScrollParent(element) {\n    var parent = element.parentNode;\n\n    if (!parent) {\n      return element;\n    }\n\n    if (parent === root.document) {\n      // Firefox puts the scrollTOp value on `documentElement` instead of `body`, we then check which of them is\n      // greater than 0 and return the proper element\n      if (root.document.body.scrollTop || root.document.body.scrollLeft) {\n        return root.document.body;\n      } else {\n        return root.document.documentElement;\n      }\n    } // Firefox want us to check `-x` and `-y` variations as well\n\n\n    if (['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow')) !== -1 || ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow-x')) !== -1 || ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow-y')) !== -1) {\n      // If the detected scrollParent is body, we perform an additional check on its parentNode\n      // in this way we'll get body if the browser is Chrome-ish, or documentElement otherwise\n      // fixes issue #65\n      return parent;\n    }\n\n    return getScrollParent(element.parentNode);\n  }\n  /**\n   * Check if the given element is fixed or is inside a fixed parent\n   * @function\n   * @ignore\n   * @argument {Element} element\n   * @argument {Element} customContainer\n   * @returns {Boolean} answer to \"isFixed?\"\n   */\n\n\n  function isFixed(element) {\n    if (element === root.document.body) {\n      return false;\n    }\n\n    if (getStyleComputedProperty(element, 'position') === 'fixed') {\n      return true;\n    }\n\n    return element.parentNode ? isFixed(element.parentNode) : element;\n  }\n  /**\n   * Set the style to the given popper\n   * @function\n   * @ignore\n   * @argument {Element} element - Element to apply the style to\n   * @argument {Object} styles - Object with a list of properties and values which will be applied to the element\n   */\n\n\n  function setStyle(element, styles) {\n    function is_numeric(n) {\n      return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n    }\n\n    Object.keys(styles).forEach(function (prop) {\n      var unit = ''; // add unit if the value is numeric and is one of the following\n\n      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && is_numeric(styles[prop])) {\n        unit = 'px';\n      }\n\n      element.style[prop] = styles[prop] + unit;\n    });\n  }\n  /**\n   * Check if the given variable is a function\n   * @function\n   * @ignore\n   * @argument {*} functionToCheck - variable to check\n   * @returns {Boolean} answer to: is a function?\n   */\n\n\n  function isFunction(functionToCheck) {\n    var getType = {};\n    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n  }\n  /**\n   * Get the position of the given element, relative to its offset parent\n   * @function\n   * @ignore\n   * @param {Element} element\n   * @return {Object} position - Coordinates of the element and its `scrollTop`\n   */\n\n\n  function getOffsetRect(element) {\n    var elementRect = {\n      width: element.offsetWidth,\n      height: element.offsetHeight,\n      left: element.offsetLeft,\n      top: element.offsetTop\n    };\n    elementRect.right = elementRect.left + elementRect.width;\n    elementRect.bottom = elementRect.top + elementRect.height; // position\n\n    return elementRect;\n  }\n  /**\n   * Get bounding client rect of given element\n   * @function\n   * @ignore\n   * @param {HTMLElement} element\n   * @return {Object} client rect\n   */\n\n\n  function getBoundingClientRect(element) {\n    var rect = element.getBoundingClientRect(); // whether the IE version is lower than 11\n\n    var isIE = navigator.userAgent.indexOf(\"MSIE\") != -1; // fix ie document bounding top always 0 bug\n\n    var rectTop = isIE && element.tagName === 'HTML' ? -element.scrollTop : rect.top;\n    return {\n      left: rect.left,\n      top: rectTop,\n      right: rect.right,\n      bottom: rect.bottom,\n      width: rect.right - rect.left,\n      height: rect.bottom - rectTop\n    };\n  }\n  /**\n   * Given an element and one of its parents, return the offset\n   * @function\n   * @ignore\n   * @param {HTMLElement} element\n   * @param {HTMLElement} parent\n   * @return {Object} rect\n   */\n\n\n  function getOffsetRectRelativeToCustomParent(element, parent, fixed) {\n    var elementRect = getBoundingClientRect(element);\n    var parentRect = getBoundingClientRect(parent);\n\n    if (fixed) {\n      var scrollParent = getScrollParent(parent);\n      parentRect.top += scrollParent.scrollTop;\n      parentRect.bottom += scrollParent.scrollTop;\n      parentRect.left += scrollParent.scrollLeft;\n      parentRect.right += scrollParent.scrollLeft;\n    }\n\n    var rect = {\n      top: elementRect.top - parentRect.top,\n      left: elementRect.left - parentRect.left,\n      bottom: elementRect.top - parentRect.top + elementRect.height,\n      right: elementRect.left - parentRect.left + elementRect.width,\n      width: elementRect.width,\n      height: elementRect.height\n    };\n    return rect;\n  }\n  /**\n   * Get the prefixed supported property name\n   * @function\n   * @ignore\n   * @argument {String} property (camelCase)\n   * @returns {String} prefixed property (camelCase)\n   */\n\n\n  function getSupportedPropertyName(property) {\n    var prefixes = ['', 'ms', 'webkit', 'moz', 'o'];\n\n    for (var i = 0; i < prefixes.length; i++) {\n      var toCheck = prefixes[i] ? prefixes[i] + property.charAt(0).toUpperCase() + property.slice(1) : property;\n\n      if (typeof root.document.body.style[toCheck] !== 'undefined') {\n        return toCheck;\n      }\n    }\n\n    return null;\n  }\n  /**\n   * The Object.assign() method is used to copy the values of all enumerable own properties from one or more source\n   * objects to a target object. It will return the target object.\n   * This polyfill doesn't support symbol properties, since ES5 doesn't have symbols anyway\n   * Source: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\n   * @function\n   * @ignore\n   */\n\n\n  if (!Object.assign) {\n    Object.defineProperty(Object, 'assign', {\n      enumerable: false,\n      configurable: true,\n      writable: true,\n      value: function value(target) {\n        if (target === undefined || target === null) {\n          throw new TypeError('Cannot convert first argument to object');\n        }\n\n        var to = Object(target);\n\n        for (var i = 1; i < arguments.length; i++) {\n          var nextSource = arguments[i];\n\n          if (nextSource === undefined || nextSource === null) {\n            continue;\n          }\n\n          nextSource = Object(nextSource);\n          var keysArray = Object.keys(nextSource);\n\n          for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {\n            var nextKey = keysArray[nextIndex];\n            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);\n\n            if (desc !== undefined && desc.enumerable) {\n              to[nextKey] = nextSource[nextKey];\n            }\n          }\n        }\n\n        return to;\n      }\n    });\n  }\n\n  return Popper;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdXRpbHMvcG9wcGVyLmpzPzYxNjciXSwibmFtZXMiOlsiX3R5cGVvZiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwib2JqIiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJyb290IiwiZmFjdG9yeSIsImRlZmluZSIsInVuZGVmaW5lZCIsIndpbmRvdyIsIkRFRkFVTFRTIiwicGxhY2VtZW50IiwiZ3B1QWNjZWxlcmF0aW9uIiwib2Zmc2V0IiwiYm91bmRhcmllc0VsZW1lbnQiLCJib3VuZGFyaWVzUGFkZGluZyIsInByZXZlbnRPdmVyZmxvd09yZGVyIiwiZmxpcEJlaGF2aW9yIiwiYXJyb3dFbGVtZW50IiwiYXJyb3dPZmZzZXQiLCJtb2RpZmllcnMiLCJtb2RpZmllcnNJZ25vcmVkIiwiZm9yY2VBYnNvbHV0ZSIsIlBvcHBlciIsInJlZmVyZW5jZSIsInBvcHBlciIsIm9wdGlvbnMiLCJfcmVmZXJlbmNlIiwianF1ZXJ5Iiwic3RhdGUiLCJpc05vdERlZmluZWQiLCJpc0NvbmZpZyIsIk9iamVjdCIsInRvU3RyaW5nIiwiY2FsbCIsIl9wb3BwZXIiLCJwYXJzZSIsIl9vcHRpb25zIiwiYXNzaWduIiwibWFwIiwibW9kaWZpZXIiLCJpbmRleE9mIiwic2V0QXR0cmlidXRlIiwiYmluZCIsInBvc2l0aW9uIiwiX2dldFBvc2l0aW9uIiwic2V0U3R5bGUiLCJ0b3AiLCJ1cGRhdGUiLCJfc2V0dXBFdmVudExpc3RlbmVycyIsImRlc3Ryb3kiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzdHlsZSIsImxlZnQiLCJnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUiLCJfcmVtb3ZlRXZlbnRMaXN0ZW5lcnMiLCJyZW1vdmVPbkRlc3Ryb3kiLCJyZW1vdmUiLCJkYXRhIiwiaW5zdGFuY2UiLCJzdHlsZXMiLCJfb3JpZ2luYWxQbGFjZW1lbnQiLCJvZmZzZXRzIiwiX2dldE9mZnNldHMiLCJib3VuZGFyaWVzIiwiX2dldEJvdW5kYXJpZXMiLCJydW5Nb2RpZmllcnMiLCJ1cGRhdGVDYWxsYmFjayIsIm9uQ3JlYXRlIiwiY2FsbGJhY2siLCJvblVwZGF0ZSIsImNvbmZpZyIsImRlZmF1bHRDb25maWciLCJ0YWdOYW1lIiwiY2xhc3NOYW1lcyIsImF0dHJpYnV0ZXMiLCJwYXJlbnQiLCJkb2N1bWVudCIsImJvZHkiLCJjb250ZW50IiwiY29udGVudFR5cGUiLCJhcnJvd1RhZ05hbWUiLCJhcnJvd0NsYXNzTmFtZXMiLCJhcnJvd0F0dHJpYnV0ZXMiLCJkIiwiY3JlYXRlRWxlbWVudCIsImFkZENsYXNzTmFtZXMiLCJhZGRBdHRyaWJ1dGVzIiwiYXBwZW5kQ2hpbGQiLCJpbm5lckhUTUwiLCJ0ZXh0Q29udGVudCIsImFycm93IiwicXVlcnlTZWxlY3RvckFsbCIsImxlbmd0aCIsImNvbnNvbGUiLCJ3YXJuIiwiRWxlbWVudCIsImVsZW1lbnQiLCJmb3JFYWNoIiwiY2xhc3NOYW1lIiwiY2xhc3NMaXN0IiwiYWRkIiwiYXR0cmlidXRlIiwic3BsaXQiLCJjb250YWluZXIiLCJnZXRPZmZzZXRQYXJlbnQiLCJpc1BhcmVudEZpeGVkIiwiaXNGaXhlZCIsInBvcHBlck9mZnNldHMiLCJyZWZlcmVuY2VPZmZzZXRzIiwiZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9DdXN0b21QYXJlbnQiLCJwb3BwZXJSZWN0IiwiZ2V0T3V0ZXJTaXplcyIsImhlaWdodCIsIndpZHRoIiwicmlnaHQiLCJib3R0b20iLCJ1cGRhdGVCb3VuZCIsImFkZEV2ZW50TGlzdGVuZXIiLCJ0YXJnZXQiLCJnZXRTY3JvbGxQYXJlbnQiLCJkb2N1bWVudEVsZW1lbnQiLCJzY3JvbGxUYXJnZXQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicGFkZGluZyIsImh0bWwiLCJNYXRoIiwibWF4Iiwic2Nyb2xsSGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0IiwiY2xpZW50SGVpZ2h0Iiwic2Nyb2xsV2lkdGgiLCJvZmZzZXRXaWR0aCIsImNsaWVudFdpZHRoIiwib2Zmc2V0UGFyZW50Iiwic2Nyb2xsUGFyZW50Iiwib2Zmc2V0UGFyZW50UmVjdCIsImdldE9mZnNldFJlY3QiLCJnZXRTY3JvbGxUb3BWYWx1ZSIsInNjcm9sbFRvcCIsImdldFNjcm9sbExlZnRWYWx1ZSIsInNjcm9sbExlZnQiLCJlbmRzIiwibW9kaWZpZXJzVG9SdW4iLCJzbGljZSIsImdldEFycmF5S2V5SW5kZXgiLCJpc0Z1bmN0aW9uIiwiaXNNb2RpZmllclJlcXVpcmVkIiwicmVxdWVzdGluZyIsInJlcXVlc3RlZCIsImluZGV4IiwiZmlsdGVyIiwiYXBwbHlTdHlsZSIsInJvdW5kIiwicHJlZml4ZWRQcm9wZXJ0eSIsInNoaWZ0IiwiYmFzZVBsYWNlbWVudCIsInNoaWZ0VmFyaWF0aW9uIiwiZ2V0UG9wcGVyQ2xpZW50UmVjdCIsInNoaWZ0T2Zmc2V0cyIsInkiLCJzdGFydCIsImVuZCIsIngiLCJheGlzIiwicHJldmVudE92ZXJmbG93Iiwib3JkZXIiLCJjaGVjayIsIm1pbiIsImRpcmVjdGlvbiIsImtlZXBUb2dldGhlciIsImYiLCJmbG9vciIsImZsaXAiLCJmbGlwcGVkIiwicGxhY2VtZW50T3Bwb3NpdGUiLCJnZXRPcHBvc2l0ZVBsYWNlbWVudCIsInZhcmlhdGlvbiIsImZsaXBPcmRlciIsInN0ZXAiLCJhIiwiX2ZsaXAiLCJxdWVyeVNlbGVjdG9yIiwiY29udGFpbnMiLCJhcnJvd1N0eWxlIiwiaXNWZXJ0aWNhbCIsImxlbiIsInNpZGUiLCJ0cmFuc2xhdGUiLCJhbHRTaWRlIiwib3BTaWRlIiwiYXJyb3dTaXplIiwiY2VudGVyIiwic2lkZVZhbHVlIiwiX2Rpc3BsYXkiLCJkaXNwbGF5IiwiX3Zpc2liaWxpdHkiLCJ2aXNpYmlsaXR5IiwiY2FsY1dpZHRoVG9Gb3JjZVJlcGFpbnQiLCJnZXRDb21wdXRlZFN0eWxlIiwicGFyc2VGbG9hdCIsIm1hcmdpblRvcCIsIm1hcmdpbkJvdHRvbSIsIm1hcmdpbkxlZnQiLCJtYXJnaW5SaWdodCIsInJlc3VsdCIsImhhc2giLCJyZXBsYWNlIiwibWF0Y2hlZCIsImFyciIsImtleVRvRmluZCIsImkiLCJrZXkiLCJnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkiLCJwcm9wZXJ0eSIsImNzcyIsInBhcmVudE5vZGUiLCJpc19udW1lcmljIiwibiIsImlzTmFOIiwiaXNGaW5pdGUiLCJrZXlzIiwicHJvcCIsInVuaXQiLCJmdW5jdGlvblRvQ2hlY2siLCJnZXRUeXBlIiwiZWxlbWVudFJlY3QiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0VG9wIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicmVjdCIsImlzSUUiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJyZWN0VG9wIiwiZml4ZWQiLCJwYXJlbnRSZWN0IiwicHJlZml4ZXMiLCJ0b0NoZWNrIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsInZhbHVlIiwiVHlwZUVycm9yIiwidG8iLCJhcmd1bWVudHMiLCJuZXh0U291cmNlIiwia2V5c0FycmF5IiwibmV4dEluZGV4IiwibmV4dEtleSIsImRlc2MiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiXSwibWFwcGluZ3MiOiJBQUFBLGtFQUFhOztBQUViLElBQUlBLE9BQU8sR0FBRyxPQUFPQyxNQUFQLEtBQWtCLFVBQWxCLElBQWdDLE9BQU9BLE1BQU0sQ0FBQ0MsUUFBZCxLQUEyQixRQUEzRCxHQUFzRSxVQUFVQyxHQUFWLEVBQWU7QUFBRSxTQUFPLE9BQU9BLEdBQWQ7QUFBb0IsQ0FBM0csR0FBOEcsVUFBVUEsR0FBVixFQUFlO0FBQUUsU0FBT0EsR0FBRyxJQUFJLE9BQU9GLE1BQVAsS0FBa0IsVUFBekIsSUFBdUNFLEdBQUcsQ0FBQ0MsV0FBSixLQUFvQkgsTUFBM0QsSUFBcUVFLEdBQUcsS0FBS0YsTUFBTSxDQUFDSSxTQUFwRixHQUFnRyxRQUFoRyxHQUEyRyxPQUFPRixHQUF6SDtBQUErSCxDQUE1UTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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LElBQVAsQ0FBWTRCLFVBQVosQ0FBaEI7O0FBQ0EsZUFBSyxJQUFJRSxTQUFTLEdBQUcsQ0FBaEIsRUFBbUJqRSxHQUFHLEdBQUdnRSxTQUFTLENBQUM3SixNQUF4QyxFQUFnRDhKLFNBQVMsR0FBR2pFLEdBQTVELEVBQWlFaUUsU0FBUyxFQUExRSxFQUE4RTtBQUMxRSxnQkFBSUMsT0FBTyxHQUFHRixTQUFTLENBQUNDLFNBQUQsQ0FBdkI7QUFDQSxnQkFBSUUsSUFBSSxHQUFHN04sTUFBTSxDQUFDOE4sd0JBQVAsQ0FBZ0NMLFVBQWhDLEVBQTRDRyxPQUE1QyxDQUFYOztBQUNBLGdCQUFJQyxJQUFJLEtBQUtyUCxTQUFULElBQXNCcVAsSUFBSSxDQUFDWCxVQUEvQixFQUEyQztBQUN2Q0ssZ0JBQUUsQ0FBQ0ssT0FBRCxDQUFGLEdBQWNILFVBQVUsQ0FBQ0csT0FBRCxDQUF4QjtBQUNIO0FBQ0o7QUFDSjs7QUFDRCxlQUFPTCxFQUFQO0FBQ0g7QUEzQm1DLEtBQXhDO0FBNkJIOztBQUVELFNBQU9oTyxNQUFQO0FBQ0gsQ0Ezc0NBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvbGliL3V0aWxzL3BvcHBlci5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG4vKipcbiAqIEBmaWxlT3ZlcnZpZXcgS2lja2FzcyBsaWJyYXJ5IHRvIGNyZWF0ZSBhbmQgcGxhY2UgcG9wcGVycyBuZWFyIHRoZWlyIHJlZmVyZW5jZSBlbGVtZW50cy5cbiAqIEB2ZXJzaW9uIHt7dmVyc2lvbn19XG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE2IEZlZGVyaWNvIFppdm9sbyBhbmQgY29udHJpYnV0b3JzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuXG4vL1xuLy8gQ3Jvc3MgbW9kdWxlIGxvYWRlclxuLy8gU3VwcG9ydGVkOiBOb2RlLCBBTUQsIEJyb3dzZXIgZ2xvYmFsc1xuLy9cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRC4gUmVnaXN0ZXIgYXMgYW4gYW5vbnltb3VzIG1vZHVsZS5cbiAgICAgICAgZGVmaW5lKGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBtb2R1bGUgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKG1vZHVsZSkpID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgICAvLyBOb2RlLiBEb2VzIG5vdCB3b3JrIHdpdGggc3RyaWN0IENvbW1vbkpTLCBidXRcbiAgICAgICAgLy8gb25seSBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB0aGF0IHN1cHBvcnQgbW9kdWxlLmV4cG9ydHMsXG4gICAgICAgIC8vIGxpa2UgTm9kZS5cbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzIChyb290IGlzIHdpbmRvdylcbiAgICAgICAgcm9vdC5Qb3BwZXIgPSBmYWN0b3J5KCk7XG4gICAgfVxufSkodW5kZWZpbmVkLCBmdW5jdGlvbiAoKSB7XG5cbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgcm9vdCA9IHdpbmRvdztcblxuICAgIC8vIGRlZmF1bHQgb3B0aW9uc1xuICAgIHZhciBERUZBVUxUUyA9IHtcbiAgICAgICAgLy8gcGxhY2VtZW50IG9mIHRoZSBwb3BwZXJcbiAgICAgICAgcGxhY2VtZW50OiAnYm90dG9tJyxcblxuICAgICAgICBncHVBY2NlbGVyYXRpb246IHRydWUsXG5cbiAgICAgICAgLy8gc2hpZnQgcG9wcGVyIGZyb20gaXRzIG9yaWdpbiBieSB0aGUgZ2l2ZW4gYW1vdW50IG9mIHBpeGVscyAoY2FuIGJlIG5lZ2F0aXZlKVxuICAgICAgICBvZmZzZXQ6IDAsXG5cbiAgICAgICAgLy8gdGhlIGVsZW1lbnQgd2hpY2ggd2lsbCBhY3QgYXMgYm91bmRhcnkgb2YgdGhlIHBvcHBlclxuICAgICAgICBib3VuZGFyaWVzRWxlbWVudDogJ3ZpZXdwb3J0JyxcblxuICAgICAgICAvLyBhbW91bnQgb2YgcGl4ZWwgdXNlZCB0byBkZWZpbmUgYSBtaW5pbXVtIGRpc3RhbmNlIGJldHdlZW4gdGhlIGJvdW5kYXJpZXMgYW5kIHRoZSBwb3BwZXJcbiAgICAgICAgYm91bmRhcmllc1BhZGRpbmc6IDUsXG5cbiAgICAgICAgLy8gcG9wcGVyIHdpbGwgdHJ5IHRvIHByZXZlbnQgb3ZlcmZsb3cgZm9sbG93aW5nIHRoaXMgb3JkZXIsXG4gICAgICAgIC8vIGJ5IGRlZmF1bHQsIHRoZW4sIGl0IGNvdWxkIG92ZXJmbG93IG9uIHRoZSBsZWZ0IGFuZCBvbiB0b3Agb2YgdGhlIGJvdW5kYXJpZXNFbGVtZW50XG4gICAgICAgIHByZXZlbnRPdmVyZmxvd09yZGVyOiBbJ2xlZnQnLCAncmlnaHQnLCAndG9wJywgJ2JvdHRvbSddLFxuXG4gICAgICAgIC8vIHRoZSBiZWhhdmlvciB1c2VkIGJ5IGZsaXAgdG8gY2hhbmdlIHRoZSBwbGFjZW1lbnQgb2YgdGhlIHBvcHBlclxuICAgICAgICBmbGlwQmVoYXZpb3I6ICdmbGlwJyxcblxuICAgICAgICBhcnJvd0VsZW1lbnQ6ICdbeC1hcnJvd10nLFxuXG4gICAgICAgIGFycm93T2Zmc2V0OiAwLFxuXG4gICAgICAgIC8vIGxpc3Qgb2YgZnVuY3Rpb25zIHVzZWQgdG8gbW9kaWZ5IHRoZSBvZmZzZXRzIGJlZm9yZSB0aGV5IGFyZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAgICAgICAgbW9kaWZpZXJzOiBbJ3NoaWZ0JywgJ29mZnNldCcsICdwcmV2ZW50T3ZlcmZsb3cnLCAna2VlcFRvZ2V0aGVyJywgJ2Fycm93JywgJ2ZsaXAnLCAnYXBwbHlTdHlsZSddLFxuXG4gICAgICAgIG1vZGlmaWVyc0lnbm9yZWQ6IFtdLFxuXG4gICAgICAgIGZvcmNlQWJzb2x1dGU6IGZhbHNlXG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBQb3BwZXIuanMgaW5zdGFuY2VcbiAgICAgKiBAY29uc3RydWN0b3IgUG9wcGVyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBlbGVtZW50IHVzZWQgdG8gcG9zaXRpb24gdGhlIHBvcHBlclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8T2JqZWN0fSBwb3BwZXJcbiAgICAgKiAgICAgIFRoZSBIVE1MIGVsZW1lbnQgdXNlZCBhcyBwb3BwZXIsIG9yIGEgY29uZmlndXJhdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZSBwb3BwZXIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwb3BwZXIudGFnTmFtZT0nZGl2J10gVGhlIHRhZyBuYW1lIG9mIHRoZSBnZW5lcmF0ZWQgcG9wcGVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwb3BwZXIuY2xhc3NOYW1lcz1bJ3BvcHBlciddXSBBcnJheSBvZiBjbGFzc2VzIHRvIGFwcGx5IHRvIHRoZSBnZW5lcmF0ZWQgcG9wcGVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwb3BwZXIuYXR0cmlidXRlc10gQXJyYXkgb2YgYXR0cmlidXRlcyB0byBhcHBseSwgc3BlY2lmeSBgYXR0cjp2YWx1ZWAgdG8gYXNzaWduIGEgdmFsdWUgdG8gaXQuXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxTdHJpbmd9IFtwb3BwZXIucGFyZW50PXdpbmRvdy5kb2N1bWVudC5ib2R5XSBUaGUgcGFyZW50IGVsZW1lbnQsIGdpdmVuIGFzIEhUTUxFbGVtZW50IG9yIGFzIHF1ZXJ5IHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BvcHBlci5jb250ZW50PScnXSBUaGUgY29udGVudCBvZiB0aGUgcG9wcGVyLCBpdCBjYW4gYmUgdGV4dCwgaHRtbCwgb3Igbm9kZTsgaWYgaXQgaXMgbm90IHRleHQsIHNldCBgY29udGVudFR5cGVgIHRvIGBodG1sYCBvciBgbm9kZWAuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtwb3BwZXIuY29udGVudFR5cGU9J3RleHQnXSBJZiBgaHRtbGAsIHRoZSBgY29udGVudGAgd2lsbCBiZSBwYXJzZWQgYXMgSFRNTC4gSWYgYG5vZGVgLCBpdCB3aWxsIGJlIGFwcGVuZGVkIGFzLWlzLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBbcG9wcGVyLmFycm93VGFnTmFtZT0nZGl2J10gU2FtZSBhcyBgcG9wcGVyLnRhZ05hbWVgIGJ1dCBmb3IgdGhlIGFycm93IGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BvcHBlci5hcnJvd0NsYXNzTmFtZXM9J3BvcHBlcl9fYXJyb3cnXSBTYW1lIGFzIGBwb3BwZXIuY2xhc3NOYW1lc2AgYnV0IGZvciB0aGUgYXJyb3cgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gW3BvcHBlci5hcnJvd0F0dHJpYnV0ZXM9Wyd4LWFycm93J11dIFNhbWUgYXMgYHBvcHBlci5hdHRyaWJ1dGVzYCBidXQgZm9yIHRoZSBhcnJvdyBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLnBsYWNlbWVudD1ib3R0b21dXG4gICAgICogICAgICBQbGFjZW1lbnQgb2YgdGhlIHBvcHBlciBhY2NlcHRlZCB2YWx1ZXM6IGB0b3AoLXN0YXJ0LCAtZW5kKSwgcmlnaHQoLXN0YXJ0LCAtZW5kKSwgYm90dG9tKC1zdGFydCwgLXJpZ2h0KSxcbiAgICAgKiAgICAgIGxlZnQoLXN0YXJ0LCAtZW5kKWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8U3RyaW5nfSBbb3B0aW9ucy5hcnJvd0VsZW1lbnQ9J1t4LWFycm93XSddXG4gICAgICogICAgICBUaGUgRE9NIE5vZGUgdXNlZCBhcyBhcnJvdyBmb3IgdGhlIHBvcHBlciwgb3IgYSBDU1Mgc2VsZWN0b3IgdXNlZCB0byBnZXQgdGhlIERPTSBub2RlLiBJdCBtdXN0IGJlIGNoaWxkIG9mXG4gICAgICogICAgICBpdHMgcGFyZW50IFBvcHBlci4gUG9wcGVyLmpzIHdpbGwgYXBwbHkgdG8gdGhlIGdpdmVuIGVsZW1lbnQgdGhlIHN0eWxlIHJlcXVpcmVkIHRvIGFsaWduIHRoZSBhcnJvdyB3aXRoIGl0c1xuICAgICAqICAgICAgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAgICogICAgICBCeSBkZWZhdWx0LCBpdCB3aWxsIGxvb2sgZm9yIGEgY2hpbGQgbm9kZSBvZiB0aGUgcG9wcGVyIHdpdGggdGhlIGB4LWFycm93YCBhdHRyaWJ1dGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmdwdUFjY2VsZXJhdGlvbj10cnVlXVxuICAgICAqICAgICAgV2hlbiB0aGlzIHByb3BlcnR5IGlzIHNldCB0byB0cnVlLCB0aGUgcG9wcGVyIHBvc2l0aW9uIHdpbGwgYmUgYXBwbGllZCB1c2luZyBDU1MzIHRyYW5zbGF0ZTNkLCBhbGxvd2luZyB0aGVcbiAgICAgKiAgICAgIGJyb3dzZXIgdG8gdXNlIHRoZSBHUFUgdG8gYWNjZWxlcmF0ZSB0aGUgcmVuZGVyaW5nLlxuICAgICAqICAgICAgSWYgc2V0IHRvIGZhbHNlLCB0aGUgcG9wcGVyIHdpbGwgYmUgcGxhY2VkIHVzaW5nIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllcywgbm90IHVzaW5nIHRoZSBHUFUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMub2Zmc2V0PTBdXG4gICAgICogICAgICBBbW91bnQgb2YgcGl4ZWxzIHRoZSBwb3BwZXIgd2lsbCBiZSBzaGlmdGVkIChjYW4gYmUgbmVnYXRpdmUpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8RWxlbWVudH0gW29wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQ9J3ZpZXdwb3J0J11cbiAgICAgKiAgICAgIFRoZSBlbGVtZW50IHdoaWNoIHdpbGwgZGVmaW5lIHRoZSBib3VuZGFyaWVzIG9mIHRoZSBwb3BwZXIgcG9zaXRpb24sIHRoZSBwb3BwZXIgd2lsbCBuZXZlciBiZSBwbGFjZWQgb3V0c2lkZVxuICAgICAqICAgICAgb2YgdGhlIGRlZmluZWQgYm91bmRhcmllcyAoZXhjZXB0IGlmIGBrZWVwVG9nZXRoZXJgIGlzIGVuYWJsZWQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYm91bmRhcmllc1BhZGRpbmc9NV1cbiAgICAgKiAgICAgIEFkZGl0aW9uYWwgcGFkZGluZyBmb3IgdGhlIGJvdW5kYXJpZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnByZXZlbnRPdmVyZmxvd09yZGVyPVsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ11dXG4gICAgICogICAgICBPcmRlciB1c2VkIHdoZW4gUG9wcGVyLmpzIHRyaWVzIHRvIGF2b2lkIG92ZXJmbG93cyBmcm9tIHRoZSBib3VuZGFyaWVzLCB0aGV5IHdpbGwgYmUgY2hlY2tlZCBpbiBvcmRlcixcbiAgICAgKiAgICAgIHRoaXMgbWVhbnMgdGhhdCB0aGUgbGFzdCBvbmVzIHdpbGwgbmV2ZXIgb3ZlcmZsb3dcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBbb3B0aW9ucy5mbGlwQmVoYXZpb3I9J2ZsaXAnXVxuICAgICAqICAgICAgVGhlIGJlaGF2aW9yIHVzZWQgYnkgdGhlIGBmbGlwYCBtb2RpZmllciB0byBjaGFuZ2UgdGhlIHBsYWNlbWVudCBvZiB0aGUgcG9wcGVyIHdoZW4gdGhlIGxhdHRlciBpcyB0cnlpbmcgdG9cbiAgICAgKiAgICAgIG92ZXJsYXAgaXRzIHJlZmVyZW5jZSBlbGVtZW50LiBEZWZpbmluZyBgZmxpcGAgYXMgdmFsdWUsIHRoZSBwbGFjZW1lbnQgd2lsbCBiZSBmbGlwcGVkIG9uXG4gICAgICogICAgICBpdHMgYXhpcyAoYHJpZ2h0IC0gbGVmdGAsIGB0b3AgLSBib3R0b21gKS5cbiAgICAgKiAgICAgIFlvdSBjYW4gZXZlbiBwYXNzIGFuIGFycmF5IG9mIHBsYWNlbWVudHMgKGVnOiBgWydyaWdodCcsICdsZWZ0JywgJ3RvcCddYCApIHRvIG1hbnVhbGx5IHNwZWNpZnlcbiAgICAgKiAgICAgIGhvdyBhbHRlciB0aGUgcGxhY2VtZW50IHdoZW4gYSBmbGlwIGlzIG5lZWRlZC4gKGVnLiBpbiB0aGUgYWJvdmUgZXhhbXBsZSwgaXQgd291bGQgZmlyc3QgZmxpcCBmcm9tIHJpZ2h0IHRvIGxlZnQsXG4gICAgICogICAgICB0aGVuLCBpZiBldmVuIGluIGl0cyBuZXcgcGxhY2VtZW50LCB0aGUgcG9wcGVyIGlzIG92ZXJsYXBwaW5nIGl0cyByZWZlcmVuY2UgZWxlbWVudCwgaXQgd2lsbCBiZSBtb3ZlZCB0byB0b3ApXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5tb2RpZmllcnM9WyAnc2hpZnQnLCAnb2Zmc2V0JywgJ3ByZXZlbnRPdmVyZmxvdycsICdrZWVwVG9nZXRoZXInLCAnYXJyb3cnLCAnZmxpcCcsICdhcHBseVN0eWxlJ11dXG4gICAgICogICAgICBMaXN0IG9mIGZ1bmN0aW9ucyB1c2VkIHRvIG1vZGlmeSB0aGUgZGF0YSBiZWZvcmUgdGhleSBhcmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLCBhZGQgeW91ciBjdXN0b20gZnVuY3Rpb25zXG4gICAgICogICAgICB0byB0aGlzIGFycmF5IHRvIGVkaXQgdGhlIG9mZnNldHMgYW5kIHBsYWNlbWVudC5cbiAgICAgKiAgICAgIFRoZSBmdW5jdGlvbiBzaG91bGQgcmVmbGVjdCB0aGUgQHBhcmFtcyBhbmQgQHJldHVybnMgb2YgcHJldmVudE92ZXJmbG93XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbb3B0aW9ucy5tb2RpZmllcnNJZ25vcmVkPVtdXVxuICAgICAqICAgICAgUHV0IGhlcmUgYW55IGJ1aWx0LWluIG1vZGlmaWVyIG5hbWUgeW91IHdhbnQgdG8gZXhjbHVkZSBmcm9tIHRoZSBtb2RpZmllcnMgbGlzdFxuICAgICAqICAgICAgVGhlIGZ1bmN0aW9uIHNob3VsZCByZWZsZWN0IHRoZSBAcGFyYW1zIGFuZCBAcmV0dXJucyBvZiBwcmV2ZW50T3ZlcmZsb3dcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVtb3ZlT25EZXN0cm95PWZhbHNlXVxuICAgICAqICAgICAgU2V0IHRvIHRydWUgaWYgeW91IHdhbnQgdG8gYXV0b21hdGljYWxseSByZW1vdmUgdGhlIHBvcHBlciB3aGVuIHlvdSBjYWxsIHRoZSBgZGVzdHJveWAgbWV0aG9kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFBvcHBlcihyZWZlcmVuY2UsIHBvcHBlciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLl9yZWZlcmVuY2UgPSByZWZlcmVuY2UuanF1ZXJ5ID8gcmVmZXJlbmNlWzBdIDogcmVmZXJlbmNlO1xuICAgICAgICB0aGlzLnN0YXRlID0ge307XG5cbiAgICAgICAgLy8gaWYgdGhlIHBvcHBlciB2YXJpYWJsZSBpcyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0LCBwYXJzZSBpdCB0byBnZW5lcmF0ZSBhbiBIVE1MRWxlbWVudFxuICAgICAgICAvLyBnZW5lcmF0ZSBhIGRlZmF1bHQgcG9wcGVyIGlmIGlzIG5vdCBkZWZpbmVkXG4gICAgICAgIHZhciBpc05vdERlZmluZWQgPSB0eXBlb2YgcG9wcGVyID09PSAndW5kZWZpbmVkJyB8fCBwb3BwZXIgPT09IG51bGw7XG4gICAgICAgIHZhciBpc0NvbmZpZyA9IHBvcHBlciAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwocG9wcGVyKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgICAgIGlmIChpc05vdERlZmluZWQgfHwgaXNDb25maWcpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvcHBlciA9IHRoaXMucGFyc2UoaXNDb25maWcgPyBwb3BwZXIgOiB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb3RoZXJ3aXNlLCB1c2UgdGhlIGdpdmVuIEhUTUxFbGVtZW50IGFzIHBvcHBlclxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3BwZXIgPSBwb3BwZXIuanF1ZXJ5ID8gcG9wcGVyWzBdIDogcG9wcGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIC8vIHdpdGgge30gd2UgY3JlYXRlIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvcHRpb25zIGluc2lkZSBpdFxuICAgICAgICB0aGlzLl9vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVFMsIG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIHJlZmFjdG9yaW5nIG1vZGlmaWVycycgbGlzdFxuICAgICAgICB0aGlzLl9vcHRpb25zLm1vZGlmaWVycyA9IHRoaXMuX29wdGlvbnMubW9kaWZpZXJzLm1hcChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBpZ25vcmVkIG1vZGlmaWVyc1xuICAgICAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMubW9kaWZpZXJzSWdub3JlZC5pbmRleE9mKG1vZGlmaWVyKSAhPT0gLTEpIHJldHVybjtcblxuICAgICAgICAgICAgLy8gc2V0IHRoZSB4LXBsYWNlbWVudCBhdHRyaWJ1dGUgYmVmb3JlIGV2ZXJ5dGhpbmcgZWxzZSBiZWNhdXNlIGl0IGNvdWxkIGJlIHVzZWQgdG8gYWRkIG1hcmdpbnMgdG8gdGhlIHBvcHBlclxuICAgICAgICAgICAgLy8gbWFyZ2lucyBuZWVkcyB0byBiZSBjYWxjdWxhdGVkIHRvIGdldCB0aGUgY29ycmVjdCBwb3BwZXIgb2Zmc2V0c1xuICAgICAgICAgICAgaWYgKG1vZGlmaWVyID09PSAnYXBwbHlTdHlsZScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3BwZXIuc2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcsIHRoaXMuX29wdGlvbnMucGxhY2VtZW50KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gcmV0dXJuIHByZWRlZmluZWQgbW9kaWZpZXIgaWRlbnRpZmllZCBieSBzdHJpbmcgb3Iga2VlcCB0aGUgY3VzdG9tIG9uZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubW9kaWZpZXJzW21vZGlmaWVyXSB8fCBtb2RpZmllcjtcbiAgICAgICAgfS5iaW5kKHRoaXMpKTtcblxuICAgICAgICAvLyBtYWtlIHN1cmUgdG8gYXBwbHkgdGhlIHBvcHBlciBwb3NpdGlvbiBiZWZvcmUgYW55IGNvbXB1dGF0aW9uXG4gICAgICAgIHRoaXMuc3RhdGUucG9zaXRpb24gPSB0aGlzLl9nZXRQb3NpdGlvbih0aGlzLl9wb3BwZXIsIHRoaXMuX3JlZmVyZW5jZSk7XG4gICAgICAgIHNldFN0eWxlKHRoaXMuX3BvcHBlciwgeyBwb3NpdGlvbjogdGhpcy5zdGF0ZS5wb3NpdGlvbiwgdG9wOiAwIH0pO1xuXG4gICAgICAgIC8vIGZpcmUgdGhlIGZpcnN0IHVwZGF0ZSB0byBwb3NpdGlvbiB0aGUgcG9wcGVyIGluIHRoZSByaWdodCBwbGFjZVxuICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgICAgIC8vIHNldHVwIGV2ZW50IGxpc3RlbmVycywgdGhleSB3aWxsIHRha2UgY2FyZSBvZiB1cGRhdGUgdGhlIHBvc2l0aW9uIGluIHNwZWNpZmljIHNpdHVhdGlvbnNcbiAgICAgICAgdGhpcy5fc2V0dXBFdmVudExpc3RlbmVycygpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIE1ldGhvZHNcbiAgICAvL1xuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgdGhlIHBvcHBlclxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG4gICAgUG9wcGVyLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9wb3BwZXIucmVtb3ZlQXR0cmlidXRlKCd4LXBsYWNlbWVudCcpO1xuICAgICAgICB0aGlzLl9wb3BwZXIuc3R5bGUubGVmdCA9ICcnO1xuICAgICAgICB0aGlzLl9wb3BwZXIuc3R5bGUucG9zaXRpb24gPSAnJztcbiAgICAgICAgdGhpcy5fcG9wcGVyLnN0eWxlLnRvcCA9ICcnO1xuICAgICAgICB0aGlzLl9wb3BwZXIuc3R5bGVbZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKV0gPSAnJztcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAgICAgICAvLyByZW1vdmUgdGhlIHBvcHBlciBpZiB1c2VyIGV4cGxpY2l0eSBhc2tlZCBmb3IgdGhlIGRlbGV0aW9uIG9uIGRlc3Ryb3lcbiAgICAgICAgaWYgKHRoaXMuX29wdGlvbnMucmVtb3ZlT25EZXN0cm95KSB7XG4gICAgICAgICAgICB0aGlzLl9wb3BwZXIucmVtb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIsIGNvbXB1dGluZyB0aGUgbmV3IG9mZnNldHMgYW5kIGFwcGx5aW5nIHRoZSBuZXcgc3R5bGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuICAgIFBvcHBlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9IHsgaW5zdGFuY2U6IHRoaXMsIHN0eWxlczoge30gfTtcblxuICAgICAgICAvLyBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCwgbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAgICAgICAvLyBhbmQgcmVmZXIgdG8gX29yaWdpbmFsUGxhY2VtZW50IHRvIGtub3cgdGhlIG9yaWdpbmFsIHZhbHVlXG4gICAgICAgIGRhdGEucGxhY2VtZW50ID0gdGhpcy5fb3B0aW9ucy5wbGFjZW1lbnQ7XG4gICAgICAgIGRhdGEuX29yaWdpbmFsUGxhY2VtZW50ID0gdGhpcy5fb3B0aW9ucy5wbGFjZW1lbnQ7XG5cbiAgICAgICAgLy8gY29tcHV0ZSB0aGUgcG9wcGVyIGFuZCByZWZlcmVuY2Ugb2Zmc2V0cyBhbmQgcHV0IHRoZW0gaW5zaWRlIGRhdGEub2Zmc2V0c1xuICAgICAgICBkYXRhLm9mZnNldHMgPSB0aGlzLl9nZXRPZmZzZXRzKHRoaXMuX3BvcHBlciwgdGhpcy5fcmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCk7XG5cbiAgICAgICAgLy8gZ2V0IGJvdW5kYXJpZXNcbiAgICAgICAgZGF0YS5ib3VuZGFyaWVzID0gdGhpcy5fZ2V0Qm91bmRhcmllcyhkYXRhLCB0aGlzLl9vcHRpb25zLmJvdW5kYXJpZXNQYWRkaW5nLCB0aGlzLl9vcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50KTtcblxuICAgICAgICBkYXRhID0gdGhpcy5ydW5Nb2RpZmllcnMoZGF0YSwgdGhpcy5fb3B0aW9ucy5tb2RpZmllcnMpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zdGF0ZS51cGRhdGVDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGVDYWxsYmFjayhkYXRhKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBJZiBhIGZ1bmN0aW9uIGlzIHBhc3NlZCwgaXQgd2lsbCBiZSBleGVjdXRlZCBhZnRlciB0aGUgaW5pdGlhbGl6YXRpb24gb2YgcG9wcGVyIHdpdGggYXMgZmlyc3QgYXJndW1lbnQgdGhlIFBvcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG4gICAgUG9wcGVyLnByb3RvdHlwZS5vbkNyZWF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAvLyB0aGUgY3JlYXRlQ2FsbGJhY2tzIHJldHVybiBhcyBmaXJzdCBhcmd1bWVudCB0aGUgcG9wcGVyIGluc3RhbmNlXG4gICAgICAgIGNhbGxiYWNrKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSWYgYSBmdW5jdGlvbiBpcyBwYXNzZWQsIGl0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgZWFjaCB1cGRhdGUgb2YgcG9wcGVyIHdpdGggYXMgZmlyc3QgYXJndW1lbnQgdGhlIHNldCBvZiBjb29yZGluYXRlcyBhbmQgaW5mb3JtYXRpb25zXG4gICAgICogdXNlZCB0byBzdHlsZSBwb3BwZXIgYW5kIGl0cyBhcnJvdy5cbiAgICAgKiBOT1RFOiBpdCBkb2Vzbid0IGdldCBmaXJlZCBvbiB0aGUgZmlyc3QgY2FsbCBvZiB0aGUgYFBvcHBlci51cGRhdGUoKWAgbWV0aG9kIGluc2lkZSB0aGUgYFBvcHBlcmAgY29uc3RydWN0b3IhXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuICAgIFBvcHBlci5wcm90b3R5cGUub25VcGRhdGUgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5zdGF0ZS51cGRhdGVDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogSGVscGVyIHVzZWQgdG8gZ2VuZXJhdGUgcG9wcGVycyBmcm9tIGEgY29uZmlndXJhdGlvbiBmaWxlXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKiBAcGFyYW0gY29uZmlnIHtPYmplY3R9IGNvbmZpZ3VyYXRpb25cbiAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHBvcHBlclxuICAgICAqL1xuICAgIFBvcHBlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgIHZhciBkZWZhdWx0Q29uZmlnID0ge1xuICAgICAgICAgICAgdGFnTmFtZTogJ2RpdicsXG4gICAgICAgICAgICBjbGFzc05hbWVzOiBbJ3BvcHBlciddLFxuICAgICAgICAgICAgYXR0cmlidXRlczogW10sXG4gICAgICAgICAgICBwYXJlbnQ6IHJvb3QuZG9jdW1lbnQuYm9keSxcbiAgICAgICAgICAgIGNvbnRlbnQ6ICcnLFxuICAgICAgICAgICAgY29udGVudFR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgIGFycm93VGFnTmFtZTogJ2RpdicsXG4gICAgICAgICAgICBhcnJvd0NsYXNzTmFtZXM6IFsncG9wcGVyX19hcnJvdyddLFxuICAgICAgICAgICAgYXJyb3dBdHRyaWJ1dGVzOiBbJ3gtYXJyb3cnXVxuICAgICAgICB9O1xuICAgICAgICBjb25maWcgPSBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0Q29uZmlnLCBjb25maWcpO1xuXG4gICAgICAgIHZhciBkID0gcm9vdC5kb2N1bWVudDtcblxuICAgICAgICB2YXIgcG9wcGVyID0gZC5jcmVhdGVFbGVtZW50KGNvbmZpZy50YWdOYW1lKTtcbiAgICAgICAgYWRkQ2xhc3NOYW1lcyhwb3BwZXIsIGNvbmZpZy5jbGFzc05hbWVzKTtcbiAgICAgICAgYWRkQXR0cmlidXRlcyhwb3BwZXIsIGNvbmZpZy5hdHRyaWJ1dGVzKTtcbiAgICAgICAgaWYgKGNvbmZpZy5jb250ZW50VHlwZSA9PT0gJ25vZGUnKSB7XG4gICAgICAgICAgICBwb3BwZXIuYXBwZW5kQ2hpbGQoY29uZmlnLmNvbnRlbnQuanF1ZXJ5ID8gY29uZmlnLmNvbnRlbnRbMF0gOiBjb25maWcuY29udGVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLmNvbnRlbnRUeXBlID09PSAnaHRtbCcpIHtcbiAgICAgICAgICAgIHBvcHBlci5pbm5lckhUTUwgPSBjb25maWcuY29udGVudDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBvcHBlci50ZXh0Q29udGVudCA9IGNvbmZpZy5jb250ZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbmZpZy5hcnJvd1RhZ05hbWUpIHtcbiAgICAgICAgICAgIHZhciBhcnJvdyA9IGQuY3JlYXRlRWxlbWVudChjb25maWcuYXJyb3dUYWdOYW1lKTtcbiAgICAgICAgICAgIGFkZENsYXNzTmFtZXMoYXJyb3csIGNvbmZpZy5hcnJvd0NsYXNzTmFtZXMpO1xuICAgICAgICAgICAgYWRkQXR0cmlidXRlcyhhcnJvdywgY29uZmlnLmFycm93QXR0cmlidXRlcyk7XG4gICAgICAgICAgICBwb3BwZXIuYXBwZW5kQ2hpbGQoYXJyb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBhcmVudCA9IGNvbmZpZy5wYXJlbnQuanF1ZXJ5ID8gY29uZmlnLnBhcmVudFswXSA6IGNvbmZpZy5wYXJlbnQ7XG5cbiAgICAgICAgLy8gaWYgdGhlIGdpdmVuIHBhcmVudCBpcyBhIHN0cmluZywgdXNlIGl0IHRvIG1hdGNoIGFuIGVsZW1lbnRcbiAgICAgICAgLy8gaWYgbW9yZSB0aGFuIG9uZSBlbGVtZW50IGlzIG1hdGNoZWQsIHRoZSBmaXJzdCBvbmUgd2lsbCBiZSB1c2VkIGFzIHBhcmVudFxuICAgICAgICAvLyBpZiBubyBlbGVtZW50cyBhcmUgbWF0Y2hlZCwgdGhlIHNjcmlwdCB3aWxsIHRocm93IGFuIGVycm9yXG4gICAgICAgIGlmICh0eXBlb2YgcGFyZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcGFyZW50ID0gZC5xdWVyeVNlbGVjdG9yQWxsKGNvbmZpZy5wYXJlbnQpO1xuICAgICAgICAgICAgaWYgKHBhcmVudC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiB0aGUgZ2l2ZW4gYHBhcmVudGAgcXVlcnkoJyArIGNvbmZpZy5wYXJlbnQgKyAnKSBtYXRjaGVkIG1vcmUgdGhhbiBvbmUgZWxlbWVudCwgdGhlIGZpcnN0IG9uZSB3aWxsIGJlIHVzZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJlbnQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0VSUk9SOiB0aGUgZ2l2ZW4gYHBhcmVudGAgZG9lc25cXCd0IGV4aXN0cyEnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50WzBdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBnaXZlbiBwYXJlbnQgaXMgYSBET00gbm9kZXMgbGlzdCBvciBhbiBhcnJheSBvZiBub2RlcyB3aXRoIG1vcmUgdGhhbiBvbmUgZWxlbWVudCxcbiAgICAgICAgLy8gdGhlIGZpcnN0IG9uZSB3aWxsIGJlIHVzZWQgYXMgcGFyZW50XG4gICAgICAgIGlmIChwYXJlbnQubGVuZ3RoID4gMSAmJiBwYXJlbnQgaW5zdGFuY2VvZiBFbGVtZW50ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiB5b3UgaGF2ZSBwYXNzZWQgYXMgcGFyZW50IGEgbGlzdCBvZiBlbGVtZW50cywgdGhlIGZpcnN0IG9uZSB3aWxsIGJlIHVzZWQnKTtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFwcGVuZCB0aGUgZ2VuZXJhdGVkIHBvcHBlciB0byBpdHMgcGFyZW50XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChwb3BwZXIpO1xuXG4gICAgICAgIHJldHVybiBwb3BwZXI7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgY2xhc3MgbmFtZXMgdG8gdGhlIGdpdmVuIGVsZW1lbnRcbiAgICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgICAqIEBpZ25vcmVcbiAgICAgICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdGFyZ2V0XG4gICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGNsYXNzZXNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGFkZENsYXNzTmFtZXMoZWxlbWVudCwgY2xhc3NOYW1lcykge1xuICAgICAgICAgICAgY2xhc3NOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZHMgYXR0cmlidXRlcyB0byB0aGUgZ2l2ZW4gZWxlbWVudFxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQGlnbm9yZVxuICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXRcbiAgICAgICAgICogQHBhcmFtIHtBcnJheX0gYXR0cmlidXRlc1xuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBhZGRBdHRyaWJ1dGVzKGVsZW1lbnQsIFsgJ2RhdGEtaW5mbzpmb29iYXInIF0pO1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gYWRkQXR0cmlidXRlcyhlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICBhdHRyaWJ1dGVzLmZvckVhY2goZnVuY3Rpb24gKGF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZS5zcGxpdCgnOicpWzBdLCBhdHRyaWJ1dGUuc3BsaXQoJzonKVsxXSB8fCAnJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgdXNlZCB0byBnZXQgdGhlIHBvc2l0aW9uIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKiBAcGFyYW0gY29uZmlnIHtIVE1MRWxlbWVudH0gcG9wcGVyIGVsZW1lbnRcbiAgICAgKiBAcGFyYW0gcmVmZXJlbmNlIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlIGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBwb3NpdGlvblxuICAgICAqL1xuICAgIFBvcHBlci5wcm90b3R5cGUuX2dldFBvc2l0aW9uID0gZnVuY3Rpb24gKHBvcHBlciwgcmVmZXJlbmNlKSB7XG4gICAgICAgIHZhciBjb250YWluZXIgPSBnZXRPZmZzZXRQYXJlbnQocmVmZXJlbmNlKTtcblxuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5mb3JjZUFic29sdXRlKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2Fic29sdXRlJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlY2lkZSBpZiB0aGUgcG9wcGVyIHdpbGwgYmUgZml4ZWRcbiAgICAgICAgLy8gSWYgdGhlIHJlZmVyZW5jZSBlbGVtZW50IGlzIGluc2lkZSBhIGZpeGVkIGNvbnRleHQsIHRoZSBwb3BwZXIgd2lsbCBiZSBmaXhlZCBhcyB3ZWxsIHRvIGFsbG93IHRoZW0gdG8gc2Nyb2xsIHRvZ2V0aGVyXG4gICAgICAgIHZhciBpc1BhcmVudEZpeGVkID0gaXNGaXhlZChyZWZlcmVuY2UsIGNvbnRhaW5lcik7XG4gICAgICAgIHJldHVybiBpc1BhcmVudEZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZSc7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldCBvZmZzZXRzIHRvIHRoZSBwb3BwZXJcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gcG9wcGVyIC0gdGhlIHBvcHBlciBlbGVtZW50XG4gICAgICogQHBhcmFtIHtFbGVtZW50fSByZWZlcmVuY2UgLSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gICAgICovXG4gICAgUG9wcGVyLnByb3RvdHlwZS5fZ2V0T2Zmc2V0cyA9IGZ1bmN0aW9uIChwb3BwZXIsIHJlZmVyZW5jZSwgcGxhY2VtZW50KSB7XG4gICAgICAgIHBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgICAgICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHt9O1xuXG4gICAgICAgIHBvcHBlck9mZnNldHMucG9zaXRpb24gPSB0aGlzLnN0YXRlLnBvc2l0aW9uO1xuICAgICAgICB2YXIgaXNQYXJlbnRGaXhlZCA9IHBvcHBlck9mZnNldHMucG9zaXRpb24gPT09ICdmaXhlZCc7XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2V0IHJlZmVyZW5jZSBlbGVtZW50IHBvc2l0aW9uXG4gICAgICAgIC8vXG4gICAgICAgIHZhciByZWZlcmVuY2VPZmZzZXRzID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9DdXN0b21QYXJlbnQocmVmZXJlbmNlLCBnZXRPZmZzZXRQYXJlbnQocG9wcGVyKSwgaXNQYXJlbnRGaXhlZCk7XG5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gR2V0IHBvcHBlciBzaXplc1xuICAgICAgICAvL1xuICAgICAgICB2YXIgcG9wcGVyUmVjdCA9IGdldE91dGVyU2l6ZXMocG9wcGVyKTtcblxuICAgICAgICAvL1xuICAgICAgICAvLyBDb21wdXRlIG9mZnNldHMgb2YgcG9wcGVyXG4gICAgICAgIC8vXG5cbiAgICAgICAgLy8gZGVwZW5kaW5nIGJ5IHRoZSBwb3BwZXIgcGxhY2VtZW50IHdlIGhhdmUgdG8gY29tcHV0ZSBpdHMgb2Zmc2V0cyBzbGlnaHRseSBkaWZmZXJlbnRseVxuICAgICAgICBpZiAoWydyaWdodCcsICdsZWZ0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMSkge1xuICAgICAgICAgICAgcG9wcGVyT2Zmc2V0cy50b3AgPSByZWZlcmVuY2VPZmZzZXRzLnRvcCArIHJlZmVyZW5jZU9mZnNldHMuaGVpZ2h0IC8gMiAtIHBvcHBlclJlY3QuaGVpZ2h0IC8gMjtcbiAgICAgICAgICAgIGlmIChwbGFjZW1lbnQgPT09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgIHBvcHBlck9mZnNldHMubGVmdCA9IHJlZmVyZW5jZU9mZnNldHMubGVmdCAtIHBvcHBlclJlY3Qud2lkdGg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvcHBlck9mZnNldHMubGVmdCA9IHJlZmVyZW5jZU9mZnNldHMucmlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3BwZXJPZmZzZXRzLmxlZnQgPSByZWZlcmVuY2VPZmZzZXRzLmxlZnQgKyByZWZlcmVuY2VPZmZzZXRzLndpZHRoIC8gMiAtIHBvcHBlclJlY3Qud2lkdGggLyAyO1xuICAgICAgICAgICAgaWYgKHBsYWNlbWVudCA9PT0gJ3RvcCcpIHtcbiAgICAgICAgICAgICAgICBwb3BwZXJPZmZzZXRzLnRvcCA9IHJlZmVyZW5jZU9mZnNldHMudG9wIC0gcG9wcGVyUmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBvcHBlck9mZnNldHMudG9wID0gcmVmZXJlbmNlT2Zmc2V0cy5ib3R0b207XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGQgd2lkdGggYW5kIGhlaWdodCB0byBvdXIgb2Zmc2V0cyBvYmplY3RcbiAgICAgICAgcG9wcGVyT2Zmc2V0cy53aWR0aCA9IHBvcHBlclJlY3Qud2lkdGg7XG4gICAgICAgIHBvcHBlck9mZnNldHMuaGVpZ2h0ID0gcG9wcGVyUmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBvcHBlcjogcG9wcGVyT2Zmc2V0cyxcbiAgICAgICAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlT2Zmc2V0c1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBTZXR1cCBuZWVkZWQgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIFBvcHBlci5wcm90b3R5cGUuX3NldHVwRXZlbnRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gICAgICAgIHRoaXMuc3RhdGUudXBkYXRlQm91bmQgPSB0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpO1xuICAgICAgICByb290LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuc3RhdGUudXBkYXRlQm91bmQpO1xuICAgICAgICAvLyBpZiB0aGUgYm91bmRhcmllc0VsZW1lbnQgaXMgd2luZG93IHdlIGRvbid0IG5lZWQgdG8gbGlzdGVuIGZvciB0aGUgc2Nyb2xsIGV2ZW50XG4gICAgICAgIGlmICh0aGlzLl9vcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50ICE9PSAnd2luZG93Jykge1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IGdldFNjcm9sbFBhcmVudCh0aGlzLl9yZWZlcmVuY2UpO1xuICAgICAgICAgICAgLy8gaGVyZSBpdCBjb3VsZCBiZSBib3RoIGBib2R5YCBvciBgZG9jdW1lbnRFbGVtZW50YCB0aGFua3MgdG8gRmlyZWZveCwgd2UgdGhlbiBjaGVjayBib3RoXG4gICAgICAgICAgICBpZiAodGFyZ2V0ID09PSByb290LmRvY3VtZW50LmJvZHkgfHwgdGFyZ2V0ID09PSByb290LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHJvb3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5zdGF0ZS51cGRhdGVCb3VuZCk7XG4gICAgICAgICAgICB0aGlzLnN0YXRlLnNjcm9sbFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqIEBhY2Nlc3MgcHJpdmF0ZVxuICAgICAqL1xuICAgIFBvcHBlci5wcm90b3R5cGUuX3JlbW92ZUV2ZW50TGlzdGVuZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICAgICAgICByb290LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuc3RhdGUudXBkYXRlQm91bmQpO1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5ib3VuZGFyaWVzRWxlbWVudCAhPT0gJ3dpbmRvdycgJiYgdGhpcy5zdGF0ZS5zY3JvbGxUYXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUuc2Nyb2xsVGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuc3RhdGUudXBkYXRlQm91bmQpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zY3JvbGxUYXJnZXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUudXBkYXRlQm91bmQgPSBudWxsO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlZCB0aGUgYm91bmRhcmllcyBsaW1pdHMgYW5kIHJldHVybiB0aGVtXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKiBAYWNjZXNzIHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtIE9iamVjdCBjb250YWluaW5nIHRoZSBwcm9wZXJ0eSBcIm9mZnNldHNcIiBnZW5lcmF0ZWQgYnkgYF9nZXRPZmZzZXRzYFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBwYWRkaW5nIC0gQm91bmRhcmllcyBwYWRkaW5nXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudCAtIEVsZW1lbnQgdXNlZCB0byBkZWZpbmUgdGhlIGJvdW5kYXJpZXNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBDb29yZGluYXRlcyBvZiB0aGUgYm91bmRhcmllc1xuICAgICAqL1xuICAgIFBvcHBlci5wcm90b3R5cGUuX2dldEJvdW5kYXJpZXMgPSBmdW5jdGlvbiAoZGF0YSwgcGFkZGluZywgYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgICAgICAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgICAgICAgdmFyIGJvdW5kYXJpZXMgPSB7fTtcbiAgICAgICAgdmFyIHdpZHRoLCBoZWlnaHQ7XG4gICAgICAgIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgICAgICAgIHZhciBib2R5ID0gcm9vdC5kb2N1bWVudC5ib2R5LFxuICAgICAgICAgICAgICAgIGh0bWwgPSByb290LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5tYXgoYm9keS5zY3JvbGxIZWlnaHQsIGJvZHkub2Zmc2V0SGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwub2Zmc2V0SGVpZ2h0KTtcbiAgICAgICAgICAgIHdpZHRoID0gTWF0aC5tYXgoYm9keS5zY3JvbGxXaWR0aCwgYm9keS5vZmZzZXRXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5vZmZzZXRXaWR0aCk7XG5cbiAgICAgICAgICAgIGJvdW5kYXJpZXMgPSB7XG4gICAgICAgICAgICAgICAgdG9wOiAwLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiB3aWR0aCxcbiAgICAgICAgICAgICAgICBib3R0b206IGhlaWdodCxcbiAgICAgICAgICAgICAgICBsZWZ0OiAwXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAndmlld3BvcnQnKSB7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KHRoaXMuX3BvcHBlcik7XG4gICAgICAgICAgICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KHRoaXMuX3BvcHBlcik7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0UGFyZW50UmVjdCA9IGdldE9mZnNldFJlY3Qob2Zmc2V0UGFyZW50KTtcblxuICAgICAgICAgICAgLy8gVGhhbmtzIHRoZSBmdWNraW5nIG5hdGl2ZSBBUEksIGBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcGAgJiBgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcGBcbiAgICAgICAgICAgIHZhciBnZXRTY3JvbGxUb3BWYWx1ZSA9IGZ1bmN0aW9uIGdldFNjcm9sbFRvcFZhbHVlKGVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudCA9PSBkb2N1bWVudC5ib2R5ID8gTWF0aC5tYXgoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCwgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3ApIDogZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIGdldFNjcm9sbExlZnRWYWx1ZSA9IGZ1bmN0aW9uIGdldFNjcm9sbExlZnRWYWx1ZShlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQgPT0gZG9jdW1lbnQuYm9keSA/IE1hdGgubWF4KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LCBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQpIDogZWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gaWYgdGhlIHBvcHBlciBpcyBmaXhlZCB3ZSBkb24ndCBoYXZlIHRvIHN1YnN0cmFjdCBzY3JvbGxpbmcgZnJvbSB0aGUgYm91bmRhcmllc1xuICAgICAgICAgICAgdmFyIHNjcm9sbFRvcCA9IGRhdGEub2Zmc2V0cy5wb3BwZXIucG9zaXRpb24gPT09ICdmaXhlZCcgPyAwIDogZ2V0U2Nyb2xsVG9wVmFsdWUoc2Nyb2xsUGFyZW50KTtcbiAgICAgICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZGF0YS5vZmZzZXRzLnBvcHBlci5wb3NpdGlvbiA9PT0gJ2ZpeGVkJyA/IDAgOiBnZXRTY3JvbGxMZWZ0VmFsdWUoc2Nyb2xsUGFyZW50KTtcblxuICAgICAgICAgICAgYm91bmRhcmllcyA9IHtcbiAgICAgICAgICAgICAgICB0b3A6IDAgLSAob2Zmc2V0UGFyZW50UmVjdC50b3AgLSBzY3JvbGxUb3ApLFxuICAgICAgICAgICAgICAgIHJpZ2h0OiByb290LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCAtIChvZmZzZXRQYXJlbnRSZWN0LmxlZnQgLSBzY3JvbGxMZWZ0KSxcbiAgICAgICAgICAgICAgICBib3R0b206IHJvb3QuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCAtIChvZmZzZXRQYXJlbnRSZWN0LnRvcCAtIHNjcm9sbFRvcCksXG4gICAgICAgICAgICAgICAgbGVmdDogMCAtIChvZmZzZXRQYXJlbnRSZWN0LmxlZnQgLSBzY3JvbGxMZWZ0KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChnZXRPZmZzZXRQYXJlbnQodGhpcy5fcG9wcGVyKSA9PT0gYm91bmRhcmllc0VsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBib3VuZGFyaWVzID0ge1xuICAgICAgICAgICAgICAgICAgICB0b3A6IDAsXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiBib3VuZGFyaWVzRWxlbWVudC5jbGllbnRXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiBib3VuZGFyaWVzRWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBib3VuZGFyaWVzID0gZ2V0T2Zmc2V0UmVjdChib3VuZGFyaWVzRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYm91bmRhcmllcy5sZWZ0ICs9IHBhZGRpbmc7XG4gICAgICAgIGJvdW5kYXJpZXMucmlnaHQgLT0gcGFkZGluZztcbiAgICAgICAgYm91bmRhcmllcy50b3AgPSBib3VuZGFyaWVzLnRvcCArIHBhZGRpbmc7XG4gICAgICAgIGJvdW5kYXJpZXMuYm90dG9tID0gYm91bmRhcmllcy5ib3R0b20gLSBwYWRkaW5nO1xuICAgICAgICByZXR1cm4gYm91bmRhcmllcztcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTG9vcCB0cm91Z2ggdGhlIGxpc3Qgb2YgbW9kaWZpZXJzIGFuZCBydW4gdGhlbSBpbiBvcmRlciwgZWFjaCBvZiB0aGVtIHdpbGwgdGhlbiBlZGl0IHRoZSBkYXRhIG9iamVjdFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICogQGFjY2VzcyBwdWJsaWNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IG1vZGlmaWVyc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVuZHNcbiAgICAgKi9cbiAgICBQb3BwZXIucHJvdG90eXBlLnJ1bk1vZGlmaWVycyA9IGZ1bmN0aW9uIChkYXRhLCBtb2RpZmllcnMsIGVuZHMpIHtcbiAgICAgICAgdmFyIG1vZGlmaWVyc1RvUnVuID0gbW9kaWZpZXJzLnNsaWNlKCk7XG4gICAgICAgIGlmIChlbmRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG1vZGlmaWVyc1RvUnVuID0gdGhpcy5fb3B0aW9ucy5tb2RpZmllcnMuc2xpY2UoMCwgZ2V0QXJyYXlLZXlJbmRleCh0aGlzLl9vcHRpb25zLm1vZGlmaWVycywgZW5kcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9kaWZpZXJzVG9SdW4uZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKG1vZGlmaWVyKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBtb2RpZmllci5jYWxsKHRoaXMsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBkZXBlbmRzIGZyb20gYW5vdGhlciBvbmUuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBQb3BwZXJcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGluZyAtIG5hbWUgb2YgcmVxdWVzdGluZyBtb2RpZmllclxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0ZWQgLSBuYW1lIG9mIHJlcXVlc3RlZCBtb2RpZmllclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIFBvcHBlci5wcm90b3R5cGUuaXNNb2RpZmllclJlcXVpcmVkID0gZnVuY3Rpb24gKHJlcXVlc3RpbmcsIHJlcXVlc3RlZCkge1xuICAgICAgICB2YXIgaW5kZXggPSBnZXRBcnJheUtleUluZGV4KHRoaXMuX29wdGlvbnMubW9kaWZpZXJzLCByZXF1ZXN0aW5nKTtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5fb3B0aW9ucy5tb2RpZmllcnMuc2xpY2UoMCwgaW5kZXgpLmZpbHRlcihmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBtb2RpZmllciA9PT0gcmVxdWVzdGVkO1xuICAgICAgICB9KS5sZW5ndGg7XG4gICAgfTtcblxuICAgIC8vXG4gICAgLy8gTW9kaWZpZXJzXG4gICAgLy9cblxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVycyBsaXN0XG4gICAgICogQG5hbWVzcGFjZSBQb3BwZXIubW9kaWZpZXJzXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICovXG4gICAgUG9wcGVyLnByb3RvdHlwZS5tb2RpZmllcnMgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEFwcGx5IHRoZSBjb21wdXRlZCBzdHlsZXMgdG8gdGhlIHBvcHBlciBlbGVtZW50XG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBQb3BwZXIubW9kaWZpZXJzXG4gICAgICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzYW1lIGRhdGEgb2JqZWN0XG4gICAgICovXG4gICAgUG9wcGVyLnByb3RvdHlwZS5tb2RpZmllcnMuYXBwbHlTdHlsZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIC8vIGFwcGx5IHRoZSBmaW5hbCBvZmZzZXRzIHRvIHRoZSBwb3BwZXJcbiAgICAgICAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgICAgICAgdmFyIHN0eWxlcyA9IHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBkYXRhLm9mZnNldHMucG9wcGVyLnBvc2l0aW9uXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gcm91bmQgdG9wIGFuZCBsZWZ0IHRvIGF2b2lkIGJsdXJyeSB0ZXh0XG4gICAgICAgIHZhciBsZWZ0ID0gTWF0aC5yb3VuZChkYXRhLm9mZnNldHMucG9wcGVyLmxlZnQpO1xuICAgICAgICB2YXIgdG9wID0gTWF0aC5yb3VuZChkYXRhLm9mZnNldHMucG9wcGVyLnRvcCk7XG5cbiAgICAgICAgLy8gaWYgZ3B1QWNjZWxlcmF0aW9uIGlzIHNldCB0byB0cnVlIGFuZCB0cmFuc2Zvcm0gaXMgc3VwcG9ydGVkLCB3ZSB1c2UgYHRyYW5zbGF0ZTNkYCB0byBhcHBseSB0aGUgcG9zaXRpb24gdG8gdGhlIHBvcHBlclxuICAgICAgICAvLyB3ZSBhdXRvbWF0aWNhbGx5IHVzZSB0aGUgc3VwcG9ydGVkIHByZWZpeGVkIHZlcnNpb24gaWYgbmVlZGVkXG4gICAgICAgIHZhciBwcmVmaXhlZFByb3BlcnR5O1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5ncHVBY2NlbGVyYXRpb24gJiYgKHByZWZpeGVkUHJvcGVydHkgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpKSkge1xuICAgICAgICAgICAgc3R5bGVzW3ByZWZpeGVkUHJvcGVydHldID0gJ3RyYW5zbGF0ZTNkKCcgKyBsZWZ0ICsgJ3B4LCAnICsgdG9wICsgJ3B4LCAwKSc7XG4gICAgICAgICAgICBzdHlsZXMudG9wID0gMDtcbiAgICAgICAgICAgIHN0eWxlcy5sZWZ0ID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBvdGh3ZXJpc2UsIHdlIHVzZSB0aGUgc3RhbmRhcmQgYGxlZnRgIGFuZCBgdG9wYCBwcm9wZXJ0aWVzXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0eWxlcy5sZWZ0ID0gbGVmdDtcbiAgICAgICAgICAgICAgICBzdHlsZXMudG9wID0gdG9wO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIC8vIGFueSBwcm9wZXJ0eSBwcmVzZW50IGluIGBkYXRhLnN0eWxlc2Agd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsXG4gICAgICAgIC8vIGluIHRoaXMgd2F5IHdlIGNhbiBtYWtlIHRoZSAzcmQgcGFydHkgbW9kaWZpZXJzIGFkZCBjdXN0b20gc3R5bGVzIHRvIGl0XG4gICAgICAgIC8vIEJlIGF3YXJlLCBtb2RpZmllcnMgY291bGQgb3ZlcnJpZGUgdGhlIHByb3BlcnRpZXMgZGVmaW5lZCBpbiB0aGUgcHJldmlvdXNcbiAgICAgICAgLy8gbGluZXMgb2YgdGhpcyBtb2RpZmllciFcbiAgICAgICAgT2JqZWN0LmFzc2lnbihzdHlsZXMsIGRhdGEuc3R5bGVzKTtcblxuICAgICAgICBzZXRTdHlsZSh0aGlzLl9wb3BwZXIsIHN0eWxlcyk7XG5cbiAgICAgICAgLy8gc2V0IGFuIGF0dHJpYnV0ZSB3aGljaCB3aWxsIGJlIHVzZWZ1bCB0byBzdHlsZSB0aGUgdG9vbHRpcCAodXNlIGl0IHRvIHByb3Blcmx5IHBvc2l0aW9uIGl0cyBhcnJvdylcbiAgICAgICAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgICAgICAgdGhpcy5fcG9wcGVyLnNldEF0dHJpYnV0ZSgneC1wbGFjZW1lbnQnLCBkYXRhLnBsYWNlbWVudCk7XG5cbiAgICAgICAgLy8gaWYgdGhlIGFycm93IG1vZGlmaWVyIGlzIHJlcXVpcmVkIGFuZCB0aGUgYXJyb3cgc3R5bGUgaGFzIGJlZW4gY29tcHV0ZWQsIGFwcGx5IHRoZSBhcnJvdyBzdHlsZVxuICAgICAgICBpZiAodGhpcy5pc01vZGlmaWVyUmVxdWlyZWQodGhpcy5tb2RpZmllcnMuYXBwbHlTdHlsZSwgdGhpcy5tb2RpZmllcnMuYXJyb3cpICYmIGRhdGEub2Zmc2V0cy5hcnJvdykge1xuICAgICAgICAgICAgc2V0U3R5bGUoZGF0YS5hcnJvd0VsZW1lbnQsIGRhdGEub2Zmc2V0cy5hcnJvdyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW9kaWZpZXIgdXNlZCB0byBzaGlmdCB0aGUgcG9wcGVyIG9uIHRoZSBzdGFydCBvciBlbmQgb2YgaXRzIHJlZmVyZW5jZSBlbGVtZW50IHNpZGVcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIFBvcHBlci5tb2RpZmllcnNcbiAgICAgKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICAgICAqL1xuICAgIFBvcHBlci5wcm90b3R5cGUubW9kaWZpZXJzLnNoaWZ0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICAgICAgICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgICAgICB2YXIgc2hpZnRWYXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICAgICAgICAvLyBpZiBzaGlmdCBzaGlmdFZhcmlhdGlvbiBpcyBzcGVjaWZpZWQsIHJ1biB0aGUgbW9kaWZpZXJcbiAgICAgICAgaWYgKHNoaWZ0VmFyaWF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgcmVmZXJlbmNlID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcbiAgICAgICAgICAgIHZhciBwb3BwZXIgPSBnZXRQb3BwZXJDbGllbnRSZWN0KGRhdGEub2Zmc2V0cy5wb3BwZXIpO1xuXG4gICAgICAgICAgICB2YXIgc2hpZnRPZmZzZXRzID0ge1xuICAgICAgICAgICAgICAgIHk6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHsgdG9wOiByZWZlcmVuY2UudG9wIH0sXG4gICAgICAgICAgICAgICAgICAgIGVuZDogeyB0b3A6IHJlZmVyZW5jZS50b3AgKyByZWZlcmVuY2UuaGVpZ2h0IC0gcG9wcGVyLmhlaWdodCB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB4OiB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7IGxlZnQ6IHJlZmVyZW5jZS5sZWZ0IH0sXG4gICAgICAgICAgICAgICAgICAgIGVuZDogeyBsZWZ0OiByZWZlcmVuY2UubGVmdCArIHJlZmVyZW5jZS53aWR0aCAtIHBvcHBlci53aWR0aCB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIGF4aXMgPSBbJ2JvdHRvbScsICd0b3AnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMSA/ICd4JyA6ICd5JztcblxuICAgICAgICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24ocG9wcGVyLCBzaGlmdE9mZnNldHNbYXhpc11bc2hpZnRWYXJpYXRpb25dKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2Ugc3VyZSB0aGUgcG9wcGVyIGRvZXMgbm90IG92ZXJmbG93cyBmcm9tIGl0J3MgYm91bmRhcmllc1xuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyLm1vZGlmaWVyc1xuICAgICAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gICAgICovXG4gICAgUG9wcGVyLnByb3RvdHlwZS5tb2RpZmllcnMucHJldmVudE92ZXJmbG93ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIG9yZGVyID0gdGhpcy5fb3B0aW9ucy5wcmV2ZW50T3ZlcmZsb3dPcmRlcjtcbiAgICAgICAgdmFyIHBvcHBlciA9IGdldFBvcHBlckNsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG5cbiAgICAgICAgdmFyIGNoZWNrID0ge1xuICAgICAgICAgICAgbGVmdDogZnVuY3Rpb24gbGVmdCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdCA9IHBvcHBlci5sZWZ0O1xuICAgICAgICAgICAgICAgIGlmIChwb3BwZXIubGVmdCA8IGRhdGEuYm91bmRhcmllcy5sZWZ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPSBNYXRoLm1heChwb3BwZXIubGVmdCwgZGF0YS5ib3VuZGFyaWVzLmxlZnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4geyBsZWZ0OiBsZWZ0IH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmlnaHQ6IGZ1bmN0aW9uIHJpZ2h0KCkge1xuICAgICAgICAgICAgICAgIHZhciBsZWZ0ID0gcG9wcGVyLmxlZnQ7XG4gICAgICAgICAgICAgICAgaWYgKHBvcHBlci5yaWdodCA+IGRhdGEuYm91bmRhcmllcy5yaWdodCkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ID0gTWF0aC5taW4ocG9wcGVyLmxlZnQsIGRhdGEuYm91bmRhcmllcy5yaWdodCAtIHBvcHBlci53aWR0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGxlZnQ6IGxlZnQgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0b3A6IGZ1bmN0aW9uIHRvcCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9wID0gcG9wcGVyLnRvcDtcbiAgICAgICAgICAgICAgICBpZiAocG9wcGVyLnRvcCA8IGRhdGEuYm91bmRhcmllcy50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgdG9wID0gTWF0aC5tYXgocG9wcGVyLnRvcCwgZGF0YS5ib3VuZGFyaWVzLnRvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHRvcDogdG9wIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm90dG9tOiBmdW5jdGlvbiBib3R0b20oKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRvcCA9IHBvcHBlci50b3A7XG4gICAgICAgICAgICAgICAgaWYgKHBvcHBlci5ib3R0b20gPiBkYXRhLmJvdW5kYXJpZXMuYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcCA9IE1hdGgubWluKHBvcHBlci50b3AsIGRhdGEuYm91bmRhcmllcy5ib3R0b20gLSBwb3BwZXIuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdG9wOiB0b3AgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBvcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHBvcHBlciwgY2hlY2tbZGlyZWN0aW9uXSgpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVyIHVzZWQgdG8gbWFrZSBzdXJlIHRoZSBwb3BwZXIgaXMgYWx3YXlzIG5lYXIgaXRzIHJlZmVyZW5jZVxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyLm1vZGlmaWVyc1xuICAgICAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBfdXBkYXRlIG1ldGhvZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAgICAgKi9cbiAgICBQb3BwZXIucHJvdG90eXBlLm1vZGlmaWVycy5rZWVwVG9nZXRoZXIgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgcG9wcGVyID0gZ2V0UG9wcGVyQ2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcbiAgICAgICAgdmFyIHJlZmVyZW5jZSA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG4gICAgICAgIHZhciBmID0gTWF0aC5mbG9vcjtcblxuICAgICAgICBpZiAocG9wcGVyLnJpZ2h0IDwgZihyZWZlcmVuY2UubGVmdCkpIHtcbiAgICAgICAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIubGVmdCA9IGYocmVmZXJlbmNlLmxlZnQpIC0gcG9wcGVyLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3BwZXIubGVmdCA+IGYocmVmZXJlbmNlLnJpZ2h0KSkge1xuICAgICAgICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlci5sZWZ0ID0gZihyZWZlcmVuY2UucmlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3BwZXIuYm90dG9tIDwgZihyZWZlcmVuY2UudG9wKSkge1xuICAgICAgICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlci50b3AgPSBmKHJlZmVyZW5jZS50b3ApIC0gcG9wcGVyLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9wcGVyLnRvcCA+IGYocmVmZXJlbmNlLmJvdHRvbSkpIHtcbiAgICAgICAgICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIudG9wID0gZihyZWZlcmVuY2UuYm90dG9tKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBNb2RpZmllciB1c2VkIHRvIGZsaXAgdGhlIHBsYWNlbWVudCBvZiB0aGUgcG9wcGVyIHdoZW4gdGhlIGxhdHRlciBpcyBzdGFydGluZyBvdmVybGFwcGluZyBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgICAqICoqTk9URToqKiBUaGlzIG1vZGlmaWVyIHdpbGwgcnVuIGFsbCBpdHMgcHJldmlvdXMgbW9kaWZpZXJzIGV2ZXJ5dGltZSBpdCB0cmllcyB0byBmbGlwIHRoZSBwb3BwZXIhXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBtZW1iZXJvZiBQb3BwZXIubW9kaWZpZXJzXG4gICAgICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IF91cGRhdGUgbWV0aG9kXG4gICAgICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICAgICAqL1xuICAgIFBvcHBlci5wcm90b3R5cGUubW9kaWZpZXJzLmZsaXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAvLyBjaGVjayBpZiBwcmV2ZW50T3ZlcmZsb3cgaXMgaW4gdGhlIGxpc3Qgb2YgbW9kaWZpZXJzIGJlZm9yZSB0aGUgZmxpcCBtb2RpZmllci5cbiAgICAgICAgLy8gb3RoZXJ3aXNlIGZsaXAgd291bGQgbm90IHdvcmsgYXMgZXhwZWN0ZWQuXG4gICAgICAgIGlmICghdGhpcy5pc01vZGlmaWVyUmVxdWlyZWQodGhpcy5tb2RpZmllcnMuZmxpcCwgdGhpcy5tb2RpZmllcnMucHJldmVudE92ZXJmbG93KSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBwcmV2ZW50T3ZlcmZsb3cgbW9kaWZpZXIgaXMgcmVxdWlyZWQgYnkgZmxpcCBtb2RpZmllciBpbiBvcmRlciB0byB3b3JrLCBiZSBzdXJlIHRvIGluY2x1ZGUgaXQgYmVmb3JlIGZsaXAhJyk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkYXRhLmZsaXBwZWQgJiYgZGF0YS5wbGFjZW1lbnQgPT09IGRhdGEuX29yaWdpbmFsUGxhY2VtZW50KSB7XG4gICAgICAgICAgICAvLyBzZWVtcyBsaWtlIGZsaXAgaXMgdHJ5aW5nIHRvIGxvb3AsIHByb2JhYmx5IHRoZXJlJ3Mgbm90IGVub3VnaCBzcGFjZSBvbiBhbnkgb2YgdGhlIGZsaXBwYWJsZSBzaWRlc1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgICAgICAgdmFyIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgICAgICAgdmFyIHZhcmlhdGlvbiA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMV0gfHwgJyc7XG5cbiAgICAgICAgdmFyIGZsaXBPcmRlciA9IFtdO1xuICAgICAgICBpZiAodGhpcy5fb3B0aW9ucy5mbGlwQmVoYXZpb3IgPT09ICdmbGlwJykge1xuICAgICAgICAgICAgZmxpcE9yZGVyID0gW3BsYWNlbWVudCwgcGxhY2VtZW50T3Bwb3NpdGVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxpcE9yZGVyID0gdGhpcy5fb3B0aW9ucy5mbGlwQmVoYXZpb3I7XG4gICAgICAgIH1cblxuICAgICAgICBmbGlwT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAoc3RlcCwgaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChwbGFjZW1lbnQgIT09IHN0ZXAgfHwgZmxpcE9yZGVyLmxlbmd0aCA9PT0gaW5kZXggKyAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgICAgICAgICAgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgICAgICAgICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGdldFBvcHBlckNsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG5cbiAgICAgICAgICAgIC8vIHRoaXMgYm9vbGVhbiBpcyB1c2VkIHRvIGRpc3Rpbmd1aXNoIHJpZ2h0IGFuZCBib3R0b20gZnJvbSB0b3AgYW5kIGxlZnRcbiAgICAgICAgICAgIC8vIHRoZXkgbmVlZCBkaWZmZXJlbnQgY29tcHV0YXRpb25zIHRvIGdldCBmbGlwcGVkXG4gICAgICAgICAgICB2YXIgYSA9IFsncmlnaHQnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICAgICAgICAgICAgLy8gdXNpbmcgTWF0aC5mbG9vciBiZWNhdXNlIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyBtYXkgY29udGFpbiBkZWNpbWFscyB3ZSBhcmUgbm90IGdvaW5nIHRvIGNvbnNpZGVyIGhlcmVcbiAgICAgICAgICAgIGlmIChhICYmIE1hdGguZmxvb3IoZGF0YS5vZmZzZXRzLnJlZmVyZW5jZVtwbGFjZW1lbnRdKSA+IE1hdGguZmxvb3IocG9wcGVyT2Zmc2V0c1twbGFjZW1lbnRPcHBvc2l0ZV0pIHx8ICFhICYmIE1hdGguZmxvb3IoZGF0YS5vZmZzZXRzLnJlZmVyZW5jZVtwbGFjZW1lbnRdKSA8IE1hdGguZmxvb3IocG9wcGVyT2Zmc2V0c1twbGFjZW1lbnRPcHBvc2l0ZV0pKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UnbGwgdXNlIHRoaXMgYm9vbGVhbiB0byBkZXRlY3QgYW55IGZsaXAgbG9vcFxuICAgICAgICAgICAgICAgIGRhdGEuZmxpcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgZGF0YS5wbGFjZW1lbnQgPSBmbGlwT3JkZXJbaW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICBpZiAodmFyaWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucGxhY2VtZW50ICs9ICctJyArIHZhcmlhdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IHRoaXMuX2dldE9mZnNldHModGhpcy5fcG9wcGVyLCB0aGlzLl9yZWZlcmVuY2UsIGRhdGEucGxhY2VtZW50KS5wb3BwZXI7XG5cbiAgICAgICAgICAgICAgICBkYXRhID0gdGhpcy5ydW5Nb2RpZmllcnMoZGF0YSwgdGhpcy5fb3B0aW9ucy5tb2RpZmllcnMsIHRoaXMuX2ZsaXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTW9kaWZpZXIgdXNlZCB0byBhZGQgYW4gb2Zmc2V0IHRvIHRoZSBwb3BwZXIsIHVzZWZ1bCBpZiB5b3UgbW9yZSBncmFudWxhcml0eSBwb3NpdGlvbmluZyB5b3VyIHBvcHBlci5cbiAgICAgKiBUaGUgb2Zmc2V0cyB3aWxsIHNoaWZ0IHRoZSBwb3BwZXIgb24gdGhlIHNpZGUgb2YgaXRzIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyLm1vZGlmaWVyc1xuICAgICAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBfdXBkYXRlIG1ldGhvZFxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAgICAgKi9cbiAgICBQb3BwZXIucHJvdG90eXBlLm1vZGlmaWVycy5vZmZzZXQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gdGhpcy5fb3B0aW9ucy5vZmZzZXQ7XG4gICAgICAgIHZhciBwb3BwZXIgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuXG4gICAgICAgIGlmIChkYXRhLnBsYWNlbWVudC5pbmRleE9mKCdsZWZ0JykgIT09IC0xKSB7XG4gICAgICAgICAgICBwb3BwZXIudG9wIC09IG9mZnNldDtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLnBsYWNlbWVudC5pbmRleE9mKCdyaWdodCcpICE9PSAtMSkge1xuICAgICAgICAgICAgcG9wcGVyLnRvcCArPSBvZmZzZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5wbGFjZW1lbnQuaW5kZXhPZigndG9wJykgIT09IC0xKSB7XG4gICAgICAgICAgICBwb3BwZXIubGVmdCAtPSBvZmZzZXQ7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF0YS5wbGFjZW1lbnQuaW5kZXhPZignYm90dG9tJykgIT09IC0xKSB7XG4gICAgICAgICAgICBwb3BwZXIubGVmdCArPSBvZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIE1vZGlmaWVyIHVzZWQgdG8gbW92ZSB0aGUgYXJyb3dzIG9uIHRoZSBlZGdlIG9mIHRoZSBwb3BwZXIgdG8gbWFrZSBzdXJlIHRoZW0gYXJlIGFsd2F5cyBiZXR3ZWVuIHRoZSBwb3BwZXIgYW5kIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICAgICAqIEl0IHdpbGwgdXNlIHRoZSBDU1Mgb3V0ZXIgc2l6ZSBvZiB0aGUgYXJyb3cgZWxlbWVudCB0byBrbm93IGhvdyBtYW55IHBpeGVscyBvZiBjb25qdWN0aW9uIGFyZSBuZWVkZWRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQG1lbWJlcm9mIFBvcHBlci5tb2RpZmllcnNcbiAgICAgKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgX3VwZGF0ZSBtZXRob2RcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gICAgICovXG4gICAgUG9wcGVyLnByb3RvdHlwZS5tb2RpZmllcnMuYXJyb3cgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgYXJyb3cgPSB0aGlzLl9vcHRpb25zLmFycm93RWxlbWVudDtcbiAgICAgICAgdmFyIGFycm93T2Zmc2V0ID0gdGhpcy5fb3B0aW9ucy5hcnJvd09mZnNldDtcblxuICAgICAgICAvLyBpZiB0aGUgYXJyb3dFbGVtZW50IGlzIGEgc3RyaW5nLCBzdXBwb3NlIGl0J3MgYSBDU1Mgc2VsZWN0b3JcbiAgICAgICAgaWYgKHR5cGVvZiBhcnJvdyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGFycm93ID0gdGhpcy5fcG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3cpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgYXJyb3cgZWxlbWVudCBpcyBub3QgZm91bmQsIGRvbid0IHJ1biB0aGUgbW9kaWZpZXJcbiAgICAgICAgaWYgKCFhcnJvdykge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgYXJyb3cgZWxlbWVudCBtdXN0IGJlIGNoaWxkIG9mIGl0cyBwb3BwZXJcbiAgICAgICAgaWYgKCF0aGlzLl9wb3BwZXIuY29udGFpbnMoYXJyb3cpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBhcnJvd0VsZW1lbnRgIG11c3QgYmUgY2hpbGQgb2YgaXRzIHBvcHBlciBlbGVtZW50IScpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcnJvdyBkZXBlbmRzIG9uIGtlZXBUb2dldGhlciBpbiBvcmRlciB0byB3b3JrXG4gICAgICAgIGlmICghdGhpcy5pc01vZGlmaWVyUmVxdWlyZWQodGhpcy5tb2RpZmllcnMuYXJyb3csIHRoaXMubW9kaWZpZXJzLmtlZXBUb2dldGhlcikpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignV0FSTklORzoga2VlcFRvZ2V0aGVyIG1vZGlmaWVyIGlzIHJlcXVpcmVkIGJ5IGFycm93IG1vZGlmaWVyIGluIG9yZGVyIHRvIHdvcmssIGJlIHN1cmUgdG8gaW5jbHVkZSBpdCBiZWZvcmUgYXJyb3chJyk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhcnJvd1N0eWxlID0ge307XG4gICAgICAgIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgICAgICB2YXIgcG9wcGVyID0gZ2V0UG9wcGVyQ2xpZW50UmVjdChkYXRhLm9mZnNldHMucG9wcGVyKTtcbiAgICAgICAgdmFyIHJlZmVyZW5jZSA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG4gICAgICAgIHZhciBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICAgICAgICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgICAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ3RvcCcgOiAnbGVmdCc7XG4gICAgICAgIHZhciB0cmFuc2xhdGUgPSBpc1ZlcnRpY2FsID8gJ3RyYW5zbGF0ZVknIDogJ3RyYW5zbGF0ZVgnO1xuICAgICAgICB2YXIgYWx0U2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgICAgdmFyIG9wU2lkZSA9IGlzVmVydGljYWwgPyAnYm90dG9tJyA6ICdyaWdodCc7XG4gICAgICAgIHZhciBhcnJvd1NpemUgPSBnZXRPdXRlclNpemVzKGFycm93KVtsZW5dO1xuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGV4dGVuZHMga2VlcFRvZ2V0aGVyIGJlaGF2aW9yIG1ha2luZyBzdXJlIHRoZSBwb3BwZXIgYW5kIGl0cyByZWZlcmVuY2UgaGF2ZSBlbm91Z2ggcGl4ZWxzIGluIGNvbmp1Y3Rpb25cbiAgICAgICAgLy9cblxuICAgICAgICAvLyB0b3AvbGVmdCBzaWRlXG4gICAgICAgIGlmIChyZWZlcmVuY2Vbb3BTaWRlXSAtIGFycm93U2l6ZSA8IHBvcHBlcltzaWRlXSkge1xuICAgICAgICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtPSBwb3BwZXJbc2lkZV0gLSAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd1NpemUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGJvdHRvbS9yaWdodCBzaWRlXG4gICAgICAgIGlmIChyZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd1NpemUgPiBwb3BwZXJbb3BTaWRlXSkge1xuICAgICAgICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSArPSByZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd1NpemUgLSBwb3BwZXJbb3BTaWRlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNvbXB1dGUgY2VudGVyIG9mIHRoZSBwb3BwZXJcbiAgICAgICAgdmFyIGNlbnRlciA9IHJlZmVyZW5jZVtzaWRlXSArIChhcnJvd09mZnNldCB8fCByZWZlcmVuY2VbbGVuXSAvIDIgLSBhcnJvd1NpemUgLyAyKTtcblxuICAgICAgICB2YXIgc2lkZVZhbHVlID0gY2VudGVyIC0gcG9wcGVyW3NpZGVdO1xuXG4gICAgICAgIC8vIHByZXZlbnQgYXJyb3cgZnJvbSBiZWluZyBwbGFjZWQgbm90IGNvbnRpZ3VvdXNseSB0byBpdHMgcG9wcGVyXG4gICAgICAgIHNpZGVWYWx1ZSA9IE1hdGgubWF4KE1hdGgubWluKHBvcHBlcltsZW5dIC0gYXJyb3dTaXplIC0gOCwgc2lkZVZhbHVlKSwgOCk7XG4gICAgICAgIGFycm93U3R5bGVbc2lkZV0gPSBzaWRlVmFsdWU7XG4gICAgICAgIGFycm93U3R5bGVbYWx0U2lkZV0gPSAnJzsgLy8gbWFrZSBzdXJlIHRvIHJlbW92ZSBhbnkgb2xkIHN0eWxlIGZyb20gdGhlIGFycm93XG5cbiAgICAgICAgZGF0YS5vZmZzZXRzLmFycm93ID0gYXJyb3dTdHlsZTtcbiAgICAgICAgZGF0YS5hcnJvd0VsZW1lbnQgPSBhcnJvdztcblxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuXG4gICAgLy9cbiAgICAvLyBIZWxwZXJzXG4gICAgLy9cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgb3V0ZXIgc2l6ZXMgb2YgdGhlIGdpdmVuIGVsZW1lbnQgKG9mZnNldCBzaXplICsgbWFyZ2lucylcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaWdub3JlXG4gICAgICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgd2lkdGggYW5kIGhlaWdodCBwcm9wZXJ0aWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0T3V0ZXJTaXplcyhlbGVtZW50KSB7XG4gICAgICAgIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gICAgICAgIHZhciBfZGlzcGxheSA9IGVsZW1lbnQuc3R5bGUuZGlzcGxheSxcbiAgICAgICAgICAgIF92aXNpYmlsaXR5ID0gZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5O1xuICAgICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO2VsZW1lbnQuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICB2YXIgY2FsY1dpZHRoVG9Gb3JjZVJlcGFpbnQgPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xuXG4gICAgICAgIC8vIG9yaWdpbmFsIG1ldGhvZFxuICAgICAgICB2YXIgc3R5bGVzID0gcm9vdC5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICAgICAgICB2YXIgeCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblRvcCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Cb3R0b20pO1xuICAgICAgICB2YXIgeSA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQpICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luUmlnaHQpO1xuICAgICAgICB2YXIgcmVzdWx0ID0geyB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCArIHksIGhlaWdodDogZWxlbWVudC5vZmZzZXRIZWlnaHQgKyB4IH07XG5cbiAgICAgICAgLy8gcmVzZXQgZWxlbWVudCBzdHlsZXNcbiAgICAgICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gX2Rpc3BsYXk7ZWxlbWVudC5zdHlsZS52aXNpYmlsaXR5ID0gX3Zpc2liaWxpdHk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgb2YgdGhlIGdpdmVuIG9uZS9cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaWdub3JlXG4gICAgICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gICAgICAgIHZhciBoYXNoID0geyBsZWZ0OiAncmlnaHQnLCByaWdodDogJ2xlZnQnLCBib3R0b206ICd0b3AnLCB0b3A6ICdib3R0b20nIH07XG4gICAgICAgIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2l2ZW4gdGhlIHBvcHBlciBvZmZzZXRzLCBnZW5lcmF0ZSBhbiBvdXRwdXQgc2ltaWxhciB0byBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaWdub3JlXG4gICAgICogQGFyZ3VtZW50IHtPYmplY3R9IHBvcHBlck9mZnNldHNcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBDbGllbnRSZWN0IGxpa2Ugb3V0cHV0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0UG9wcGVyQ2xpZW50UmVjdChwb3BwZXJPZmZzZXRzKSB7XG4gICAgICAgIHZhciBvZmZzZXRzID0gT2JqZWN0LmFzc2lnbih7fSwgcG9wcGVyT2Zmc2V0cyk7XG4gICAgICAgIG9mZnNldHMucmlnaHQgPSBvZmZzZXRzLmxlZnQgKyBvZmZzZXRzLndpZHRoO1xuICAgICAgICBvZmZzZXRzLmJvdHRvbSA9IG9mZnNldHMudG9wICsgb2Zmc2V0cy5oZWlnaHQ7XG4gICAgICAgIHJldHVybiBvZmZzZXRzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGFuIGFycmF5IGFuZCB0aGUga2V5IHRvIGZpbmQsIHJldHVybnMgaXRzIGluZGV4XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGlnbm9yZVxuICAgICAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICAgICAqIEBhcmd1bWVudCBrZXlUb0ZpbmRcbiAgICAgKiBAcmV0dXJucyBpbmRleCBvciBudWxsXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QXJyYXlLZXlJbmRleChhcnIsIGtleVRvRmluZCkge1xuICAgICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgICBrZXk7XG4gICAgICAgIGZvciAoa2V5IGluIGFycikge1xuICAgICAgICAgICAgaWYgKGFycltrZXldID09PSBrZXlUb0ZpbmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXQgQ1NTIGNvbXB1dGVkIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGlnbm9yZVxuICAgICAqIEBhcmd1bWVudCB7RWVtZW50fSBlbGVtZW50XG4gICAgICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gICAgICAgIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gICAgICAgIHZhciBjc3MgPSByb290LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gICAgICAgIHJldHVybiBjc3NbcHJvcGVydHldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG9mZnNldCBwYXJlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaWdub3JlXG4gICAgICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHJldHVybnMge0VsZW1lbnR9IG9mZnNldCBwYXJlbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICAgICAgICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICAgICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG4gICAgICAgIHJldHVybiBvZmZzZXRQYXJlbnQgPT09IHJvb3QuZG9jdW1lbnQuYm9keSB8fCAhb2Zmc2V0UGFyZW50ID8gcm9vdC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBvZmZzZXRQYXJlbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc2Nyb2xsaW5nIHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJucyB7RWxlbWVudH0gb2Zmc2V0IHBhcmVudFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChlbGVtZW50KSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG5cbiAgICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmVudCA9PT0gcm9vdC5kb2N1bWVudCkge1xuICAgICAgICAgICAgLy8gRmlyZWZveCBwdXRzIHRoZSBzY3JvbGxUT3AgdmFsdWUgb24gYGRvY3VtZW50RWxlbWVudGAgaW5zdGVhZCBvZiBgYm9keWAsIHdlIHRoZW4gY2hlY2sgd2hpY2ggb2YgdGhlbSBpc1xuICAgICAgICAgICAgLy8gZ3JlYXRlciB0aGFuIDAgYW5kIHJldHVybiB0aGUgcHJvcGVyIGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChyb290LmRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIHx8IHJvb3QuZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3QuZG9jdW1lbnQuYm9keTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJvb3QuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyZWZveCB3YW50IHVzIHRvIGNoZWNrIGAteGAgYW5kIGAteWAgdmFyaWF0aW9ucyBhcyB3ZWxsXG4gICAgICAgIGlmIChbJ3Njcm9sbCcsICdhdXRvJ10uaW5kZXhPZihnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkocGFyZW50LCAnb3ZlcmZsb3cnKSkgIT09IC0xIHx8IFsnc2Nyb2xsJywgJ2F1dG8nXS5pbmRleE9mKGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQsICdvdmVyZmxvdy14JykpICE9PSAtMSB8fCBbJ3Njcm9sbCcsICdhdXRvJ10uaW5kZXhPZihnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkocGFyZW50LCAnb3ZlcmZsb3cteScpKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSBkZXRlY3RlZCBzY3JvbGxQYXJlbnQgaXMgYm9keSwgd2UgcGVyZm9ybSBhbiBhZGRpdGlvbmFsIGNoZWNrIG9uIGl0cyBwYXJlbnROb2RlXG4gICAgICAgICAgICAvLyBpbiB0aGlzIHdheSB3ZSdsbCBnZXQgYm9keSBpZiB0aGUgYnJvd3NlciBpcyBDaHJvbWUtaXNoLCBvciBkb2N1bWVudEVsZW1lbnQgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBmaXhlcyBpc3N1ZSAjNjVcbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChlbGVtZW50LnBhcmVudE5vZGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiBlbGVtZW50IGlzIGZpeGVkIG9yIGlzIGluc2lkZSBhIGZpeGVkIHBhcmVudFxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBpZ25vcmVcbiAgICAgKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAYXJndW1lbnQge0VsZW1lbnR9IGN1c3RvbUNvbnRhaW5lclxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBhbnN3ZXIgdG8gXCJpc0ZpeGVkP1wiXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGaXhlZChlbGVtZW50KSB7XG4gICAgICAgIGlmIChlbGVtZW50ID09PSByb290LmRvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsICdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudC5wYXJlbnROb2RlID8gaXNGaXhlZChlbGVtZW50LnBhcmVudE5vZGUpIDogZWxlbWVudDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHN0eWxlIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaWdub3JlXG4gICAgICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSB0aGUgc3R5bGUgdG9cbiAgICAgKiBAYXJndW1lbnQge09iamVjdH0gc3R5bGVzIC0gT2JqZWN0IHdpdGggYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRTdHlsZShlbGVtZW50LCBzdHlsZXMpIHtcbiAgICAgICAgZnVuY3Rpb24gaXNfbnVtZXJpYyhuKSB7XG4gICAgICAgICAgICByZXR1cm4gbiAhPT0gJycgJiYgIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKHN0eWxlcykuZm9yRWFjaChmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgdmFyIHVuaXQgPSAnJztcbiAgICAgICAgICAgIC8vIGFkZCB1bml0IGlmIHRoZSB2YWx1ZSBpcyBudW1lcmljIGFuZCBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZ1xuICAgICAgICAgICAgaWYgKFsnd2lkdGgnLCAnaGVpZ2h0JywgJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddLmluZGV4T2YocHJvcCkgIT09IC0xICYmIGlzX251bWVyaWMoc3R5bGVzW3Byb3BdKSkge1xuICAgICAgICAgICAgICAgIHVuaXQgPSAncHgnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxlbWVudC5zdHlsZVtwcm9wXSA9IHN0eWxlc1twcm9wXSArIHVuaXQ7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZSBnaXZlbiB2YXJpYWJsZSBpcyBhIGZ1bmN0aW9uXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGlnbm9yZVxuICAgICAqIEBhcmd1bWVudCB7Kn0gZnVuY3Rpb25Ub0NoZWNrIC0gdmFyaWFibGUgdG8gY2hlY2tcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvOiBpcyBhIGZ1bmN0aW9uP1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuY3Rpb25Ub0NoZWNrKSB7XG4gICAgICAgIHZhciBnZXRUeXBlID0ge307XG4gICAgICAgIHJldHVybiBmdW5jdGlvblRvQ2hlY2sgJiYgZ2V0VHlwZS50b1N0cmluZy5jYWxsKGZ1bmN0aW9uVG9DaGVjaykgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgZ2l2ZW4gZWxlbWVudCwgcmVsYXRpdmUgdG8gaXRzIG9mZnNldCBwYXJlbnRcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaWdub3JlXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAgICogQHJldHVybiB7T2JqZWN0fSBwb3NpdGlvbiAtIENvb3JkaW5hdGVzIG9mIHRoZSBlbGVtZW50IGFuZCBpdHMgYHNjcm9sbFRvcGBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRPZmZzZXRSZWN0KGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRSZWN0ID0ge1xuICAgICAgICAgICAgd2lkdGg6IGVsZW1lbnQub2Zmc2V0V2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgICAgbGVmdDogZWxlbWVudC5vZmZzZXRMZWZ0LFxuICAgICAgICAgICAgdG9wOiBlbGVtZW50Lm9mZnNldFRvcFxuICAgICAgICB9O1xuXG4gICAgICAgIGVsZW1lbnRSZWN0LnJpZ2h0ID0gZWxlbWVudFJlY3QubGVmdCArIGVsZW1lbnRSZWN0LndpZHRoO1xuICAgICAgICBlbGVtZW50UmVjdC5ib3R0b20gPSBlbGVtZW50UmVjdC50b3AgKyBlbGVtZW50UmVjdC5oZWlnaHQ7XG5cbiAgICAgICAgLy8gcG9zaXRpb25cbiAgICAgICAgcmV0dXJuIGVsZW1lbnRSZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBib3VuZGluZyBjbGllbnQgcmVjdCBvZiBnaXZlbiBlbGVtZW50XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGlnbm9yZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IGNsaWVudCByZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIC8vIHdoZXRoZXIgdGhlIElFIHZlcnNpb24gaXMgbG93ZXIgdGhhbiAxMVxuICAgICAgICB2YXIgaXNJRSA9IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihcIk1TSUVcIikgIT0gLTE7XG5cbiAgICAgICAgLy8gZml4IGllIGRvY3VtZW50IGJvdW5kaW5nIHRvcCBhbHdheXMgMCBidWdcbiAgICAgICAgdmFyIHJlY3RUb3AgPSBpc0lFICYmIGVsZW1lbnQudGFnTmFtZSA9PT0gJ0hUTUwnID8gLWVsZW1lbnQuc2Nyb2xsVG9wIDogcmVjdC50b3A7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICAgICAgICAgIHRvcDogcmVjdFRvcCxcbiAgICAgICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0LFxuICAgICAgICAgICAgYm90dG9tOiByZWN0LmJvdHRvbSxcbiAgICAgICAgICAgIHdpZHRoOiByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LFxuICAgICAgICAgICAgaGVpZ2h0OiByZWN0LmJvdHRvbSAtIHJlY3RUb3BcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHaXZlbiBhbiBlbGVtZW50IGFuZCBvbmUgb2YgaXRzIHBhcmVudHMsIHJldHVybiB0aGUgb2Zmc2V0XG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQGlnbm9yZVxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnRcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHJlY3RcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0N1c3RvbVBhcmVudChlbGVtZW50LCBwYXJlbnQsIGZpeGVkKSB7XG4gICAgICAgIHZhciBlbGVtZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTtcbiAgICAgICAgdmFyIHBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocGFyZW50KTtcblxuICAgICAgICBpZiAoZml4ZWQpIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxQYXJlbnQgPSBnZXRTY3JvbGxQYXJlbnQocGFyZW50KTtcbiAgICAgICAgICAgIHBhcmVudFJlY3QudG9wICs9IHNjcm9sbFBhcmVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgICBwYXJlbnRSZWN0LmJvdHRvbSArPSBzY3JvbGxQYXJlbnQuc2Nyb2xsVG9wO1xuICAgICAgICAgICAgcGFyZW50UmVjdC5sZWZ0ICs9IHNjcm9sbFBhcmVudC5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgcGFyZW50UmVjdC5yaWdodCArPSBzY3JvbGxQYXJlbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZWN0ID0ge1xuICAgICAgICAgICAgdG9wOiBlbGVtZW50UmVjdC50b3AgLSBwYXJlbnRSZWN0LnRvcCxcbiAgICAgICAgICAgIGxlZnQ6IGVsZW1lbnRSZWN0LmxlZnQgLSBwYXJlbnRSZWN0LmxlZnQsXG4gICAgICAgICAgICBib3R0b206IGVsZW1lbnRSZWN0LnRvcCAtIHBhcmVudFJlY3QudG9wICsgZWxlbWVudFJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgcmlnaHQ6IGVsZW1lbnRSZWN0LmxlZnQgLSBwYXJlbnRSZWN0LmxlZnQgKyBlbGVtZW50UmVjdC53aWR0aCxcbiAgICAgICAgICAgIHdpZHRoOiBlbGVtZW50UmVjdC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogZWxlbWVudFJlY3QuaGVpZ2h0XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcHJlZml4ZWQgc3VwcG9ydGVkIHByb3BlcnR5IG5hbWVcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaWdub3JlXG4gICAgICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5IChjYW1lbENhc2UpXG4gICAgICogQHJldHVybnMge1N0cmluZ30gcHJlZml4ZWQgcHJvcGVydHkgKGNhbWVsQ2FzZSlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUocHJvcGVydHkpIHtcbiAgICAgICAgdmFyIHByZWZpeGVzID0gWycnLCAnbXMnLCAnd2Via2l0JywgJ21veicsICdvJ107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRvQ2hlY2sgPSBwcmVmaXhlc1tpXSA/IHByZWZpeGVzW2ldICsgcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKSA6IHByb3BlcnR5O1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByb290LmRvY3VtZW50LmJvZHkuc3R5bGVbdG9DaGVja10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRvQ2hlY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIE9iamVjdC5hc3NpZ24oKSBtZXRob2QgaXMgdXNlZCB0byBjb3B5IHRoZSB2YWx1ZXMgb2YgYWxsIGVudW1lcmFibGUgb3duIHByb3BlcnRpZXMgZnJvbSBvbmUgb3IgbW9yZSBzb3VyY2VcbiAgICAgKiBvYmplY3RzIHRvIGEgdGFyZ2V0IG9iamVjdC4gSXQgd2lsbCByZXR1cm4gdGhlIHRhcmdldCBvYmplY3QuXG4gICAgICogVGhpcyBwb2x5ZmlsbCBkb2Vzbid0IHN1cHBvcnQgc3ltYm9sIHByb3BlcnRpZXMsIHNpbmNlIEVTNSBkb2Vzbid0IGhhdmUgc3ltYm9scyBhbnl3YXlcbiAgICAgKiBTb3VyY2U6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ25cbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgaWYgKCFPYmplY3QuYXNzaWduKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShPYmplY3QsICdhc3NpZ24nLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIGlmICh0YXJnZXQgPT09IHVuZGVmaW5lZCB8fCB0YXJnZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgZmlyc3QgYXJndW1lbnQgdG8gb2JqZWN0Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHRvID0gT2JqZWN0KHRhcmdldCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5leHRTb3VyY2UgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0U291cmNlID09PSB1bmRlZmluZWQgfHwgbmV4dFNvdXJjZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV4dFNvdXJjZSA9IE9iamVjdChuZXh0U291cmNlKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIga2V5c0FycmF5ID0gT2JqZWN0LmtleXMobmV4dFNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIG5leHRJbmRleCA9IDAsIGxlbiA9IGtleXNBcnJheS5sZW5ndGg7IG5leHRJbmRleCA8IGxlbjsgbmV4dEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0S2V5ID0ga2V5c0FycmF5W25leHRJbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobmV4dFNvdXJjZSwgbmV4dEtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVzYyAhPT0gdW5kZWZpbmVkICYmIGRlc2MuZW51bWVyYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvW25leHRLZXldID0gbmV4dFNvdXJjZVtuZXh0S2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBQb3BwZXI7XG59KTsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/element-ui/lib/utils/popper.js\n");

/***/ }),

/***/ "./node_modules/element-ui/lib/utils/popup/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/element-ui/lib/utils/popup/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.PopupManager = undefined;\n\nvar _vue = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm.js\");\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nvar _merge = __webpack_require__(/*! element-ui/lib/utils/merge */ \"./node_modules/element-ui/lib/utils/merge.js\");\n\nvar _merge2 = _interopRequireDefault(_merge);\n\nvar _popupManager = __webpack_require__(/*! element-ui/lib/utils/popup/popup-manager */ \"./node_modules/element-ui/lib/utils/popup/popup-manager.js\");\n\nvar _popupManager2 = _interopRequireDefault(_popupManager);\n\nvar _scrollbarWidth = __webpack_require__(/*! ../scrollbar-width */ \"./node_modules/element-ui/lib/utils/scrollbar-width.js\");\n\nvar _scrollbarWidth2 = _interopRequireDefault(_scrollbarWidth);\n\nvar _dom = __webpack_require__(/*! ../dom */ \"./node_modules/element-ui/lib/utils/dom.js\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar idSeed = 1;\nvar scrollBarWidth = void 0;\nexports.default = {\n  props: {\n    visible: {\n      type: Boolean,\n      default: false\n    },\n    openDelay: {},\n    closeDelay: {},\n    zIndex: {},\n    modal: {\n      type: Boolean,\n      default: false\n    },\n    modalFade: {\n      type: Boolean,\n      default: true\n    },\n    modalClass: {},\n    modalAppendToBody: {\n      type: Boolean,\n      default: false\n    },\n    lockScroll: {\n      type: Boolean,\n      default: true\n    },\n    closeOnPressEscape: {\n      type: Boolean,\n      default: false\n    },\n    closeOnClickModal: {\n      type: Boolean,\n      default: false\n    }\n  },\n  beforeMount: function beforeMount() {\n    this._popupId = 'popup-' + idSeed++;\n\n    _popupManager2.default.register(this._popupId, this);\n  },\n  beforeDestroy: function beforeDestroy() {\n    _popupManager2.default.deregister(this._popupId);\n\n    _popupManager2.default.closeModal(this._popupId);\n\n    this.restoreBodyStyle();\n  },\n  data: function data() {\n    return {\n      opened: false,\n      bodyPaddingRight: null,\n      computedBodyPaddingRight: 0,\n      withoutHiddenClass: true,\n      rendered: false\n    };\n  },\n  watch: {\n    visible: function visible(val) {\n      var _this = this;\n\n      if (val) {\n        if (this._opening) return;\n\n        if (!this.rendered) {\n          this.rendered = true;\n\n          _vue2.default.nextTick(function () {\n            _this.open();\n          });\n        } else {\n          this.open();\n        }\n      } else {\n        this.close();\n      }\n    }\n  },\n  methods: {\n    open: function open(options) {\n      var _this2 = this;\n\n      if (!this.rendered) {\n        this.rendered = true;\n      }\n\n      var props = (0, _merge2.default)({}, this.$props || this, options);\n\n      if (this._closeTimer) {\n        clearTimeout(this._closeTimer);\n        this._closeTimer = null;\n      }\n\n      clearTimeout(this._openTimer);\n      var openDelay = Number(props.openDelay);\n\n      if (openDelay > 0) {\n        this._openTimer = setTimeout(function () {\n          _this2._openTimer = null;\n\n          _this2.doOpen(props);\n        }, openDelay);\n      } else {\n        this.doOpen(props);\n      }\n    },\n    doOpen: function doOpen(props) {\n      if (this.$isServer) return;\n      if (this.willOpen && !this.willOpen()) return;\n      if (this.opened) return;\n      this._opening = true;\n      var dom = this.$el;\n      var modal = props.modal;\n      var zIndex = props.zIndex;\n\n      if (zIndex) {\n        _popupManager2.default.zIndex = zIndex;\n      }\n\n      if (modal) {\n        if (this._closing) {\n          _popupManager2.default.closeModal(this._popupId);\n\n          this._closing = false;\n        }\n\n        _popupManager2.default.openModal(this._popupId, _popupManager2.default.nextZIndex(), this.modalAppendToBody ? undefined : dom, props.modalClass, props.modalFade);\n\n        if (props.lockScroll) {\n          this.withoutHiddenClass = !(0, _dom.hasClass)(document.body, 'el-popup-parent--hidden');\n\n          if (this.withoutHiddenClass) {\n            this.bodyPaddingRight = document.body.style.paddingRight;\n            this.computedBodyPaddingRight = parseInt((0, _dom.getStyle)(document.body, 'paddingRight'), 10);\n          }\n\n          scrollBarWidth = (0, _scrollbarWidth2.default)();\n          var bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;\n          var bodyOverflowY = (0, _dom.getStyle)(document.body, 'overflowY');\n\n          if (scrollBarWidth > 0 && (bodyHasOverflow || bodyOverflowY === 'scroll') && this.withoutHiddenClass) {\n            document.body.style.paddingRight = this.computedBodyPaddingRight + scrollBarWidth + 'px';\n          }\n\n          (0, _dom.addClass)(document.body, 'el-popup-parent--hidden');\n        }\n      }\n\n      if (getComputedStyle(dom).position === 'static') {\n        dom.style.position = 'absolute';\n      }\n\n      dom.style.zIndex = _popupManager2.default.nextZIndex();\n      this.opened = true;\n      this.onOpen && this.onOpen();\n      this.doAfterOpen();\n    },\n    doAfterOpen: function doAfterOpen() {\n      this._opening = false;\n    },\n    close: function close() {\n      var _this3 = this;\n\n      if (this.willClose && !this.willClose()) return;\n\n      if (this._openTimer !== null) {\n        clearTimeout(this._openTimer);\n        this._openTimer = null;\n      }\n\n      clearTimeout(this._closeTimer);\n      var closeDelay = Number(this.closeDelay);\n\n      if (closeDelay > 0) {\n        this._closeTimer = setTimeout(function () {\n          _this3._closeTimer = null;\n\n          _this3.doClose();\n        }, closeDelay);\n      } else {\n        this.doClose();\n      }\n    },\n    doClose: function doClose() {\n      this._closing = true;\n      this.onClose && this.onClose();\n\n      if (this.lockScroll) {\n        setTimeout(this.restoreBodyStyle, 200);\n      }\n\n      this.opened = false;\n      this.doAfterClose();\n    },\n    doAfterClose: function doAfterClose() {\n      _popupManager2.default.closeModal(this._popupId);\n\n      this._closing = false;\n    },\n    restoreBodyStyle: function restoreBodyStyle() {\n      if (this.modal && this.withoutHiddenClass) {\n        document.body.style.paddingRight = this.bodyPaddingRight;\n        (0, _dom.removeClass)(document.body, 'el-popup-parent--hidden');\n      }\n\n      this.withoutHiddenClass = true;\n    }\n  }\n};\nexports.PopupManager = _popupManager2.default;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdXRpbHMvcG9wdXAvaW5kZXguanM/NTEyOCJdLCJuYW1lcyI6WyJleHBvcnRzIiwiX19lc01vZHVsZSIsIlBvcHVwTWFuYWdlciIsInVuZGVmaW5lZCIsIl92dWUiLCJyZXF1aXJlIiwiX3Z1ZTIiLCJfaW50ZXJvcFJlcXVpcmVEZWZhdWx0IiwiX21lcmdlIiwiX21lcmdlMiIsIl9wb3B1cE1hbmFnZXIiLCJfcG9wdXBNYW5hZ2VyMiIsIl9zY3JvbGxiYXJXaWR0aCIsIl9zY3JvbGxiYXJXaWR0aDIiLCJfZG9tIiwib2JqIiwiZGVmYXVsdCIsImlkU2VlZCIsInNjcm9sbEJhcldpZHRoIiwicHJvcHMiLCJ2aXNpYmxlIiwidHlwZSIsIkJvb2xlYW4iLCJvcGVuRGVsYXkiLCJjbG9zZURlbGF5IiwiekluZGV4IiwibW9kYWwiLCJtb2RhbEZhZGUiLCJtb2RhbENsYXNzIiwibW9kYWxBcHBlbmRUb0JvZHkiLCJsb2NrU2Nyb2xsIiwiY2xvc2VPblByZXNzRXNjYXBlIiwiY2xvc2VPbkNsaWNrTW9kYWwiLCJiZWZvcmVNb3VudCIsIl9wb3B1cElkIiwicmVnaXN0ZXIiLCJiZWZvcmVEZXN0cm95IiwiZGVyZWdpc3RlciIsImNsb3NlTW9kYWwiLCJyZXN0b3JlQm9keVN0eWxlIiwiZGF0YSIsIm9wZW5lZCIsImJvZHlQYWRkaW5nUmlnaHQiLCJjb21wdXRlZEJvZHlQYWRkaW5nUmlnaHQiLCJ3aXRob3V0SGlkZGVuQ2xhc3MiLCJyZW5kZXJlZCIsIndhdGNoIiwidmFsIiwiX3RoaXMiLCJfb3BlbmluZyIsIm5leHRUaWNrIiwib3BlbiIsImNsb3NlIiwibWV0aG9kcyIsIm9wdGlvbnMiLCJfdGhpczIiLCIkcHJvcHMiLCJfY2xvc2VUaW1lciIsImNsZWFyVGltZW91dCIsIl9vcGVuVGltZXIiLCJOdW1iZXIiLCJzZXRUaW1lb3V0IiwiZG9PcGVuIiwiJGlzU2VydmVyIiwid2lsbE9wZW4iLCJkb20iLCIkZWwiLCJfY2xvc2luZyIsIm9wZW5Nb2RhbCIsIm5leHRaSW5kZXgiLCJoYXNDbGFzcyIsImRvY3VtZW50IiwiYm9keSIsInN0eWxlIiwicGFkZGluZ1JpZ2h0IiwicGFyc2VJbnQiLCJnZXRTdHlsZSIsImJvZHlIYXNPdmVyZmxvdyIsImRvY3VtZW50RWxlbWVudCIsImNsaWVudEhlaWdodCIsInNjcm9sbEhlaWdodCIsImJvZHlPdmVyZmxvd1kiLCJhZGRDbGFzcyIsImdldENvbXB1dGVkU3R5bGUiLCJwb3NpdGlvbiIsIm9uT3BlbiIsImRvQWZ0ZXJPcGVuIiwiX3RoaXMzIiwid2lsbENsb3NlIiwiZG9DbG9zZSIsIm9uQ2xvc2UiLCJkb0FmdGVyQ2xvc2UiLCJyZW1vdmVDbGFzcyJdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWJBLE9BQU8sQ0FBQ0MsVUFBUixHQUFxQixJQUFyQjtBQUNBRCxPQUFPLENBQUNFLFlBQVIsR0FBdUJDLFNBQXZCOztBQUVBLElBQUlDLElBQUksR0FBR0MsbUJBQU8sQ0FBQyx1REFBRCxDQUFsQjs7QUFFQSxJQUFJQyxLQUFLLEdBQUdDLHNCQUFzQixDQUFDSCxJQUFELENBQWxDOztBQUVBLElBQUlJLE1BQU0sR0FBR0gsbUJBQU8sQ0FBQyxnRkFBRCxDQUFwQjs7QUFFQSxJQUFJSSxPQUFPLEdBQUdGLHNCQUFzQixDQUFDQyxNQUFELENBQXBDOztBQUVBLElBQUlFLGFBQWEsR0FBR0wsbUJBQU8sQ0FBQyw0R0FBRCxDQUEzQjs7QUFFQSxJQUFJTSxjQUFjLEdBQUdKLHNCQUFzQixDQUFDRyxhQUFELENBQTNDOztBQUVBLElBQUlFLGVBQWUsR0FBR1AsbUJBQU8sQ0FBQyxrRkFBRCxDQUE3Qjs7QUFFQSxJQUFJUSxnQkFBZ0IsR0FBR04sc0JBQXNCLENBQUNLLGVBQUQsQ0FBN0M7O0FBRUEsSUFBSUUsSUFBSSxHQUFHVCxtQkFBTyxDQUFDLDBEQUFELENBQWxCOztBQUVBLFNBQVNFLHNCQUFULENBQWdDUSxHQUFoQyxFQUFxQztBQUFFLFNBQU9BLEdBQUcs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OztBQUNELFdBQUs1QixrQkFBTCxHQUEwQixJQUExQjtBQUNEO0FBM0hNO0FBN0VPLENBQWxCO0FBMk1BNUMsT0FBTyxDQUFDRSxZQUFSLEdBQXVCUyxjQUFjLENBQUNLLE9BQXRDIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvbGliL3V0aWxzL3BvcHVwL2luZGV4LmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5Qb3B1cE1hbmFnZXIgPSB1bmRlZmluZWQ7XG5cbnZhciBfdnVlID0gcmVxdWlyZSgndnVlJyk7XG5cbnZhciBfdnVlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Z1ZSk7XG5cbnZhciBfbWVyZ2UgPSByZXF1aXJlKCdlbGVtZW50LXVpL2xpYi91dGlscy9tZXJnZScpO1xuXG52YXIgX21lcmdlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21lcmdlKTtcblxudmFyIF9wb3B1cE1hbmFnZXIgPSByZXF1aXJlKCdlbGVtZW50LXVpL2xpYi91dGlscy9wb3B1cC9wb3B1cC1tYW5hZ2VyJyk7XG5cbnZhciBfcG9wdXBNYW5hZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3BvcHVwTWFuYWdlcik7XG5cbnZhciBfc2Nyb2xsYmFyV2lkdGggPSByZXF1aXJlKCcuLi9zY3JvbGxiYXItd2lkdGgnKTtcblxudmFyIF9zY3JvbGxiYXJXaWR0aDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9zY3JvbGxiYXJXaWR0aCk7XG5cbnZhciBfZG9tID0gcmVxdWlyZSgnLi4vZG9tJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBpZFNlZWQgPSAxO1xuXG52YXIgc2Nyb2xsQmFyV2lkdGggPSB2b2lkIDA7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgcHJvcHM6IHtcbiAgICB2aXNpYmxlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIG9wZW5EZWxheToge30sXG4gICAgY2xvc2VEZWxheToge30sXG4gICAgekluZGV4OiB7fSxcbiAgICBtb2RhbDoge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBtb2RhbEZhZGU6IHtcbiAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfSxcbiAgICBtb2RhbENsYXNzOiB7fSxcbiAgICBtb2RhbEFwcGVuZFRvQm9keToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgfSxcbiAgICBsb2NrU2Nyb2xsOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH0sXG4gICAgY2xvc2VPblByZXNzRXNjYXBlOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9LFxuICAgIGNsb3NlT25DbGlja01vZGFsOiB7XG4gICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlTW91bnQ6IGZ1bmN0aW9uIGJlZm9yZU1vdW50KCkge1xuICAgIHRoaXMuX3BvcHVwSWQgPSAncG9wdXAtJyArIGlkU2VlZCsrO1xuICAgIF9wb3B1cE1hbmFnZXIyLmRlZmF1bHQucmVnaXN0ZXIodGhpcy5fcG9wdXBJZCwgdGhpcyk7XG4gIH0sXG4gIGJlZm9yZURlc3Ryb3k6IGZ1bmN0aW9uIGJlZm9yZURlc3Ryb3koKSB7XG4gICAgX3BvcHVwTWFuYWdlcjIuZGVmYXVsdC5kZXJlZ2lzdGVyKHRoaXMuX3BvcHVwSWQpO1xuICAgIF9wb3B1cE1hbmFnZXIyLmRlZmF1bHQuY2xvc2VNb2RhbCh0aGlzLl9wb3B1cElkKTtcblxuICAgIHRoaXMucmVzdG9yZUJvZHlTdHlsZSgpO1xuICB9LFxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBvcGVuZWQ6IGZhbHNlLFxuICAgICAgYm9keVBhZGRpbmdSaWdodDogbnVsbCxcbiAgICAgIGNvbXB1dGVkQm9keVBhZGRpbmdSaWdodDogMCxcbiAgICAgIHdpdGhvdXRIaWRkZW5DbGFzczogdHJ1ZSxcbiAgICAgIHJlbmRlcmVkOiBmYWxzZVxuICAgIH07XG4gIH0sXG5cblxuICB3YXRjaDoge1xuICAgIHZpc2libGU6IGZ1bmN0aW9uIHZpc2libGUodmFsKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodmFsKSB7XG4gICAgICAgIGlmICh0aGlzLl9vcGVuaW5nKSByZXR1cm47XG4gICAgICAgIGlmICghdGhpcy5yZW5kZXJlZCkge1xuICAgICAgICAgIHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICAgICAgICAgIF92dWUyLmRlZmF1bHQubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMub3BlbigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMub3BlbigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBvcGVuOiBmdW5jdGlvbiBvcGVuKG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICBpZiAoIXRoaXMucmVuZGVyZWQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcm9wcyA9ICgwLCBfbWVyZ2UyLmRlZmF1bHQpKHt9LCB0aGlzLiRwcm9wcyB8fCB0aGlzLCBvcHRpb25zKTtcblxuICAgICAgaWYgKHRoaXMuX2Nsb3NlVGltZXIpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2Nsb3NlVGltZXIpO1xuICAgICAgICB0aGlzLl9jbG9zZVRpbWVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9vcGVuVGltZXIpO1xuXG4gICAgICB2YXIgb3BlbkRlbGF5ID0gTnVtYmVyKHByb3BzLm9wZW5EZWxheSk7XG4gICAgICBpZiAob3BlbkRlbGF5ID4gMCkge1xuICAgICAgICB0aGlzLl9vcGVuVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczIuX29wZW5UaW1lciA9IG51bGw7XG4gICAgICAgICAgX3RoaXMyLmRvT3Blbihwcm9wcyk7XG4gICAgICAgIH0sIG9wZW5EZWxheSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRvT3Blbihwcm9wcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkb09wZW46IGZ1bmN0aW9uIGRvT3Blbihwcm9wcykge1xuICAgICAgaWYgKHRoaXMuJGlzU2VydmVyKSByZXR1cm47XG4gICAgICBpZiAodGhpcy53aWxsT3BlbiAmJiAhdGhpcy53aWxsT3BlbigpKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5vcGVuZWQpIHJldHVybjtcblxuICAgICAgdGhpcy5fb3BlbmluZyA9IHRydWU7XG5cbiAgICAgIHZhciBkb20gPSB0aGlzLiRlbDtcblxuICAgICAgdmFyIG1vZGFsID0gcHJvcHMubW9kYWw7XG5cbiAgICAgIHZhciB6SW5kZXggPSBwcm9wcy56SW5kZXg7XG4gICAgICBpZiAoekluZGV4KSB7XG4gICAgICAgIF9wb3B1cE1hbmFnZXIyLmRlZmF1bHQuekluZGV4ID0gekluZGV4O1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kYWwpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NpbmcpIHtcbiAgICAgICAgICBfcG9wdXBNYW5hZ2VyMi5kZWZhdWx0LmNsb3NlTW9kYWwodGhpcy5fcG9wdXBJZCk7XG4gICAgICAgICAgdGhpcy5fY2xvc2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIF9wb3B1cE1hbmFnZXIyLmRlZmF1bHQub3Blbk1vZGFsKHRoaXMuX3BvcHVwSWQsIF9wb3B1cE1hbmFnZXIyLmRlZmF1bHQubmV4dFpJbmRleCgpLCB0aGlzLm1vZGFsQXBwZW5kVG9Cb2R5ID8gdW5kZWZpbmVkIDogZG9tLCBwcm9wcy5tb2RhbENsYXNzLCBwcm9wcy5tb2RhbEZhZGUpO1xuICAgICAgICBpZiAocHJvcHMubG9ja1Njcm9sbCkge1xuICAgICAgICAgIHRoaXMud2l0aG91dEhpZGRlbkNsYXNzID0gISgwLCBfZG9tLmhhc0NsYXNzKShkb2N1bWVudC5ib2R5LCAnZWwtcG9wdXAtcGFyZW50LS1oaWRkZW4nKTtcbiAgICAgICAgICBpZiAodGhpcy53aXRob3V0SGlkZGVuQ2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMuYm9keVBhZGRpbmdSaWdodCA9IGRvY3VtZW50LmJvZHkuc3R5bGUucGFkZGluZ1JpZ2h0O1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlZEJvZHlQYWRkaW5nUmlnaHQgPSBwYXJzZUludCgoMCwgX2RvbS5nZXRTdHlsZSkoZG9jdW1lbnQuYm9keSwgJ3BhZGRpbmdSaWdodCcpLCAxMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNjcm9sbEJhcldpZHRoID0gKDAsIF9zY3JvbGxiYXJXaWR0aDIuZGVmYXVsdCkoKTtcbiAgICAgICAgICB2YXIgYm9keUhhc092ZXJmbG93ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodCA8IGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgIHZhciBib2R5T3ZlcmZsb3dZID0gKDAsIF9kb20uZ2V0U3R5bGUpKGRvY3VtZW50LmJvZHksICdvdmVyZmxvd1knKTtcbiAgICAgICAgICBpZiAoc2Nyb2xsQmFyV2lkdGggPiAwICYmIChib2R5SGFzT3ZlcmZsb3cgfHwgYm9keU92ZXJmbG93WSA9PT0gJ3Njcm9sbCcpICYmIHRoaXMud2l0aG91dEhpZGRlbkNsYXNzKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IHRoaXMuY29tcHV0ZWRCb2R5UGFkZGluZ1JpZ2h0ICsgc2Nyb2xsQmFyV2lkdGggKyAncHgnO1xuICAgICAgICAgIH1cbiAgICAgICAgICAoMCwgX2RvbS5hZGRDbGFzcykoZG9jdW1lbnQuYm9keSwgJ2VsLXBvcHVwLXBhcmVudC0taGlkZGVuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUoZG9tKS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcbiAgICAgICAgZG9tLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgIH1cblxuICAgICAgZG9tLnN0eWxlLnpJbmRleCA9IF9wb3B1cE1hbmFnZXIyLmRlZmF1bHQubmV4dFpJbmRleCgpO1xuICAgICAgdGhpcy5vcGVuZWQgPSB0cnVlO1xuXG4gICAgICB0aGlzLm9uT3BlbiAmJiB0aGlzLm9uT3BlbigpO1xuXG4gICAgICB0aGlzLmRvQWZ0ZXJPcGVuKCk7XG4gICAgfSxcbiAgICBkb0FmdGVyT3BlbjogZnVuY3Rpb24gZG9BZnRlck9wZW4oKSB7XG4gICAgICB0aGlzLl9vcGVuaW5nID0gZmFsc2U7XG4gICAgfSxcbiAgICBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMud2lsbENsb3NlICYmICF0aGlzLndpbGxDbG9zZSgpKSByZXR1cm47XG5cbiAgICAgIGlmICh0aGlzLl9vcGVuVGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX29wZW5UaW1lcik7XG4gICAgICAgIHRoaXMuX29wZW5UaW1lciA9IG51bGw7XG4gICAgICB9XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fY2xvc2VUaW1lcik7XG5cbiAgICAgIHZhciBjbG9zZURlbGF5ID0gTnVtYmVyKHRoaXMuY2xvc2VEZWxheSk7XG5cbiAgICAgIGlmIChjbG9zZURlbGF5ID4gMCkge1xuICAgICAgICB0aGlzLl9jbG9zZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgX3RoaXMzLl9jbG9zZVRpbWVyID0gbnVsbDtcbiAgICAgICAgICBfdGhpczMuZG9DbG9zZSgpO1xuICAgICAgICB9LCBjbG9zZURlbGF5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZG9DbG9zZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZG9DbG9zZTogZnVuY3Rpb24gZG9DbG9zZSgpIHtcbiAgICAgIHRoaXMuX2Nsb3NpbmcgPSB0cnVlO1xuXG4gICAgICB0aGlzLm9uQ2xvc2UgJiYgdGhpcy5vbkNsb3NlKCk7XG5cbiAgICAgIGlmICh0aGlzLmxvY2tTY3JvbGwpIHtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnJlc3RvcmVCb2R5U3R5bGUsIDIwMCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub3BlbmVkID0gZmFsc2U7XG5cbiAgICAgIHRoaXMuZG9BZnRlckNsb3NlKCk7XG4gICAgfSxcbiAgICBkb0FmdGVyQ2xvc2U6IGZ1bmN0aW9uIGRvQWZ0ZXJDbG9zZSgpIHtcbiAgICAgIF9wb3B1cE1hbmFnZXIyLmRlZmF1bHQuY2xvc2VNb2RhbCh0aGlzLl9wb3B1cElkKTtcbiAgICAgIHRoaXMuX2Nsb3NpbmcgPSBmYWxzZTtcbiAgICB9LFxuICAgIHJlc3RvcmVCb2R5U3R5bGU6IGZ1bmN0aW9uIHJlc3RvcmVCb2R5U3R5bGUoKSB7XG4gICAgICBpZiAodGhpcy5tb2RhbCAmJiB0aGlzLndpdGhvdXRIaWRkZW5DbGFzcykge1xuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLnBhZGRpbmdSaWdodCA9IHRoaXMuYm9keVBhZGRpbmdSaWdodDtcbiAgICAgICAgKDAsIF9kb20ucmVtb3ZlQ2xhc3MpKGRvY3VtZW50LmJvZHksICdlbC1wb3B1cC1wYXJlbnQtLWhpZGRlbicpO1xuICAgICAgfVxuICAgICAgdGhpcy53aXRob3V0SGlkZGVuQ2xhc3MgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcbmV4cG9ydHMuUG9wdXBNYW5hZ2VyID0gX3BvcHVwTWFuYWdlcjIuZGVmYXVsdDsiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/element-ui/lib/utils/popup/index.js\n");

/***/ }),

/***/ "./node_modules/element-ui/lib/utils/popup/popup-manager.js":
/*!******************************************************************!*\
  !*** ./node_modules/element-ui/lib/utils/popup/popup-manager.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _vue = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm.js\");\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nvar _dom = __webpack_require__(/*! element-ui/lib/utils/dom */ \"./node_modules/element-ui/lib/utils/dom.js\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar hasModal = false;\nvar hasInitZIndex = false;\nvar zIndex = void 0;\n\nvar getModal = function getModal() {\n  if (_vue2.default.prototype.$isServer) return;\n  var modalDom = PopupManager.modalDom;\n\n  if (modalDom) {\n    hasModal = true;\n  } else {\n    hasModal = false;\n    modalDom = document.createElement('div');\n    PopupManager.modalDom = modalDom;\n    modalDom.addEventListener('touchmove', function (event) {\n      event.preventDefault();\n      event.stopPropagation();\n    });\n    modalDom.addEventListener('click', function () {\n      PopupManager.doOnModalClick && PopupManager.doOnModalClick();\n    });\n  }\n\n  return modalDom;\n};\n\nvar instances = {};\nvar PopupManager = {\n  modalFade: true,\n  getInstance: function getInstance(id) {\n    return instances[id];\n  },\n  register: function register(id, instance) {\n    if (id && instance) {\n      instances[id] = instance;\n    }\n  },\n  deregister: function deregister(id) {\n    if (id) {\n      instances[id] = null;\n      delete instances[id];\n    }\n  },\n  nextZIndex: function nextZIndex() {\n    return PopupManager.zIndex++;\n  },\n  modalStack: [],\n  doOnModalClick: function doOnModalClick() {\n    var topItem = PopupManager.modalStack[PopupManager.modalStack.length - 1];\n    if (!topItem) return;\n    var instance = PopupManager.getInstance(topItem.id);\n\n    if (instance && instance.closeOnClickModal) {\n      instance.close();\n    }\n  },\n  openModal: function openModal(id, zIndex, dom, modalClass, modalFade) {\n    if (_vue2.default.prototype.$isServer) return;\n    if (!id || zIndex === undefined) return;\n    this.modalFade = modalFade;\n    var modalStack = this.modalStack;\n\n    for (var i = 0, j = modalStack.length; i < j; i++) {\n      var item = modalStack[i];\n\n      if (item.id === id) {\n        return;\n      }\n    }\n\n    var modalDom = getModal();\n    (0, _dom.addClass)(modalDom, 'v-modal');\n\n    if (this.modalFade && !hasModal) {\n      (0, _dom.addClass)(modalDom, 'v-modal-enter');\n    }\n\n    if (modalClass) {\n      var classArr = modalClass.trim().split(/\\s+/);\n      classArr.forEach(function (item) {\n        return (0, _dom.addClass)(modalDom, item);\n      });\n    }\n\n    setTimeout(function () {\n      (0, _dom.removeClass)(modalDom, 'v-modal-enter');\n    }, 200);\n\n    if (dom && dom.parentNode && dom.parentNode.nodeType !== 11) {\n      dom.parentNode.appendChild(modalDom);\n    } else {\n      document.body.appendChild(modalDom);\n    }\n\n    if (zIndex) {\n      modalDom.style.zIndex = zIndex;\n    }\n\n    modalDom.tabIndex = 0;\n    modalDom.style.display = '';\n    this.modalStack.push({\n      id: id,\n      zIndex: zIndex,\n      modalClass: modalClass\n    });\n  },\n  closeModal: function closeModal(id) {\n    var modalStack = this.modalStack;\n    var modalDom = getModal();\n\n    if (modalStack.length > 0) {\n      var topItem = modalStack[modalStack.length - 1];\n\n      if (topItem.id === id) {\n        if (topItem.modalClass) {\n          var classArr = topItem.modalClass.trim().split(/\\s+/);\n          classArr.forEach(function (item) {\n            return (0, _dom.removeClass)(modalDom, item);\n          });\n        }\n\n        modalStack.pop();\n\n        if (modalStack.length > 0) {\n          modalDom.style.zIndex = modalStack[modalStack.length - 1].zIndex;\n        }\n      } else {\n        for (var i = modalStack.length - 1; i >= 0; i--) {\n          if (modalStack[i].id === id) {\n            modalStack.splice(i, 1);\n            break;\n          }\n        }\n      }\n    }\n\n    if (modalStack.length === 0) {\n      if (this.modalFade) {\n        (0, _dom.addClass)(modalDom, 'v-modal-leave');\n      }\n\n      setTimeout(function () {\n        if (modalStack.length === 0) {\n          if (modalDom.parentNode) modalDom.parentNode.removeChild(modalDom);\n          modalDom.style.display = 'none';\n          PopupManager.modalDom = undefined;\n        }\n\n        (0, _dom.removeClass)(modalDom, 'v-modal-leave');\n      }, 200);\n    }\n  }\n};\nObject.defineProperty(PopupManager, 'zIndex', {\n  configurable: true,\n  get: function get() {\n    if (!hasInitZIndex) {\n      zIndex = zIndex || (_vue2.default.prototype.$ELEMENT || {}).zIndex || 2000;\n      hasInitZIndex = true;\n    }\n\n    return zIndex;\n  },\n  set: function set(value) {\n    zIndex = value;\n  }\n});\n\nvar getTopPopup = function getTopPopup() {\n  if (_vue2.default.prototype.$isServer) return;\n\n  if (PopupManager.modalStack.length > 0) {\n    var topPopup = PopupManager.modalStack[PopupManager.modalStack.length - 1];\n    if (!topPopup) return;\n    var instance = PopupManager.getInstance(topPopup.id);\n    return instance;\n  }\n};\n\nif (!_vue2.default.prototype.$isServer) {\n  // handle `esc` key when the popup is shown\n  window.addEventListener('keydown', function (event) {\n    if (event.keyCode === 27) {\n      var topPopup = getTopPopup();\n\n      if (topPopup && topPopup.closeOnPressEscape) {\n        topPopup.handleClose ? topPopup.handleClose() : topPopup.handleAction ? topPopup.handleAction('cancel') : topPopup.close();\n      }\n    }\n  });\n}\n\nexports.default = PopupManager;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdXRpbHMvcG9wdXAvcG9wdXAtbWFuYWdlci5qcz80YjI2Il0sIm5hbWVzIjpbImV4cG9ydHMiLCJfX2VzTW9kdWxlIiwiX3Z1ZSIsInJlcXVpcmUiLCJfdnVlMiIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfZG9tIiwib2JqIiwiZGVmYXVsdCIsImhhc01vZGFsIiwiaGFzSW5pdFpJbmRleCIsInpJbmRleCIsImdldE1vZGFsIiwicHJvdG90eXBlIiwiJGlzU2VydmVyIiwibW9kYWxEb20iLCJQb3B1cE1hbmFnZXIiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsImRvT25Nb2RhbENsaWNrIiwiaW5zdGFuY2VzIiwibW9kYWxGYWRlIiwiZ2V0SW5zdGFuY2UiLCJpZCIsInJlZ2lzdGVyIiwiaW5zdGFuY2UiLCJkZXJlZ2lzdGVyIiwibmV4dFpJbmRleCIsIm1vZGFsU3RhY2siLCJ0b3BJdGVtIiwibGVuZ3RoIiwiY2xvc2VPbkNsaWNrTW9kYWwiLCJjbG9zZSIsIm9wZW5Nb2RhbCIsImRvbSIsIm1vZGFsQ2xhc3MiLCJ1bmRlZmluZWQiLCJpIiwiaiIsIml0ZW0iLCJhZGRDbGFzcyIsImNsYXNzQXJyIiwidHJpbSIsInNwbGl0IiwiZm9yRWFjaCIsInNldFRpbWVvdXQiLCJyZW1vdmVDbGFzcyIsInBhcmVudE5vZGUiLCJub2RlVHlwZSIsImFwcGVuZENoaWxkIiwiYm9keSIsInN0eWxlIiwidGFiSW5kZXgiLCJkaXNwbGF5IiwicHVzaCIsImNsb3NlTW9kYWwiLCJwb3AiLCJzcGxpY2UiLCJyZW1vdmVDaGlsZCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiY29uZmlndXJhYmxlIiwiZ2V0IiwiJEVMRU1FTlQiLCJzZXQiLCJ2YWx1ZSIsImdldFRvcFBvcHVwIiwidG9wUG9wdXAiLCJ3aW5kb3ciLCJrZXlDb2RlIiwiY2xvc2VPblByZXNzRXNjYXBlIiwiaGFuZGxlQ2xvc2UiLCJoYW5kbGVBY3Rpb24iXSwibWFwcGluZ3MiOiJBQUFhOztBQUViQSxPQUFPLENBQUNDLFVBQVIsR0FBcUIsSUFBckI7O0FBRUEsSUFBSUMsSUFBSSxHQUFHQyxtQkFBTyxDQUFDLHVEQUFELENBQWxCOztBQUVBLElBQUlDLEtBQUssR0FBR0Msc0JBQXNCLENBQUNILElBQUQsQ0FBbEM7O0FBRUEsSUFBSUksSUFBSSxHQUFHSCxtQkFBTyxDQUFDLDRFQUFELENBQWxCOztBQUVBLFNBQVNFLHNCQUFULENBQWdDRSxHQUFoQyxFQUFxQztBQUFFLFNBQU9BLEdBQUcsSUFBSUEsR0FBRyxDQUFDTixVQUFYLEdBQXdCTSxHQUF4QixHQUE4QjtBQUFFQyxXQUFPLEVBQUVEO0FBQVgsR0FBckM7QUFBd0Q7O0FBRS9GLElBQUlFLFFBQVEsR0FBRyxLQUFmO0FBQ0EsSUFBSUMsYUFBYSxHQUFHLEtBQXBCO0FBQ0EsSUFBSUMsTUFBTSxHQUFHLEtBQUssQ0FBbEI7O0FBRUEsSUFBSUMsUUFBUSxHQUFHLFNBQVNBLFFBQVQsR0FBb0I7QUFDakMsTUFBSVIsS0FBSyxDQUFDSSxPQUFOLENBQWNLLFNBQWQsQ0FBd0JDLFNBQTVCLEVBQXVDO0FBQ3ZDLE1BQUlDLFFBQVEsR0FBR0MsWUFBWSxDQUFDRCxRQUE1Qjs7QUFDQSxNQUFJQSxRQUFKLEVBQWM7QUFDWk4sWUFBUSxHQUFHLElBQVg7QUFDRCxHQUZELE1BRU87QUFDTEEsWUFBUSxHQUFHLEtBQVg7QUFDQU0sWUFBUSxHQUFHRSxRQUFRLENBQUNDLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBWDtBQUNBRixnQkFBWSxDQUFDRCxRQUFiLEdBQXdCQSxRQUF4QjtBQUVBQSxZQUFRLENBQUNJLGdCQUFULENBQTBCLFdBQTFCLEVBQXVDLFVBQVVDLEtBQVYsRUFBaUI7QUFDdERBLFdBQUssQ0FBQ0MsY0FBTjtBQUNBRCxXQUFLLENBQUNFLGVBQU47QUFDRCxL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LFNBQWQsQ0FBd0JDLFNBQTVCLEVBQXVDOztBQUN2QyxNQUFJRSxZQUFZLENBQUNnQixVQUFiLENBQXdCRSxNQUF4QixHQUFpQyxDQUFyQyxFQUF3QztBQUN0QyxRQUFJcUMsUUFBUSxHQUFHdkQsWUFBWSxDQUFDZ0IsVUFBYixDQUF3QmhCLFlBQVksQ0FBQ2dCLFVBQWIsQ0FBd0JFLE1BQXhCLEdBQWlDLENBQXpELENBQWY7QUFDQSxRQUFJLENBQUNxQyxRQUFMLEVBQWU7QUFDZixRQUFJMUMsUUFBUSxHQUFHYixZQUFZLENBQUNVLFdBQWIsQ0FBeUI2QyxRQUFRLENBQUM1QyxFQUFsQyxDQUFmO0FBRUEsV0FBT0UsUUFBUDtBQUNEO0FBQ0YsQ0FURDs7QUFXQSxJQUFJLENBQUN6QixLQUFLLENBQUNJLE9BQU4sQ0FBY0ssU0FBZCxDQUF3QkMsU0FBN0IsRUFBd0M7QUFDdEM7QUFDQTBELFFBQU0sQ0FBQ3JELGdCQUFQLENBQXdCLFNBQXhCLEVBQW1DLFVBQVVDLEtBQVYsRUFBaUI7QUFDbEQsUUFBSUEsS0FBSyxDQUFDcUQsT0FBTixLQUFrQixFQUF0QixFQUEwQjtBQUN4QixVQUFJRixRQUFRLEdBQUdELFdBQVcsRUFBMUI7O0FBRUEsVUFBSUMsUUFBUSxJQUFJQSxRQUFRLENBQUNHLGtCQUF6QixFQUE2QztBQUMzQ0gsZ0JBQVEsQ0FBQ0ksV0FBVCxHQUF1QkosUUFBUSxDQUFDSSxXQUFULEVBQXZCLEdBQWdESixRQUFRLENBQUNLLFlBQVQsR0FBd0JMLFFBQVEsQ0FBQ0ssWUFBVCxDQUFzQixRQUF0QixDQUF4QixHQUEwREwsUUFBUSxDQUFDbkMsS0FBVCxFQUExRztBQUNEO0FBQ0Y7QUFDRixHQVJEO0FBU0Q7O0FBRURwQyxPQUFPLENBQUNRLE9BQVIsR0FBa0JRLFlBQWxCIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvbGliL3V0aWxzL3BvcHVwL3BvcHVwLW1hbmFnZXIuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfdnVlID0gcmVxdWlyZSgndnVlJyk7XG5cbnZhciBfdnVlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3Z1ZSk7XG5cbnZhciBfZG9tID0gcmVxdWlyZSgnZWxlbWVudC11aS9saWIvdXRpbHMvZG9tJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBoYXNNb2RhbCA9IGZhbHNlO1xudmFyIGhhc0luaXRaSW5kZXggPSBmYWxzZTtcbnZhciB6SW5kZXggPSB2b2lkIDA7XG5cbnZhciBnZXRNb2RhbCA9IGZ1bmN0aW9uIGdldE1vZGFsKCkge1xuICBpZiAoX3Z1ZTIuZGVmYXVsdC5wcm90b3R5cGUuJGlzU2VydmVyKSByZXR1cm47XG4gIHZhciBtb2RhbERvbSA9IFBvcHVwTWFuYWdlci5tb2RhbERvbTtcbiAgaWYgKG1vZGFsRG9tKSB7XG4gICAgaGFzTW9kYWwgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGhhc01vZGFsID0gZmFsc2U7XG4gICAgbW9kYWxEb20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBQb3B1cE1hbmFnZXIubW9kYWxEb20gPSBtb2RhbERvbTtcblxuICAgIG1vZGFsRG9tLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0pO1xuXG4gICAgbW9kYWxEb20uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICBQb3B1cE1hbmFnZXIuZG9Pbk1vZGFsQ2xpY2sgJiYgUG9wdXBNYW5hZ2VyLmRvT25Nb2RhbENsaWNrKCk7XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbW9kYWxEb207XG59O1xuXG52YXIgaW5zdGFuY2VzID0ge307XG5cbnZhciBQb3B1cE1hbmFnZXIgPSB7XG4gIG1vZGFsRmFkZTogdHJ1ZSxcblxuICBnZXRJbnN0YW5jZTogZnVuY3Rpb24gZ2V0SW5zdGFuY2UoaWQpIHtcbiAgICByZXR1cm4gaW5zdGFuY2VzW2lkXTtcbiAgfSxcblxuICByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIoaWQsIGluc3RhbmNlKSB7XG4gICAgaWYgKGlkICYmIGluc3RhbmNlKSB7XG4gICAgICBpbnN0YW5jZXNbaWRdID0gaW5zdGFuY2U7XG4gICAgfVxuICB9LFxuXG4gIGRlcmVnaXN0ZXI6IGZ1bmN0aW9uIGRlcmVnaXN0ZXIoaWQpIHtcbiAgICBpZiAoaWQpIHtcbiAgICAgIGluc3RhbmNlc1tpZF0gPSBudWxsO1xuICAgICAgZGVsZXRlIGluc3RhbmNlc1tpZF07XG4gICAgfVxuICB9LFxuXG4gIG5leHRaSW5kZXg6IGZ1bmN0aW9uIG5leHRaSW5kZXgoKSB7XG4gICAgcmV0dXJuIFBvcHVwTWFuYWdlci56SW5kZXgrKztcbiAgfSxcblxuICBtb2RhbFN0YWNrOiBbXSxcblxuICBkb09uTW9kYWxDbGljazogZnVuY3Rpb24gZG9Pbk1vZGFsQ2xpY2soKSB7XG4gICAgdmFyIHRvcEl0ZW0gPSBQb3B1cE1hbmFnZXIubW9kYWxTdGFja1tQb3B1cE1hbmFnZXIubW9kYWxTdGFjay5sZW5ndGggLSAxXTtcbiAgICBpZiAoIXRvcEl0ZW0pIHJldHVybjtcblxuICAgIHZhciBpbnN0YW5jZSA9IFBvcHVwTWFuYWdlci5nZXRJbnN0YW5jZSh0b3BJdGVtLmlkKTtcbiAgICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UuY2xvc2VPbkNsaWNrTW9kYWwpIHtcbiAgICAgIGluc3RhbmNlLmNsb3NlKCk7XG4gICAgfVxuICB9LFxuXG4gIG9wZW5Nb2RhbDogZnVuY3Rpb24gb3Blbk1vZGFsKGlkLCB6SW5kZXgsIGRvbSwgbW9kYWxDbGFzcywgbW9kYWxGYWRlKSB7XG4gICAgaWYgKF92dWUyLmRlZmF1bHQucHJvdG90eXBlLiRpc1NlcnZlcikgcmV0dXJuO1xuICAgIGlmICghaWQgfHwgekluZGV4ID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgICB0aGlzLm1vZGFsRmFkZSA9IG1vZGFsRmFkZTtcblxuICAgIHZhciBtb2RhbFN0YWNrID0gdGhpcy5tb2RhbFN0YWNrO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBtb2RhbFN0YWNrLmxlbmd0aDsgaSA8IGo7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBtb2RhbFN0YWNrW2ldO1xuICAgICAgaWYgKGl0ZW0uaWQgPT09IGlkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbW9kYWxEb20gPSBnZXRNb2RhbCgpO1xuXG4gICAgKDAsIF9kb20uYWRkQ2xhc3MpKG1vZGFsRG9tLCAndi1tb2RhbCcpO1xuICAgIGlmICh0aGlzLm1vZGFsRmFkZSAmJiAhaGFzTW9kYWwpIHtcbiAgICAgICgwLCBfZG9tLmFkZENsYXNzKShtb2RhbERvbSwgJ3YtbW9kYWwtZW50ZXInKTtcbiAgICB9XG4gICAgaWYgKG1vZGFsQ2xhc3MpIHtcbiAgICAgIHZhciBjbGFzc0FyciA9IG1vZGFsQ2xhc3MudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG4gICAgICBjbGFzc0Fyci5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiAoMCwgX2RvbS5hZGRDbGFzcykobW9kYWxEb20sIGl0ZW0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgKDAsIF9kb20ucmVtb3ZlQ2xhc3MpKG1vZGFsRG9tLCAndi1tb2RhbC1lbnRlcicpO1xuICAgIH0sIDIwMCk7XG5cbiAgICBpZiAoZG9tICYmIGRvbS5wYXJlbnROb2RlICYmIGRvbS5wYXJlbnROb2RlLm5vZGVUeXBlICE9PSAxMSkge1xuICAgICAgZG9tLnBhcmVudE5vZGUuYXBwZW5kQ2hpbGQobW9kYWxEb20pO1xuICAgIH0gZWxzZSB7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKG1vZGFsRG9tKTtcbiAgICB9XG5cbiAgICBpZiAoekluZGV4KSB7XG4gICAgICBtb2RhbERvbS5zdHlsZS56SW5kZXggPSB6SW5kZXg7XG4gICAgfVxuICAgIG1vZGFsRG9tLnRhYkluZGV4ID0gMDtcbiAgICBtb2RhbERvbS5zdHlsZS5kaXNwbGF5ID0gJyc7XG5cbiAgICB0aGlzLm1vZGFsU3RhY2sucHVzaCh7IGlkOiBpZCwgekluZGV4OiB6SW5kZXgsIG1vZGFsQ2xhc3M6IG1vZGFsQ2xhc3MgfSk7XG4gIH0sXG5cbiAgY2xvc2VNb2RhbDogZnVuY3Rpb24gY2xvc2VNb2RhbChpZCkge1xuICAgIHZhciBtb2RhbFN0YWNrID0gdGhpcy5tb2RhbFN0YWNrO1xuICAgIHZhciBtb2RhbERvbSA9IGdldE1vZGFsKCk7XG5cbiAgICBpZiAobW9kYWxTdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgdG9wSXRlbSA9IG1vZGFsU3RhY2tbbW9kYWxTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGlmICh0b3BJdGVtLmlkID09PSBpZCkge1xuICAgICAgICBpZiAodG9wSXRlbS5tb2RhbENsYXNzKSB7XG4gICAgICAgICAgdmFyIGNsYXNzQXJyID0gdG9wSXRlbS5tb2RhbENsYXNzLnRyaW0oKS5zcGxpdCgvXFxzKy8pO1xuICAgICAgICAgIGNsYXNzQXJyLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgX2RvbS5yZW1vdmVDbGFzcykobW9kYWxEb20sIGl0ZW0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9kYWxTdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKG1vZGFsU3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgIG1vZGFsRG9tLnN0eWxlLnpJbmRleCA9IG1vZGFsU3RhY2tbbW9kYWxTdGFjay5sZW5ndGggLSAxXS56SW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBtb2RhbFN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgaWYgKG1vZGFsU3RhY2tbaV0uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICBtb2RhbFN0YWNrLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtb2RhbFN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgaWYgKHRoaXMubW9kYWxGYWRlKSB7XG4gICAgICAgICgwLCBfZG9tLmFkZENsYXNzKShtb2RhbERvbSwgJ3YtbW9kYWwtbGVhdmUnKTtcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAobW9kYWxTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBpZiAobW9kYWxEb20ucGFyZW50Tm9kZSkgbW9kYWxEb20ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChtb2RhbERvbSk7XG4gICAgICAgICAgbW9kYWxEb20uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICBQb3B1cE1hbmFnZXIubW9kYWxEb20gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIF9kb20ucmVtb3ZlQ2xhc3MpKG1vZGFsRG9tLCAndi1tb2RhbC1sZWF2ZScpO1xuICAgICAgfSwgMjAwKTtcbiAgICB9XG4gIH1cbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShQb3B1cE1hbmFnZXIsICd6SW5kZXgnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKCFoYXNJbml0WkluZGV4KSB7XG4gICAgICB6SW5kZXggPSB6SW5kZXggfHwgKF92dWUyLmRlZmF1bHQucHJvdG90eXBlLiRFTEVNRU5UIHx8IHt9KS56SW5kZXggfHwgMjAwMDtcbiAgICAgIGhhc0luaXRaSW5kZXggPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gekluZGV4O1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIHpJbmRleCA9IHZhbHVlO1xuICB9XG59KTtcblxudmFyIGdldFRvcFBvcHVwID0gZnVuY3Rpb24gZ2V0VG9wUG9wdXAoKSB7XG4gIGlmIChfdnVlMi5kZWZhdWx0LnByb3RvdHlwZS4kaXNTZXJ2ZXIpIHJldHVybjtcbiAgaWYgKFBvcHVwTWFuYWdlci5tb2RhbFN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICB2YXIgdG9wUG9wdXAgPSBQb3B1cE1hbmFnZXIubW9kYWxTdGFja1tQb3B1cE1hbmFnZXIubW9kYWxTdGFjay5sZW5ndGggLSAxXTtcbiAgICBpZiAoIXRvcFBvcHVwKSByZXR1cm47XG4gICAgdmFyIGluc3RhbmNlID0gUG9wdXBNYW5hZ2VyLmdldEluc3RhbmNlKHRvcFBvcHVwLmlkKTtcblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxufTtcblxuaWYgKCFfdnVlMi5kZWZhdWx0LnByb3RvdHlwZS4kaXNTZXJ2ZXIpIHtcbiAgLy8gaGFuZGxlIGBlc2NgIGtleSB3aGVuIHRoZSBwb3B1cCBpcyBzaG93blxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5rZXlDb2RlID09PSAyNykge1xuICAgICAgdmFyIHRvcFBvcHVwID0gZ2V0VG9wUG9wdXAoKTtcblxuICAgICAgaWYgKHRvcFBvcHVwICYmIHRvcFBvcHVwLmNsb3NlT25QcmVzc0VzY2FwZSkge1xuICAgICAgICB0b3BQb3B1cC5oYW5kbGVDbG9zZSA/IHRvcFBvcHVwLmhhbmRsZUNsb3NlKCkgOiB0b3BQb3B1cC5oYW5kbGVBY3Rpb24gPyB0b3BQb3B1cC5oYW5kbGVBY3Rpb24oJ2NhbmNlbCcpIDogdG9wUG9wdXAuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBQb3B1cE1hbmFnZXI7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/element-ui/lib/utils/popup/popup-manager.js\n");

/***/ }),

/***/ "./node_modules/element-ui/lib/utils/scrollbar-width.js":
/*!**************************************************************!*\
  !*** ./node_modules/element-ui/lib/utils/scrollbar-width.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nexports.default = function () {\n  if (_vue2.default.prototype.$isServer) return 0;\n  if (scrollBarWidth !== undefined) return scrollBarWidth;\n  var outer = document.createElement('div');\n  outer.className = 'el-scrollbar__wrap';\n  outer.style.visibility = 'hidden';\n  outer.style.width = '100px';\n  outer.style.position = 'absolute';\n  outer.style.top = '-9999px';\n  document.body.appendChild(outer);\n  var widthNoScroll = outer.offsetWidth;\n  outer.style.overflow = 'scroll';\n  var inner = document.createElement('div');\n  inner.style.width = '100%';\n  outer.appendChild(inner);\n  var widthWithScroll = inner.offsetWidth;\n  outer.parentNode.removeChild(outer);\n  scrollBarWidth = widthNoScroll - widthWithScroll;\n  return scrollBarWidth;\n};\n\nvar _vue = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm.js\");\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar scrollBarWidth = void 0;\n;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdXRpbHMvc2Nyb2xsYmFyLXdpZHRoLmpzP2U2MmQiXSwibmFtZXMiOlsiZXhwb3J0cyIsIl9fZXNNb2R1bGUiLCJkZWZhdWx0IiwiX3Z1ZTIiLCJwcm90b3R5cGUiLCIkaXNTZXJ2ZXIiLCJzY3JvbGxCYXJXaWR0aCIsInVuZGVmaW5lZCIsIm91dGVyIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwic3R5bGUiLCJ2aXNpYmlsaXR5Iiwid2lkdGgiLCJwb3NpdGlvbiIsInRvcCIsImJvZHkiLCJhcHBlbmRDaGlsZCIsIndpZHRoTm9TY3JvbGwiLCJvZmZzZXRXaWR0aCIsIm92ZXJmbG93IiwiaW5uZXIiLCJ3aWR0aFdpdGhTY3JvbGwiLCJwYXJlbnROb2RlIiwicmVtb3ZlQ2hpbGQiLCJfdnVlIiwicmVxdWlyZSIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJvYmoiXSwibWFwcGluZ3MiOiJBQUFhOztBQUViQSxPQUFPLENBQUNDLFVBQVIsR0FBcUIsSUFBckI7O0FBRUFELE9BQU8sQ0FBQ0UsT0FBUixHQUFrQixZQUFZO0FBQzVCLE1BQUlDLEtBQUssQ0FBQ0QsT0FBTixDQUFjRSxTQUFkLENBQXdCQyxTQUE1QixFQUF1QyxPQUFPLENBQVA7QUFDdkMsTUFBSUMsY0FBYyxLQUFLQyxTQUF2QixFQUFrQyxPQUFPRCxjQUFQO0FBRWxDLE1BQUlFLEtBQUssR0FBR0MsUUFBUSxDQUFDQyxhQUFULENBQXVCLEtBQXZCLENBQVo7QUFDQUYsT0FBSyxDQUFDRyxTQUFOLEdBQWtCLG9CQUFsQjtBQUNBSCxPQUFLLENBQUNJLEtBQU4sQ0FBWUMsVUFBWixHQUF5QixRQUF6QjtBQUNBTCxPQUFLLENBQUNJLEtBQU4sQ0FBWUUsS0FBWixHQUFvQixPQUFwQjtBQUNBTixPQUFLLENBQUNJLEtBQU4sQ0FBWUcsUUFBWixHQUF1QixVQUF2QjtBQUNBUCxPQUFLLENBQUNJLEtBQU4sQ0FBWUksR0FBWixHQUFrQixTQUFsQjtBQUNBUCxVQUFRLENBQUNRLElBQVQsQ0FBY0MsV0FBZCxDQUEwQlYsS0FBMUI7QUFFQSxNQUFJVyxhQUFhLEdBQUdYLEtBQUssQ0FBQ1ksV0FBMUI7QUFDQVosT0FBSyxDQUFDSSxLQUFOLENBQVlTLFFBQVosR0FBdUIsUUFBdkI7QUFFQSxNQUFJQyxLQUFLLEdBQUdiLFFBQVEsQ0FBQ0MsYUFBVCxDQUF1QixLQUF2QixDQUFaO0FBQ0FZLE9BQUssQ0FBQ1YsS0FBTixDQUFZRSxLQUFaLEdBQW9CLE1BQXBCO0FBQ0FOLE9BQUssQ0FBQ1UsV0FBTixDQUFrQkksS0FBbEI7QUFFQSxNQUFJQyxlQUFlLEdBQUdELEtBQUssQ0FBQ0YsV0FBNUI7QUFDQVosT0FBSyxDQUFDZ0IsVUFBTixDQUFpQkMsV0FBakIsQ0FBNkJqQixLQUE3QjtBQUNBRixnQkFBYyxHQUFHYSxhQUFhLEdBQUdJLGVBQWpDO0FBRUEsU0FBT2pCLGNBQVA7QUFDRCxDQXhCRDs7QUEwQkEsSUFBSW9CLElBQUksR0FBR0MsbUJBQU8sQ0FBQyx1REFBRCxDQUFsQjs7QUFFQSxJQUFJeEIsS0FBSyxHQUFHeUIsc0JBQXNCLENBQUNGLElBQUQsQ0FBbEM7O0FBRUEsU0FBU0Usc0JBQVQsQ0FBZ0NDLEdBQWhDLEVBQXFDO0FBQUUsU0FBT0EsR0FBRyxJQUFJQSxHQUFHLENBQUM1QixVQUFYLEdBQXdCNEIsR0FBeEIsR0FBOEI7QUFBRTNCLFdBQU8sRUFBRTJCO0FBQVgsR0FBckM7QUFBd0Q7O0FBRS9GLElBQUl2QixjQUFjLEdBQUcsS0FBSyxDQUExQjtBQUVBIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvbGliL3V0aWxzL3Njcm9sbGJhci13aWR0aC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX3Z1ZTIuZGVmYXVsdC5wcm90b3R5cGUuJGlzU2VydmVyKSByZXR1cm4gMDtcbiAgaWYgKHNjcm9sbEJhcldpZHRoICE9PSB1bmRlZmluZWQpIHJldHVybiBzY3JvbGxCYXJXaWR0aDtcblxuICB2YXIgb3V0ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgb3V0ZXIuY2xhc3NOYW1lID0gJ2VsLXNjcm9sbGJhcl9fd3JhcCc7XG4gIG91dGVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgb3V0ZXIuc3R5bGUud2lkdGggPSAnMTAwcHgnO1xuICBvdXRlci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gIG91dGVyLnN0eWxlLnRvcCA9ICctOTk5OXB4JztcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChvdXRlcik7XG5cbiAgdmFyIHdpZHRoTm9TY3JvbGwgPSBvdXRlci5vZmZzZXRXaWR0aDtcbiAgb3V0ZXIuc3R5bGUub3ZlcmZsb3cgPSAnc2Nyb2xsJztcblxuICB2YXIgaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgaW5uZXIuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gIG91dGVyLmFwcGVuZENoaWxkKGlubmVyKTtcblxuICB2YXIgd2lkdGhXaXRoU2Nyb2xsID0gaW5uZXIub2Zmc2V0V2lkdGg7XG4gIG91dGVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQob3V0ZXIpO1xuICBzY3JvbGxCYXJXaWR0aCA9IHdpZHRoTm9TY3JvbGwgLSB3aWR0aFdpdGhTY3JvbGw7XG5cbiAgcmV0dXJuIHNjcm9sbEJhcldpZHRoO1xufTtcblxudmFyIF92dWUgPSByZXF1aXJlKCd2dWUnKTtcblxudmFyIF92dWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdnVlKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHNjcm9sbEJhcldpZHRoID0gdm9pZCAwO1xuXG47Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/element-ui/lib/utils/scrollbar-width.js\n");

/***/ }),

/***/ "./node_modules/element-ui/lib/utils/vue-popper.js":
/*!*********************************************************!*\
  !*** ./node_modules/element-ui/lib/utils/vue-popper.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\n\nvar _vue = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm.js\");\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nvar _popup = __webpack_require__(/*! element-ui/lib/utils/popup */ \"./node_modules/element-ui/lib/utils/popup/index.js\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar PopperJS = _vue2.default.prototype.$isServer ? function () {} : __webpack_require__(/*! ./popper */ \"./node_modules/element-ui/lib/utils/popper.js\");\n\nvar stop = function stop(e) {\n  return e.stopPropagation();\n};\n/**\n * @param {HTMLElement} [reference=$refs.reference] - The reference element used to position the popper.\n * @param {HTMLElement} [popper=$refs.popper] - The HTML element used as popper, or a configuration used to generate the popper.\n * @param {String} [placement=button] - Placement of the popper accepted values: top(-start, -end), right(-start, -end), bottom(-start, -end), left(-start, -end)\n * @param {Number} [offset=0] - Amount of pixels the popper will be shifted (can be negative).\n * @param {Boolean} [visible=false] Visibility of the popup element.\n * @param {Boolean} [visible-arrow=false] Visibility of the arrow, no style.\n */\n\n\nexports.default = {\n  props: {\n    transformOrigin: {\n      type: [Boolean, String],\n      default: true\n    },\n    placement: {\n      type: String,\n      default: 'bottom'\n    },\n    boundariesPadding: {\n      type: Number,\n      default: 5\n    },\n    reference: {},\n    popper: {},\n    offset: {\n      default: 0\n    },\n    value: Boolean,\n    visibleArrow: Boolean,\n    arrowOffset: {\n      type: Number,\n      default: 35\n    },\n    appendToBody: {\n      type: Boolean,\n      default: true\n    },\n    popperOptions: {\n      type: Object,\n      default: function _default() {\n        return {\n          gpuAcceleration: false\n        };\n      }\n    }\n  },\n  data: function data() {\n    return {\n      showPopper: false,\n      currentPlacement: ''\n    };\n  },\n  watch: {\n    value: {\n      immediate: true,\n      handler: function handler(val) {\n        this.showPopper = val;\n        this.$emit('input', val);\n      }\n    },\n    showPopper: function showPopper(val) {\n      if (this.disabled) return;\n      val ? this.updatePopper() : this.destroyPopper();\n      this.$emit('input', val);\n    }\n  },\n  methods: {\n    createPopper: function createPopper() {\n      var _this = this;\n\n      if (this.$isServer) return;\n      this.currentPlacement = this.currentPlacement || this.placement;\n\n      if (!/^(top|bottom|left|right)(-start|-end)?$/g.test(this.currentPlacement)) {\n        return;\n      }\n\n      var options = this.popperOptions;\n      var popper = this.popperElm = this.popperElm || this.popper || this.$refs.popper;\n      var reference = this.referenceElm = this.referenceElm || this.reference || this.$refs.reference;\n\n      if (!reference && this.$slots.reference && this.$slots.reference[0]) {\n        reference = this.referenceElm = this.$slots.reference[0].elm;\n      }\n\n      if (!popper || !reference) return;\n      if (this.visibleArrow) this.appendArrow(popper);\n      if (this.appendToBody) document.body.appendChild(this.popperElm);\n\n      if (this.popperJS && this.popperJS.destroy) {\n        this.popperJS.destroy();\n      }\n\n      options.placement = this.currentPlacement;\n      options.offset = this.offset;\n      options.arrowOffset = this.arrowOffset;\n      this.popperJS = new PopperJS(reference, popper, options);\n      this.popperJS.onCreate(function (_) {\n        _this.$emit('created', _this);\n\n        _this.resetTransformOrigin();\n\n        _this.$nextTick(_this.updatePopper);\n      });\n\n      if (typeof options.onUpdate === 'function') {\n        this.popperJS.onUpdate(options.onUpdate);\n      }\n\n      this.popperJS._popper.style.zIndex = _popup.PopupManager.nextZIndex();\n      this.popperElm.addEventListener('click', stop);\n    },\n    updatePopper: function updatePopper() {\n      var popperJS = this.popperJS;\n\n      if (popperJS) {\n        popperJS.update();\n\n        if (popperJS._popper) {\n          popperJS._popper.style.zIndex = _popup.PopupManager.nextZIndex();\n        }\n      } else {\n        this.createPopper();\n      }\n    },\n    doDestroy: function doDestroy(forceDestroy) {\n      /* istanbul ignore if */\n      if (!this.popperJS || this.showPopper && !forceDestroy) return;\n      this.popperJS.destroy();\n      this.popperJS = null;\n    },\n    destroyPopper: function destroyPopper() {\n      if (this.popperJS) {\n        this.resetTransformOrigin();\n      }\n    },\n    resetTransformOrigin: function resetTransformOrigin() {\n      if (!this.transformOrigin) return;\n      var placementMap = {\n        top: 'bottom',\n        bottom: 'top',\n        left: 'right',\n        right: 'left'\n      };\n\n      var placement = this.popperJS._popper.getAttribute('x-placement').split('-')[0];\n\n      var origin = placementMap[placement];\n      this.popperJS._popper.style.transformOrigin = typeof this.transformOrigin === 'string' ? this.transformOrigin : ['top', 'bottom'].indexOf(placement) > -1 ? 'center ' + origin : origin + ' center';\n    },\n    appendArrow: function appendArrow(element) {\n      var hash = void 0;\n\n      if (this.appended) {\n        return;\n      }\n\n      this.appended = true;\n\n      for (var item in element.attributes) {\n        if (/^_v-/.test(element.attributes[item].name)) {\n          hash = element.attributes[item].name;\n          break;\n        }\n      }\n\n      var arrow = document.createElement('div');\n\n      if (hash) {\n        arrow.setAttribute(hash, '');\n      }\n\n      arrow.setAttribute('x-arrow', '');\n      arrow.className = 'popper__arrow';\n      element.appendChild(arrow);\n    }\n  },\n  beforeDestroy: function beforeDestroy() {\n    this.doDestroy(true);\n\n    if (this.popperElm && this.popperElm.parentNode === document.body) {\n      this.popperElm.removeEventListener('click', stop);\n      document.body.removeChild(this.popperElm);\n    }\n  },\n  // call destroy in keep-alive mode\n  deactivated: function deactivated() {\n    this.$options.beforeDestroy[0].call(this);\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdXRpbHMvdnVlLXBvcHBlci5qcz9lOTc0Il0sIm5hbWVzIjpbImV4cG9ydHMiLCJfX2VzTW9kdWxlIiwiX3Z1ZSIsInJlcXVpcmUiLCJfdnVlMiIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfcG9wdXAiLCJvYmoiLCJkZWZhdWx0IiwiUG9wcGVySlMiLCJwcm90b3R5cGUiLCIkaXNTZXJ2ZXIiLCJzdG9wIiwiZSIsInN0b3BQcm9wYWdhdGlvbiIsInByb3BzIiwidHJhbnNmb3JtT3JpZ2luIiwidHlwZSIsIkJvb2xlYW4iLCJTdHJpbmciLCJwbGFjZW1lbnQiLCJib3VuZGFyaWVzUGFkZGluZyIsIk51bWJlciIsInJlZmVyZW5jZSIsInBvcHBlciIsIm9mZnNldCIsInZhbHVlIiwidmlzaWJsZUFycm93IiwiYXJyb3dPZmZzZXQiLCJhcHBlbmRUb0JvZHkiLCJwb3BwZXJPcHRpb25zIiwiT2JqZWN0IiwiX2RlZmF1bHQiLCJncHVBY2NlbGVyYXRpb24iLCJkYXRhIiwic2hvd1BvcHBlciIsImN1cnJlbnRQbGFjZW1lbnQiLCJ3YXRjaCIsImltbWVkaWF0ZSIsImhhbmRsZXIiLCJ2YWwiLCIkZW1pdCIsImRpc2FibGVkIiwidXBkYXRlUG9wcGVyIiwiZGVzdHJveVBvcHBlciIsIm1ldGhvZHMiLCJjcmVhdGVQb3BwZXIiLCJfdGhpcyIsInRlc3QiLCJvcHRpb25zIiwicG9wcGVyRWxtIiwiJHJlZnMiLCJyZWZlcmVuY2VFbG0iLCIkc2xvdHMiLCJlbG0iLCJhcHBlbmRBcnJvdyIsImRvY3VtZW50IiwiYm9keSIsImFwcGVuZENoaWxkIiwicG9wcGVySlMiLCJkZXN0cm95Iiwib25DcmVhdGUiLCJfIiwicmVzZXRUcmFuc2Zvcm1PcmlnaW4iLCIkbmV4dFRpY2siLCJvblVwZGF0ZSIsIl9wb3BwZXIiLCJzdHlsZSIsInpJbmRleCIsIlBvcHVwTWFuYWdlciIsIm5leHRaSW5kZXgiLCJhZGRFdmVudExpc3RlbmVyIiwidXBkYXRlIiwiZG9EZXN0cm95IiwiZm9yY2VEZXN0cm95IiwicGxhY2VtZW50TWFwIiwidG9wIiwiYm90dG9tIiwibGVmdCIsInJpZ2h0IiwiZ2V0QXR0cmlidXRlIiwic3BsaXQiLCJvcmlnaW4iLCJpbmRleE9mIiwiZWxlbWVudCIsImhhc2giLCJhcHBlbmRlZCIsIml0ZW0iLCJhdHRyaWJ1dGVzIiwibmFtZSIsImFycm93IiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsImNsYXNzTmFtZSIsImJlZm9yZURlc3Ryb3kiLCJwYXJlbnROb2RlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZUNoaWxkIiwiZGVhY3RpdmF0ZWQiLCIkb3B0aW9ucyIsImNhbGwiXSwibWFwcGluZ3MiOiJBQUFhOztBQUViQSxPQUFPLENBQUNDLFVBQVIsR0FBcUIsSUFBckI7O0FBRUEsSUFBSUMsSUFBSSxHQUFHQyxtQkFBTyxDQUFDLHVEQUFELENBQWxCOztBQUVBLElBQUlDLEtBQUssR0FBR0Msc0JBQXNCLENBQUNILElBQUQsQ0FBbEM7O0FBRUEsSUFBSUksTUFBTSxHQUFHSCxtQkFBTyxDQUFDLHNGQUFELENBQXBCOztBQUVBLFNBQVNFLHNCQUFULENBQWdDRSxHQUFoQyxFQUFxQztBQUFFLFNBQU9BLEdBQUcsSUFBSUEsR0FBRyxDQUFDTixVQUFYLEdBQXdCTSxHQUF4QixHQUE4QjtBQUFFQyxXQUFPLEVBQUVEO0FBQVgsR0FBckM7QUFBd0Q7O0FBRS9GLElBQUlFLFFBQVEsR0FBR0wsS0FBSyxDQUFDSSxPQUFOLENBQWNFLFNBQWQsQ0FBd0JDLFNBQXhCLEdBQW9DLFlBQVksQ0FBRSxDQUFsRCxHQUFxRFIsbUJBQU8sQ0FBQywrREFBRCxDQUEzRTs7QUFDQSxJQUFJUyxJQUFJLEdBQUcsU0FBU0EsSUFBVCxDQUFjQyxDQUFkLEVBQWlCO0FBQzFCLFNBQU9BLENBQUMsQ0FBQ0MsZUFBRixFQUFQO0FBQ0QsQ0FGRDtBQUlBOzs7Ozs7Ozs7O0FBUUFkLE9BQU8s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O0FBQ0Q7QUFqR00sR0EvRE87QUFtS2hCSSxlQUFhLEVBQUUsU0FBU0EsYUFBVCxHQUF5QjtBQUN0QyxTQUFLckIsU0FBTCxDQUFlLElBQWY7O0FBQ0EsUUFBSSxLQUFLdkIsU0FBTCxJQUFrQixLQUFLQSxTQUFMLENBQWU2QyxVQUFmLEtBQThCdkMsUUFBUSxDQUFDQyxJQUE3RCxFQUFtRTtBQUNqRSxXQUFLUCxTQUFMLENBQWU4QyxtQkFBZixDQUFtQyxPQUFuQyxFQUE0Q3BGLElBQTVDO0FBQ0E0QyxjQUFRLENBQUNDLElBQVQsQ0FBY3dDLFdBQWQsQ0FBMEIsS0FBSy9DLFNBQS9CO0FBQ0Q7QUFDRixHQXpLZTtBQTRLaEI7QUFDQWdELGFBQVcsRUFBRSxTQUFTQSxXQUFULEdBQXVCO0FBQ2xDLFNBQUtDLFFBQUwsQ0FBY0wsYUFBZCxDQUE0QixDQUE1QixFQUErQk0sSUFBL0IsQ0FBb0MsSUFBcEM7QUFDRDtBQS9LZSxDQUFsQiIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9lbGVtZW50LXVpL2xpYi91dGlscy92dWUtcG9wcGVyLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3Z1ZSA9IHJlcXVpcmUoJ3Z1ZScpO1xuXG52YXIgX3Z1ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF92dWUpO1xuXG52YXIgX3BvcHVwID0gcmVxdWlyZSgnZWxlbWVudC11aS9saWIvdXRpbHMvcG9wdXAnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIFBvcHBlckpTID0gX3Z1ZTIuZGVmYXVsdC5wcm90b3R5cGUuJGlzU2VydmVyID8gZnVuY3Rpb24gKCkge30gOiByZXF1aXJlKCcuL3BvcHBlcicpO1xudmFyIHN0b3AgPSBmdW5jdGlvbiBzdG9wKGUpIHtcbiAgcmV0dXJuIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IFtyZWZlcmVuY2U9JHJlZnMucmVmZXJlbmNlXSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBbcG9wcGVyPSRyZWZzLnBvcHBlcl0gLSBUaGUgSFRNTCBlbGVtZW50IHVzZWQgYXMgcG9wcGVyLCBvciBhIGNvbmZpZ3VyYXRpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGUgcG9wcGVyLlxuICogQHBhcmFtIHtTdHJpbmd9IFtwbGFjZW1lbnQ9YnV0dG9uXSAtIFBsYWNlbWVudCBvZiB0aGUgcG9wcGVyIGFjY2VwdGVkIHZhbHVlczogdG9wKC1zdGFydCwgLWVuZCksIHJpZ2h0KC1zdGFydCwgLWVuZCksIGJvdHRvbSgtc3RhcnQsIC1lbmQpLCBsZWZ0KC1zdGFydCwgLWVuZClcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0PTBdIC0gQW1vdW50IG9mIHBpeGVscyB0aGUgcG9wcGVyIHdpbGwgYmUgc2hpZnRlZCAoY2FuIGJlIG5lZ2F0aXZlKS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3Zpc2libGU9ZmFsc2VdIFZpc2liaWxpdHkgb2YgdGhlIHBvcHVwIGVsZW1lbnQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFt2aXNpYmxlLWFycm93PWZhbHNlXSBWaXNpYmlsaXR5IG9mIHRoZSBhcnJvdywgbm8gc3R5bGUuXG4gKi9cbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgcHJvcHM6IHtcbiAgICB0cmFuc2Zvcm1PcmlnaW46IHtcbiAgICAgIHR5cGU6IFtCb29sZWFuLCBTdHJpbmddLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH0sXG4gICAgcGxhY2VtZW50OiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAnYm90dG9tJ1xuICAgIH0sXG4gICAgYm91bmRhcmllc1BhZGRpbmc6IHtcbiAgICAgIHR5cGU6IE51bWJlcixcbiAgICAgIGRlZmF1bHQ6IDVcbiAgICB9LFxuICAgIHJlZmVyZW5jZToge30sXG4gICAgcG9wcGVyOiB7fSxcbiAgICBvZmZzZXQ6IHtcbiAgICAgIGRlZmF1bHQ6IDBcbiAgICB9LFxuICAgIHZhbHVlOiBCb29sZWFuLFxuICAgIHZpc2libGVBcnJvdzogQm9vbGVhbixcbiAgICBhcnJvd09mZnNldDoge1xuICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgZGVmYXVsdDogMzVcbiAgICB9LFxuICAgIGFwcGVuZFRvQm9keToge1xuICAgICAgdHlwZTogQm9vbGVhbixcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9LFxuICAgIHBvcHBlck9wdGlvbnM6IHtcbiAgICAgIHR5cGU6IE9iamVjdCxcbiAgICAgIGRlZmF1bHQ6IGZ1bmN0aW9uIF9kZWZhdWx0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGdwdUFjY2VsZXJhdGlvbjogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgZGF0YTogZnVuY3Rpb24gZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc2hvd1BvcHBlcjogZmFsc2UsXG4gICAgICBjdXJyZW50UGxhY2VtZW50OiAnJ1xuICAgIH07XG4gIH0sXG5cblxuICB3YXRjaDoge1xuICAgIHZhbHVlOiB7XG4gICAgICBpbW1lZGlhdGU6IHRydWUsXG4gICAgICBoYW5kbGVyOiBmdW5jdGlvbiBoYW5kbGVyKHZhbCkge1xuICAgICAgICB0aGlzLnNob3dQb3BwZXIgPSB2YWw7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2lucHV0JywgdmFsKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc2hvd1BvcHBlcjogZnVuY3Rpb24gc2hvd1BvcHBlcih2YWwpIHtcbiAgICAgIGlmICh0aGlzLmRpc2FibGVkKSByZXR1cm47XG4gICAgICB2YWwgPyB0aGlzLnVwZGF0ZVBvcHBlcigpIDogdGhpcy5kZXN0cm95UG9wcGVyKCk7XG4gICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIHZhbCk7XG4gICAgfVxuICB9LFxuXG4gIG1ldGhvZHM6IHtcbiAgICBjcmVhdGVQb3BwZXI6IGZ1bmN0aW9uIGNyZWF0ZVBvcHBlcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLiRpc1NlcnZlcikgcmV0dXJuO1xuICAgICAgdGhpcy5jdXJyZW50UGxhY2VtZW50ID0gdGhpcy5jdXJyZW50UGxhY2VtZW50IHx8IHRoaXMucGxhY2VtZW50O1xuICAgICAgaWYgKCEvXih0b3B8Ym90dG9tfGxlZnR8cmlnaHQpKC1zdGFydHwtZW5kKT8kL2cudGVzdCh0aGlzLmN1cnJlbnRQbGFjZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLnBvcHBlck9wdGlvbnM7XG4gICAgICB2YXIgcG9wcGVyID0gdGhpcy5wb3BwZXJFbG0gPSB0aGlzLnBvcHBlckVsbSB8fCB0aGlzLnBvcHBlciB8fCB0aGlzLiRyZWZzLnBvcHBlcjtcbiAgICAgIHZhciByZWZlcmVuY2UgPSB0aGlzLnJlZmVyZW5jZUVsbSA9IHRoaXMucmVmZXJlbmNlRWxtIHx8IHRoaXMucmVmZXJlbmNlIHx8IHRoaXMuJHJlZnMucmVmZXJlbmNlO1xuXG4gICAgICBpZiAoIXJlZmVyZW5jZSAmJiB0aGlzLiRzbG90cy5yZWZlcmVuY2UgJiYgdGhpcy4kc2xvdHMucmVmZXJlbmNlWzBdKSB7XG4gICAgICAgIHJlZmVyZW5jZSA9IHRoaXMucmVmZXJlbmNlRWxtID0gdGhpcy4kc2xvdHMucmVmZXJlbmNlWzBdLmVsbTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFwb3BwZXIgfHwgIXJlZmVyZW5jZSkgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMudmlzaWJsZUFycm93KSB0aGlzLmFwcGVuZEFycm93KHBvcHBlcik7XG4gICAgICBpZiAodGhpcy5hcHBlbmRUb0JvZHkpIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5wb3BwZXJFbG0pO1xuICAgICAgaWYgKHRoaXMucG9wcGVySlMgJiYgdGhpcy5wb3BwZXJKUy5kZXN0cm95KSB7XG4gICAgICAgIHRoaXMucG9wcGVySlMuZGVzdHJveSgpO1xuICAgICAgfVxuXG4gICAgICBvcHRpb25zLnBsYWNlbWVudCA9IHRoaXMuY3VycmVudFBsYWNlbWVudDtcbiAgICAgIG9wdGlvbnMub2Zmc2V0ID0gdGhpcy5vZmZzZXQ7XG4gICAgICBvcHRpb25zLmFycm93T2Zmc2V0ID0gdGhpcy5hcnJvd09mZnNldDtcbiAgICAgIHRoaXMucG9wcGVySlMgPSBuZXcgUG9wcGVySlMocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5wb3BwZXJKUy5vbkNyZWF0ZShmdW5jdGlvbiAoXykge1xuICAgICAgICBfdGhpcy4kZW1pdCgnY3JlYXRlZCcsIF90aGlzKTtcbiAgICAgICAgX3RoaXMucmVzZXRUcmFuc2Zvcm1PcmlnaW4oKTtcbiAgICAgICAgX3RoaXMuJG5leHRUaWNrKF90aGlzLnVwZGF0ZVBvcHBlcik7XG4gICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5vblVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aGlzLnBvcHBlckpTLm9uVXBkYXRlKG9wdGlvbnMub25VcGRhdGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5wb3BwZXJKUy5fcG9wcGVyLnN0eWxlLnpJbmRleCA9IF9wb3B1cC5Qb3B1cE1hbmFnZXIubmV4dFpJbmRleCgpO1xuICAgICAgdGhpcy5wb3BwZXJFbG0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzdG9wKTtcbiAgICB9LFxuICAgIHVwZGF0ZVBvcHBlcjogZnVuY3Rpb24gdXBkYXRlUG9wcGVyKCkge1xuICAgICAgdmFyIHBvcHBlckpTID0gdGhpcy5wb3BwZXJKUztcbiAgICAgIGlmIChwb3BwZXJKUykge1xuICAgICAgICBwb3BwZXJKUy51cGRhdGUoKTtcbiAgICAgICAgaWYgKHBvcHBlckpTLl9wb3BwZXIpIHtcbiAgICAgICAgICBwb3BwZXJKUy5fcG9wcGVyLnN0eWxlLnpJbmRleCA9IF9wb3B1cC5Qb3B1cE1hbmFnZXIubmV4dFpJbmRleCgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNyZWF0ZVBvcHBlcigpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZG9EZXN0cm95OiBmdW5jdGlvbiBkb0Rlc3Ryb3koZm9yY2VEZXN0cm95KSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmICghdGhpcy5wb3BwZXJKUyB8fCB0aGlzLnNob3dQb3BwZXIgJiYgIWZvcmNlRGVzdHJveSkgcmV0dXJuO1xuICAgICAgdGhpcy5wb3BwZXJKUy5kZXN0cm95KCk7XG4gICAgICB0aGlzLnBvcHBlckpTID0gbnVsbDtcbiAgICB9LFxuICAgIGRlc3Ryb3lQb3BwZXI6IGZ1bmN0aW9uIGRlc3Ryb3lQb3BwZXIoKSB7XG4gICAgICBpZiAodGhpcy5wb3BwZXJKUykge1xuICAgICAgICB0aGlzLnJlc2V0VHJhbnNmb3JtT3JpZ2luKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZXNldFRyYW5zZm9ybU9yaWdpbjogZnVuY3Rpb24gcmVzZXRUcmFuc2Zvcm1PcmlnaW4oKSB7XG4gICAgICBpZiAoIXRoaXMudHJhbnNmb3JtT3JpZ2luKSByZXR1cm47XG4gICAgICB2YXIgcGxhY2VtZW50TWFwID0ge1xuICAgICAgICB0b3A6ICdib3R0b20nLFxuICAgICAgICBib3R0b206ICd0b3AnLFxuICAgICAgICBsZWZ0OiAncmlnaHQnLFxuICAgICAgICByaWdodDogJ2xlZnQnXG4gICAgICB9O1xuICAgICAgdmFyIHBsYWNlbWVudCA9IHRoaXMucG9wcGVySlMuX3BvcHBlci5nZXRBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50Jykuc3BsaXQoJy0nKVswXTtcbiAgICAgIHZhciBvcmlnaW4gPSBwbGFjZW1lbnRNYXBbcGxhY2VtZW50XTtcbiAgICAgIHRoaXMucG9wcGVySlMuX3BvcHBlci5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSB0eXBlb2YgdGhpcy50cmFuc2Zvcm1PcmlnaW4gPT09ICdzdHJpbmcnID8gdGhpcy50cmFuc2Zvcm1PcmlnaW4gOiBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgPiAtMSA/ICdjZW50ZXIgJyArIG9yaWdpbiA6IG9yaWdpbiArICcgY2VudGVyJztcbiAgICB9LFxuICAgIGFwcGVuZEFycm93OiBmdW5jdGlvbiBhcHBlbmRBcnJvdyhlbGVtZW50KSB7XG4gICAgICB2YXIgaGFzaCA9IHZvaWQgMDtcbiAgICAgIGlmICh0aGlzLmFwcGVuZGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hcHBlbmRlZCA9IHRydWU7XG5cbiAgICAgIGZvciAodmFyIGl0ZW0gaW4gZWxlbWVudC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGlmICgvXl92LS8udGVzdChlbGVtZW50LmF0dHJpYnV0ZXNbaXRlbV0ubmFtZSkpIHtcbiAgICAgICAgICBoYXNoID0gZWxlbWVudC5hdHRyaWJ1dGVzW2l0ZW1dLm5hbWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGFycm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICAgIGlmIChoYXNoKSB7XG4gICAgICAgIGFycm93LnNldEF0dHJpYnV0ZShoYXNoLCAnJyk7XG4gICAgICB9XG4gICAgICBhcnJvdy5zZXRBdHRyaWJ1dGUoJ3gtYXJyb3cnLCAnJyk7XG4gICAgICBhcnJvdy5jbGFzc05hbWUgPSAncG9wcGVyX19hcnJvdyc7XG4gICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGFycm93KTtcbiAgICB9XG4gIH0sXG5cbiAgYmVmb3JlRGVzdHJveTogZnVuY3Rpb24gYmVmb3JlRGVzdHJveSgpIHtcbiAgICB0aGlzLmRvRGVzdHJveSh0cnVlKTtcbiAgICBpZiAodGhpcy5wb3BwZXJFbG0gJiYgdGhpcy5wb3BwZXJFbG0ucGFyZW50Tm9kZSA9PT0gZG9jdW1lbnQuYm9keSkge1xuICAgICAgdGhpcy5wb3BwZXJFbG0ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzdG9wKTtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQodGhpcy5wb3BwZXJFbG0pO1xuICAgIH1cbiAgfSxcblxuXG4gIC8vIGNhbGwgZGVzdHJveSBpbiBrZWVwLWFsaXZlIG1vZGVcbiAgZGVhY3RpdmF0ZWQ6IGZ1bmN0aW9uIGRlYWN0aXZhdGVkKCkge1xuICAgIHRoaXMuJG9wdGlvbnMuYmVmb3JlRGVzdHJveVswXS5jYWxsKHRoaXMpO1xuICB9XG59OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/element-ui/lib/utils/vue-popper.js\n");

/***/ })

}]);