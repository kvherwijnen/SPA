(window["webpackJsonp"] = window["webpackJsonp"] || []).push([["vendors~footer-tabs"],{

/***/ "./node_modules/element-ui/lib/tabs.js":
/*!*********************************************!*\
  !*** ./node_modules/element-ui/lib/tabs.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId]) {\n      /******/\n      return installedModules[moduleId].exports;\n      /******/\n    }\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n\n    var module = installedModules[moduleId] = {\n      /******/\n      i: moduleId,\n\n      /******/\n      l: false,\n\n      /******/\n      exports: {}\n      /******/\n\n    };\n    /******/\n\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.l = true;\n    /******/\n\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n\n  /******/\n\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n\n  /******/\n  // define getter function for harmony exports\n\n  /******/\n\n  __webpack_require__.d = function (exports, name, getter) {\n    /******/\n    if (!__webpack_require__.o(exports, name)) {\n      /******/\n      Object.defineProperty(exports, name, {\n        enumerable: true,\n        get: getter\n      });\n      /******/\n    }\n    /******/\n\n  };\n  /******/\n\n  /******/\n  // define __esModule on exports\n\n  /******/\n\n\n  __webpack_require__.r = function (exports) {\n    /******/\n    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n      /******/\n      Object.defineProperty(exports, Symbol.toStringTag, {\n        value: 'Module'\n      });\n      /******/\n    }\n    /******/\n\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    /******/\n  };\n  /******/\n\n  /******/\n  // create a fake namespace object\n\n  /******/\n  // mode & 1: value is a module id, require it\n\n  /******/\n  // mode & 2: merge all properties of value into the ns\n\n  /******/\n  // mode & 4: return value when already ns object\n\n  /******/\n  // mode & 8|1: behave like require\n\n  /******/\n\n\n  __webpack_require__.t = function (value, mode) {\n    /******/\n    if (mode & 1) value = __webpack_require__(value);\n    /******/\n\n    if (mode & 8) return value;\n    /******/\n\n    if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;\n    /******/\n\n    var ns = Object.create(null);\n    /******/\n\n    __webpack_require__.r(ns);\n    /******/\n\n\n    Object.defineProperty(ns, 'default', {\n      enumerable: true,\n      value: value\n    });\n    /******/\n\n    if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) {\n      return value[key];\n    }.bind(null, key));\n    /******/\n\n    return ns;\n    /******/\n  };\n  /******/\n\n  /******/\n  // getDefaultExport function for compatibility with non-harmony modules\n\n  /******/\n\n\n  __webpack_require__.n = function (module) {\n    /******/\n    var getter = module && module.__esModule ?\n    /******/\n    function getDefault() {\n      return module['default'];\n    } :\n    /******/\n    function getModuleExports() {\n      return module;\n    };\n    /******/\n\n    __webpack_require__.d(getter, 'a', getter);\n    /******/\n\n\n    return getter;\n    /******/\n  };\n  /******/\n\n  /******/\n  // Object.prototype.hasOwnProperty.call\n\n  /******/\n\n\n  __webpack_require__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  };\n  /******/\n\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n\n  __webpack_require__.p = \"/dist/\";\n  /******/\n\n  /******/\n\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(__webpack_require__.s = 60);\n  /******/\n}(\n/************************************************************************/\n\n/******/\n{\n  /***/\n  0:\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n    /* harmony export (binding) */\n\n    __webpack_require__.d(__webpack_exports__, \"a\", function () {\n      return normalizeComponent;\n    });\n    /* globals __VUE_SSR_CONTEXT__ */\n    // IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n    // This module is a runtime utility for cleaner component module output and will\n    // be included in the final webpack user bundle.\n\n\n    function normalizeComponent(scriptExports, render, staticRenderFns, functionalTemplate, injectStyles, scopeId, moduleIdentifier,\n    /* server only */\n    shadowMode\n    /* vue-cli only */\n    ) {\n      // Vue.extend constructor export interop\n      var options = typeof scriptExports === 'function' ? scriptExports.options : scriptExports; // render functions\n\n      if (render) {\n        options.render = render;\n        options.staticRenderFns = staticRenderFns;\n        options._compiled = true;\n      } // functional template\n\n\n      if (functionalTemplate) {\n        options.functional = true;\n      } // scopedId\n\n\n      if (scopeId) {\n        options._scopeId = 'data-v-' + scopeId;\n      }\n\n      var hook;\n\n      if (moduleIdentifier) {\n        // server build\n        hook = function (context) {\n          // 2.3 injection\n          context = context || // cached call\n          this.$vnode && this.$vnode.ssrContext || // stateful\n          this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext; // functional\n          // 2.2 with runInNewContext: true\n\n          if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n            context = __VUE_SSR_CONTEXT__;\n          } // inject component styles\n\n\n          if (injectStyles) {\n            injectStyles.call(this, context);\n          } // register component module identifier for async chunk inferrence\n\n\n          if (context && context._registeredComponents) {\n            context._registeredComponents.add(moduleIdentifier);\n          }\n        }; // used by ssr in case component is cached and beforeCreate\n        // never gets called\n\n\n        options._ssrRegister = hook;\n      } else if (injectStyles) {\n        hook = shadowMode ? function () {\n          injectStyles.call(this, this.$root.$options.shadowRoot);\n        } : injectStyles;\n      }\n\n      if (hook) {\n        if (options.functional) {\n          // for template-only hot-reload because in that case the render fn doesn't\n          // go through the normalizer\n          options._injectStyles = hook; // register for functioal component in vue file\n\n          var originalRender = options.render;\n\n          options.render = function renderWithStyleInjection(h, context) {\n            hook.call(context);\n            return originalRender(h, context);\n          };\n        } else {\n          // inject component registration as beforeCreate hook\n          var existing = options.beforeCreate;\n          options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\n        }\n      }\n\n      return {\n        exports: scriptExports,\n        options: options\n      };\n    }\n    /***/\n\n  },\n\n  /***/\n  16:\n  /***/\n  function (module, exports) {\n    module.exports = __webpack_require__(/*! element-ui/lib/utils/resize-event */ \"./node_modules/element-ui/lib/utils/resize-event.js\");\n    /***/\n  },\n\n  /***/\n  3:\n  /***/\n  function (module, exports) {\n    module.exports = __webpack_require__(/*! element-ui/lib/utils/util */ \"./node_modules/element-ui/lib/utils/util.js\");\n    /***/\n  },\n\n  /***/\n  60:\n  /***/\n  function (module, __webpack_exports__, __webpack_require__) {\n    \"use strict\";\n\n    __webpack_require__.r(__webpack_exports__); // CONCATENATED MODULE: ./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/vue-loader/lib??vue-loader-options!./packages/tabs/src/tab-bar.vue?vue&type=template&id=2031f33a&\n\n\n    var render = function () {\n      var _vm = this;\n\n      var _h = _vm.$createElement;\n\n      var _c = _vm._self._c || _h;\n\n      return _c(\"div\", {\n        staticClass: \"el-tabs__active-bar\",\n        class: \"is-\" + _vm.rootTabs.tabPosition,\n        style: _vm.barStyle\n      });\n    };\n\n    var staticRenderFns = [];\n    render._withStripped = true; // CONCATENATED MODULE: ./packages/tabs/src/tab-bar.vue?vue&type=template&id=2031f33a&\n    // EXTERNAL MODULE: external \"element-ui/lib/utils/util\"\n\n    var util_ = __webpack_require__(3); // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/tabs/src/tab-bar.vue?vue&type=script&lang=js&\n    //\n    //\n    //\n\n    /* harmony default export */\n\n\n    var tab_barvue_type_script_lang_js_ = {\n      name: 'TabBar',\n      props: {\n        tabs: Array\n      },\n      inject: ['rootTabs'],\n      computed: {\n        barStyle: {\n          get: function get() {\n            var _this = this;\n\n            var style = {};\n            var offset = 0;\n            var tabSize = 0;\n            var sizeName = ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1 ? 'width' : 'height';\n            var sizeDir = sizeName === 'width' ? 'x' : 'y';\n\n            var firstUpperCase = function firstUpperCase(str) {\n              return str.toLowerCase().replace(/( |^)[a-z]/g, function (L) {\n                return L.toUpperCase();\n              });\n            };\n\n            this.tabs.every(function (tab, index) {\n              var $el = Object(util_[\"arrayFind\"])(_this.$parent.$refs.tabs || [], function (t) {\n                return t.id.replace('tab-', '') === tab.paneName;\n              });\n\n              if (!$el) {\n                return false;\n              }\n\n              if (!tab.active) {\n                offset += $el['client' + firstUpperCase(sizeName)];\n                return true;\n              } else {\n                tabSize = $el['client' + firstUpperCase(sizeName)];\n                var tabStyles = window.getComputedStyle($el);\n\n                if (sizeName === 'width' && _this.tabs.length > 1) {\n                  tabSize -= parseFloat(tabStyles.paddingLeft) + parseFloat(tabStyles.paddingRight);\n                }\n\n                if (sizeName === 'width') {\n                  offset += parseFloat(tabStyles.paddingLeft);\n                }\n\n                return false;\n              }\n            });\n            var transform = 'translate' + firstUpperCase(sizeDir) + '(' + offset + 'px)';\n            style[sizeName] = tabSize + 'px';\n            style.transform = transform;\n            style.msTransform = transform;\n            style.webkitTransform = transform;\n            return style;\n          }\n        }\n      }\n    }; // CONCATENATED MODULE: ./packages/tabs/src/tab-bar.vue?vue&type=script&lang=js&\n\n    /* harmony default export */\n\n    var src_tab_barvue_type_script_lang_js_ = tab_barvue_type_script_lang_js_; // EXTERNAL MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js\n\n    var componentNormalizer = __webpack_require__(0); // CONCATENATED MODULE: ./packages/tabs/src/tab-bar.vue\n\n    /* normalize component */\n\n\n    var component = Object(componentNormalizer[\"a\"\n    /* default */\n    ])(src_tab_barvue_type_script_lang_js_, render, staticRenderFns, false, null, null, null);\n    /* hot reload */\n\n    if (false) { var api; }\n\n    component.options.__file = \"packages/tabs/src/tab-bar.vue\";\n    /* harmony default export */\n\n    var tab_bar = component.exports; // EXTERNAL MODULE: external \"element-ui/lib/utils/resize-event\"\n\n    var resize_event_ = __webpack_require__(16); // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/tabs/src/tab-nav.vue?vue&type=script&lang=js&\n\n\n    function noop() {}\n\n    var tab_navvue_type_script_lang_js_firstUpperCase = function firstUpperCase(str) {\n      return str.toLowerCase().replace(/( |^)[a-z]/g, function (L) {\n        return L.toUpperCase();\n      });\n    };\n    /* harmony default export */\n\n\n    var tab_navvue_type_script_lang_js_ = {\n      name: 'TabNav',\n      components: {\n        TabBar: tab_bar\n      },\n      inject: ['rootTabs'],\n      props: {\n        panes: Array,\n        currentName: String,\n        editable: Boolean,\n        onTabClick: {\n          type: Function,\n          default: noop\n        },\n        onTabRemove: {\n          type: Function,\n          default: noop\n        },\n        type: String,\n        stretch: Boolean\n      },\n      data: function data() {\n        return {\n          scrollable: false,\n          navOffset: 0,\n          isFocus: false,\n          focusable: true\n        };\n      },\n      computed: {\n        navStyle: function navStyle() {\n          var dir = ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1 ? 'X' : 'Y';\n          return {\n            transform: 'translate' + dir + '(-' + this.navOffset + 'px)'\n          };\n        },\n        sizeName: function sizeName() {\n          return ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1 ? 'width' : 'height';\n        }\n      },\n      methods: {\n        scrollPrev: function scrollPrev() {\n          var containerSize = this.$refs.navScroll['offset' + tab_navvue_type_script_lang_js_firstUpperCase(this.sizeName)];\n          var currentOffset = this.navOffset;\n          if (!currentOffset) return;\n          var newOffset = currentOffset > containerSize ? currentOffset - containerSize : 0;\n          this.navOffset = newOffset;\n        },\n        scrollNext: function scrollNext() {\n          var navSize = this.$refs.nav['offset' + tab_navvue_type_script_lang_js_firstUpperCase(this.sizeName)];\n          var containerSize = this.$refs.navScroll['offset' + tab_navvue_type_script_lang_js_firstUpperCase(this.sizeName)];\n          var currentOffset = this.navOffset;\n          if (navSize - currentOffset <= containerSize) return;\n          var newOffset = navSize - currentOffset > containerSize * 2 ? currentOffset + containerSize : navSize - containerSize;\n          this.navOffset = newOffset;\n        },\n        scrollToActiveTab: function scrollToActiveTab() {\n          if (!this.scrollable) return;\n          var nav = this.$refs.nav;\n          var activeTab = this.$el.querySelector('.is-active');\n          if (!activeTab) return;\n          var navScroll = this.$refs.navScroll;\n          var isHorizontal = ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1;\n          var activeTabBounding = activeTab.getBoundingClientRect();\n          var navScrollBounding = navScroll.getBoundingClientRect();\n          var maxOffset = isHorizontal ? nav.offsetWidth - navScrollBounding.width : nav.offsetHeight - navScrollBounding.height;\n          var currentOffset = this.navOffset;\n          var newOffset = currentOffset;\n\n          if (isHorizontal) {\n            if (activeTabBounding.left < navScrollBounding.left) {\n              newOffset = currentOffset - (navScrollBounding.left - activeTabBounding.left);\n            }\n\n            if (activeTabBounding.right > navScrollBounding.right) {\n              newOffset = currentOffset + activeTabBounding.right - navScrollBounding.right;\n            }\n          } else {\n            if (activeTabBounding.top < navScrollBounding.top) {\n              newOffset = currentOffset - (navScrollBounding.top - activeTabBounding.top);\n            }\n\n            if (activeTabBounding.bottom > navScrollBounding.bottom) {\n              newOffset = currentOffset + (activeTabBounding.bottom - navScrollBounding.bottom);\n            }\n          }\n\n          newOffset = Math.max(newOffset, 0);\n          this.navOffset = Math.min(newOffset, maxOffset);\n        },\n        update: function update() {\n          if (!this.$refs.nav) return;\n          var sizeName = this.sizeName;\n          var navSize = this.$refs.nav['offset' + tab_navvue_type_script_lang_js_firstUpperCase(sizeName)];\n          var containerSize = this.$refs.navScroll['offset' + tab_navvue_type_script_lang_js_firstUpperCase(sizeName)];\n          var currentOffset = this.navOffset;\n\n          if (containerSize < navSize) {\n            var _currentOffset = this.navOffset;\n            this.scrollable = this.scrollable || {};\n            this.scrollable.prev = _currentOffset;\n            this.scrollable.next = _currentOffset + containerSize < navSize;\n\n            if (navSize - _currentOffset < containerSize) {\n              this.navOffset = navSize - containerSize;\n            }\n          } else {\n            this.scrollable = false;\n\n            if (currentOffset > 0) {\n              this.navOffset = 0;\n            }\n          }\n        },\n        changeTab: function changeTab(e) {\n          var keyCode = e.keyCode;\n          var nextIndex = void 0;\n          var currentIndex = void 0,\n              tabList = void 0;\n\n          if ([37, 38, 39, 40].indexOf(keyCode) !== -1) {\n            // 左右上下键更换tab\n            tabList = e.currentTarget.querySelectorAll('[role=tab]');\n            currentIndex = Array.prototype.indexOf.call(tabList, e.target);\n          } else {\n            return;\n          }\n\n          if (keyCode === 37 || keyCode === 38) {\n            // left\n            if (currentIndex === 0) {\n              // first\n              nextIndex = tabList.length - 1;\n            } else {\n              nextIndex = currentIndex - 1;\n            }\n          } else {\n            // right\n            if (currentIndex < tabList.length - 1) {\n              // not last\n              nextIndex = currentIndex + 1;\n            } else {\n              nextIndex = 0;\n            }\n          }\n\n          tabList[nextIndex].focus(); // 改变焦点元素\n\n          tabList[nextIndex].click(); // 选中下一个tab\n\n          this.setFocus();\n        },\n        setFocus: function setFocus() {\n          if (this.focusable) {\n            this.isFocus = true;\n          }\n        },\n        removeFocus: function removeFocus() {\n          this.isFocus = false;\n        },\n        visibilityChangeHandler: function visibilityChangeHandler() {\n          var _this = this;\n\n          var visibility = document.visibilityState;\n\n          if (visibility === 'hidden') {\n            this.focusable = false;\n          } else if (visibility === 'visible') {\n            setTimeout(function () {\n              _this.focusable = true;\n            }, 50);\n          }\n        },\n        windowBlurHandler: function windowBlurHandler() {\n          this.focusable = false;\n        },\n        windowFocusHandler: function windowFocusHandler() {\n          var _this2 = this;\n\n          setTimeout(function () {\n            _this2.focusable = true;\n          }, 50);\n        }\n      },\n      updated: function updated() {\n        this.update();\n      },\n      render: function render(h) {\n        var _this3 = this;\n\n        var type = this.type,\n            panes = this.panes,\n            editable = this.editable,\n            stretch = this.stretch,\n            onTabClick = this.onTabClick,\n            onTabRemove = this.onTabRemove,\n            navStyle = this.navStyle,\n            scrollable = this.scrollable,\n            scrollNext = this.scrollNext,\n            scrollPrev = this.scrollPrev,\n            changeTab = this.changeTab,\n            setFocus = this.setFocus,\n            removeFocus = this.removeFocus;\n        var scrollBtn = scrollable ? [h('span', {\n          'class': ['el-tabs__nav-prev', scrollable.prev ? '' : 'is-disabled'],\n          on: {\n            'click': scrollPrev\n          }\n        }, [h('i', {\n          'class': 'el-icon-arrow-left'\n        })]), h('span', {\n          'class': ['el-tabs__nav-next', scrollable.next ? '' : 'is-disabled'],\n          on: {\n            'click': scrollNext\n          }\n        }, [h('i', {\n          'class': 'el-icon-arrow-right'\n        })])] : null;\n\n        var tabs = this._l(panes, function (pane, index) {\n          var _ref;\n\n          var tabName = pane.name || pane.index || index;\n          var closable = pane.isClosable || editable;\n          pane.index = '' + index;\n          var btnClose = closable ? h('span', {\n            'class': 'el-icon-close',\n            on: {\n              'click': function click(ev) {\n                onTabRemove(pane, ev);\n              }\n            }\n          }) : null;\n          var tabLabelContent = pane.$slots.label || pane.label;\n          var tabindex = pane.active ? 0 : -1;\n          return h('div', {\n            'class': (_ref = {\n              'el-tabs__item': true\n            }, _ref['is-' + _this3.rootTabs.tabPosition] = true, _ref['is-active'] = pane.active, _ref['is-disabled'] = pane.disabled, _ref['is-closable'] = closable, _ref['is-focus'] = _this3.isFocus, _ref),\n            attrs: {\n              id: 'tab-' + tabName,\n              'aria-controls': 'pane-' + tabName,\n              role: 'tab',\n              'aria-selected': pane.active,\n              tabindex: tabindex\n            },\n            key: 'tab-' + tabName,\n            ref: 'tabs',\n            refInFor: true,\n            on: {\n              'focus': function focus() {\n                setFocus();\n              },\n              'blur': function blur() {\n                removeFocus();\n              },\n              'click': function click(ev) {\n                removeFocus();\n                onTabClick(pane, tabName, ev);\n              },\n              'keydown': function keydown(ev) {\n                if (closable && (ev.keyCode === 46 || ev.keyCode === 8)) {\n                  onTabRemove(pane, ev);\n                }\n              }\n            }\n          }, [tabLabelContent, btnClose]);\n        });\n\n        return h('div', {\n          'class': ['el-tabs__nav-wrap', scrollable ? 'is-scrollable' : '', 'is-' + this.rootTabs.tabPosition]\n        }, [scrollBtn, h('div', {\n          'class': ['el-tabs__nav-scroll'],\n          ref: 'navScroll'\n        }, [h('div', {\n          'class': ['el-tabs__nav', 'is-' + this.rootTabs.tabPosition, stretch && ['top', 'bottom'].indexOf(this.rootTabs.tabPosition) !== -1 ? 'is-stretch' : ''],\n          ref: 'nav',\n          style: navStyle,\n          attrs: {\n            role: 'tablist'\n          },\n          on: {\n            'keydown': changeTab\n          }\n        }, [!type ? h('tab-bar', {\n          attrs: {\n            tabs: panes\n          }\n        }) : null, tabs])])]);\n      },\n      mounted: function mounted() {\n        var _this4 = this;\n\n        Object(resize_event_[\"addResizeListener\"])(this.$el, this.update);\n        document.addEventListener('visibilitychange', this.visibilityChangeHandler);\n        window.addEventListener('blur', this.windowBlurHandler);\n        window.addEventListener('focus', this.windowFocusHandler);\n        setTimeout(function () {\n          _this4.scrollToActiveTab();\n        }, 0);\n      },\n      beforeDestroy: function beforeDestroy() {\n        if (this.$el && this.update) Object(resize_event_[\"removeResizeListener\"])(this.$el, this.update);\n        document.removeEventListener('visibilitychange', this.visibilityChangeHandler);\n        window.removeEventListener('blur', this.windowBlurHandler);\n        window.removeEventListener('focus', this.windowFocusHandler);\n      }\n    }; // CONCATENATED MODULE: ./packages/tabs/src/tab-nav.vue?vue&type=script&lang=js&\n\n    /* harmony default export */\n\n    var src_tab_navvue_type_script_lang_js_ = tab_navvue_type_script_lang_js_; // CONCATENATED MODULE: ./packages/tabs/src/tab-nav.vue\n\n    var tab_nav_render, tab_nav_staticRenderFns;\n    /* normalize component */\n\n    var tab_nav_component = Object(componentNormalizer[\"a\"\n    /* default */\n    ])(src_tab_navvue_type_script_lang_js_, tab_nav_render, tab_nav_staticRenderFns, false, null, null, null);\n    /* hot reload */\n\n    if (false) { var tab_nav_api; }\n\n    tab_nav_component.options.__file = \"packages/tabs/src/tab-nav.vue\";\n    /* harmony default export */\n\n    var tab_nav = tab_nav_component.exports; // CONCATENATED MODULE: ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib??vue-loader-options!./packages/tabs/src/tabs.vue?vue&type=script&lang=js&\n\n    /* harmony default export */\n\n    var tabsvue_type_script_lang_js_ = {\n      name: 'ElTabs',\n      components: {\n        TabNav: tab_nav\n      },\n      props: {\n        type: String,\n        activeName: String,\n        closable: Boolean,\n        addable: Boolean,\n        value: {},\n        editable: Boolean,\n        tabPosition: {\n          type: String,\n          default: 'top'\n        },\n        beforeLeave: Function,\n        stretch: Boolean\n      },\n      provide: function provide() {\n        return {\n          rootTabs: this\n        };\n      },\n      data: function data() {\n        return {\n          currentName: this.value || this.activeName,\n          panes: []\n        };\n      },\n      watch: {\n        activeName: function activeName(value) {\n          this.setCurrentName(value);\n        },\n        value: function value(_value) {\n          this.setCurrentName(_value);\n        },\n        currentName: function currentName(value) {\n          var _this = this;\n\n          if (this.$refs.nav) {\n            this.$nextTick(function () {\n              _this.$refs.nav.$nextTick(function (_) {\n                _this.$refs.nav.scrollToActiveTab();\n              });\n            });\n          }\n        }\n      },\n      methods: {\n        calcPaneInstances: function calcPaneInstances() {\n          var _this2 = this;\n\n          var isForceUpdate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n          if (this.$slots.default) {\n            var paneSlots = this.$slots.default.filter(function (vnode) {\n              return vnode.tag && vnode.componentOptions && vnode.componentOptions.Ctor.options.name === 'ElTabPane';\n            }); // update indeed\n\n            var panes = paneSlots.map(function (_ref) {\n              var componentInstance = _ref.componentInstance;\n              return componentInstance;\n            });\n            var panesChanged = !(panes.length === this.panes.length && panes.every(function (pane, index) {\n              return pane === _this2.panes[index];\n            }));\n\n            if (isForceUpdate || panesChanged) {\n              this.panes = panes;\n            }\n          } else if (this.panes.length !== 0) {\n            this.panes = [];\n          }\n        },\n        handleTabClick: function handleTabClick(tab, tabName, event) {\n          if (tab.disabled) return;\n          this.setCurrentName(tabName);\n          this.$emit('tab-click', tab, event);\n        },\n        handleTabRemove: function handleTabRemove(pane, ev) {\n          if (pane.disabled) return;\n          ev.stopPropagation();\n          this.$emit('edit', pane.name, 'remove');\n          this.$emit('tab-remove', pane.name);\n        },\n        handleTabAdd: function handleTabAdd() {\n          this.$emit('edit', null, 'add');\n          this.$emit('tab-add');\n        },\n        setCurrentName: function setCurrentName(value) {\n          var _this3 = this;\n\n          var changeCurrentName = function changeCurrentName() {\n            _this3.currentName = value;\n\n            _this3.$emit('input', value);\n          };\n\n          if (this.currentName !== value && this.beforeLeave) {\n            var before = this.beforeLeave(value, this.currentName);\n\n            if (before && before.then) {\n              before.then(function () {\n                changeCurrentName();\n                _this3.$refs.nav && _this3.$refs.nav.removeFocus();\n              }, function () {// https://github.com/ElemeFE/element/pull/14816\n                // ignore promise rejection in `before-leave` hook\n              });\n            } else if (before !== false) {\n              changeCurrentName();\n            }\n          } else {\n            changeCurrentName();\n          }\n        }\n      },\n      render: function render(h) {\n        var _ref2;\n\n        var type = this.type,\n            handleTabClick = this.handleTabClick,\n            handleTabRemove = this.handleTabRemove,\n            handleTabAdd = this.handleTabAdd,\n            currentName = this.currentName,\n            panes = this.panes,\n            editable = this.editable,\n            addable = this.addable,\n            tabPosition = this.tabPosition,\n            stretch = this.stretch;\n        var newButton = editable || addable ? h('span', {\n          'class': 'el-tabs__new-tab',\n          on: {\n            'click': handleTabAdd,\n            'keydown': function keydown(ev) {\n              if (ev.keyCode === 13) {\n                handleTabAdd();\n              }\n            }\n          },\n          attrs: {\n            tabindex: '0'\n          }\n        }, [h('i', {\n          'class': 'el-icon-plus'\n        })]) : null;\n        var navData = {\n          props: {\n            currentName: currentName,\n            onTabClick: handleTabClick,\n            onTabRemove: handleTabRemove,\n            editable: editable,\n            type: type,\n            panes: panes,\n            stretch: stretch\n          },\n          ref: 'nav'\n        };\n        var header = h('div', {\n          'class': ['el-tabs__header', 'is-' + tabPosition]\n        }, [newButton, h('tab-nav', navData)]);\n        var panels = h('div', {\n          'class': 'el-tabs__content'\n        }, [this.$slots.default]);\n        return h('div', {\n          'class': (_ref2 = {\n            'el-tabs': true,\n            'el-tabs--card': type === 'card'\n          }, _ref2['el-tabs--' + tabPosition] = true, _ref2['el-tabs--border-card'] = type === 'border-card', _ref2)\n        }, [tabPosition !== 'bottom' ? [header, panels] : [panels, header]]);\n      },\n      created: function created() {\n        if (!this.currentName) {\n          this.setCurrentName('0');\n        }\n\n        this.$on('tab-nav-update', this.calcPaneInstances.bind(null, true));\n      },\n      mounted: function mounted() {\n        this.calcPaneInstances();\n      },\n      updated: function updated() {\n        this.calcPaneInstances();\n      }\n    }; // CONCATENATED MODULE: ./packages/tabs/src/tabs.vue?vue&type=script&lang=js&\n\n    /* harmony default export */\n\n    var src_tabsvue_type_script_lang_js_ = tabsvue_type_script_lang_js_; // CONCATENATED MODULE: ./packages/tabs/src/tabs.vue\n\n    var tabs_render, tabs_staticRenderFns;\n    /* normalize component */\n\n    var tabs_component = Object(componentNormalizer[\"a\"\n    /* default */\n    ])(src_tabsvue_type_script_lang_js_, tabs_render, tabs_staticRenderFns, false, null, null, null);\n    /* hot reload */\n\n    if (false) { var tabs_api; }\n\n    tabs_component.options.__file = \"packages/tabs/src/tabs.vue\";\n    /* harmony default export */\n\n    var tabs = tabs_component.exports; // CONCATENATED MODULE: ./packages/tabs/index.js\n\n    /* istanbul ignore next */\n\n    tabs.install = function (Vue) {\n      Vue.component(tabs.name, tabs);\n    };\n    /* harmony default export */\n\n\n    var packages_tabs = __webpack_exports__[\"default\"] = tabs;\n    /***/\n  }\n  /******/\n\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdGFicy5qcz83MmFhIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJtb2R1bGVzIiwiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImkiLCJsIiwiY2FsbCIsIm0iLCJjIiwiZCIsIm5hbWUiLCJnZXR0ZXIiLCJvIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiciIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwidmFsdWUiLCJ0IiwibW9kZSIsIl9fZXNNb2R1bGUiLCJucyIsImNyZWF0ZSIsImtleSIsImJpbmQiLCJuIiwiZ2V0RGVmYXVsdCIsImdldE1vZHVsZUV4cG9ydHMiLCJvYmplY3QiLCJwcm9wZXJ0eSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwicCIsInMiLCJfX3dlYnBhY2tfZXhwb3J0c19fIiwibm9ybWFsaXplQ29tcG9uZW50Iiwic2NyaXB0RXhwb3J0cyIsInJlbmRlciIsInN0YXRpY1JlbmRlckZucyIsImZ1bmN0aW9uYWxUZW1wbGF0ZSIsImluamVjdFN0eWxlcyIsInNjb3BlSWQiLCJtb2R1bGVJZGVudGlmaWVyIiwic2hhZG93TW9kZSIsIm9wdGlvbnMiLCJfY29tcGlsZWQiLCJmdW5jdGlvbmFsIiwiX3Njb3BlSWQiLCJob29rIiwiY29udGV4dCIsIiR2bm9kZSIsInNzckNvbnRleHQiLCJwYXJlbnQiLCJfX1ZVRV9TU1JfQ09OVEVYVF9fIiwiX3JlZ2lzdGVyZWRDb21wb25lbnRzIiwiYWRkIiwiX3NzclJlZ2lzdGVyIiwiJHJvb3QiLCIkb3B0aW9ucyIsInNoYWRvd1Jvb3QiLCJfaW5qZWN0U3R5bGVzIiwib3JpZ2luYWxSZW5kZXIiLCJyZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24iLCJoIiwiZXhpc3RpbmciLCJiZWZvcmVDcmVhdGUiLCJjb25jYXQiLCJyZXF1aXJlIiwiX3ZtIiwiX2giLCIkY3JlYXRlRWxlbWVudCIsIl9jIiwiX3NlbGYiLCJzdGF0aWNDbGFzcyIsImNsYXNzIiwicm9vdFRhYnMiLCJ0YWJQb3NpdGlvbiIsInN0eWxlIiwiYmFyU3R5bGUiLCJfd2l0aFN0cmlwcGVkIiwidXRpbF8iLCJ0YWJfYmFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfIiwicHJvcHMiLCJ0YWJzIiwiQXJyYXkiLCJpbmplY3QiLCJjb21wdXRlZCIsIl90aGlzIiwib2Zmc2V0IiwidGFiU2l6ZSIsInNpemVOYW1lIiwiaW5kZXhPZiIsInNpemVEaXIiLCJmaXJzdFVwcGVyQ2FzZSIsInN0ciIsInRvTG93ZXJDYXNlIiwicmVwbGFjZSIsIkwiLCJ0b1VwcGVyQ2FzZSIsImV2ZXJ5IiwidGFiIiwiaW5kZXgiLCIkZWwiLCIkcGFyZW50IiwiJHJlZnMiLCJpZCIsInBhbmVOYW1lIiwiYWN0aXZlIiwidGFiU3R5bGVzIiwid2luZG93IiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImxlbmd0aCIsInBhcnNlRmxvYXQiLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsInRyYW5zZm9ybSIsIm1zVHJhbnNmb3JtIiwid2Via2l0VHJhbnNmb3JtIiwic3JjX3RhYl9iYXJ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18iLCJjb21wb25lbnROb3JtYWxpemVyIiwiY29tcG9uZW50IiwiX19maWxlIiwidGFiX2JhciIsInJlc2l6ZV9ldmVudF8iLCJub29wIiwidGFiX25hdnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2ZpcnN0VXBwZXJDYXNlIiwidGFiX25hdnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyIsImNvbXBvbmVudHMiLCJUYWJCYXIiLCJwYW5lcyIsImN1cnJlbnROYW1lIiwiU3RyaW5nIiwiZWRpdGFibGUiLCJCb29sZWFuIiwib25UYWJDbGljayIsInR5cGUiLCJGdW5jdGlvbiIsImRlZmF1bHQiLCJvblRhYlJlbW92ZSIsInN0cmV0Y2giLCJkYXRhIiwic2Nyb2xsYWJsZSIsIm5hdk9mZnNldCIsImlzRm9jdXMiLCJmb2N1c2FibGUiLCJuYXZTdHlsZSIsImRpciIsIm1ldGhvZHMiLCJzY3JvbGxQcmV2IiwiY29udGFpbmVyU2l6ZSIsIm5hdlNjcm9sbCIsImN1cnJlbnRPZmZzZXQiLCJuZXdPZmZzZXQiLCJzY3JvbGxOZXh0IiwibmF2U2l6ZSIsIm5hdiIsInNjcm9sbFRvQWN0aXZlVGFiIiwiYWN0aXZlVGFiIiwicXVlcnlTZWxlY3RvciIsImlzSG9yaXpvbnRhbCIsImFjdGl2ZVRhYkJvdW5kaW5nIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwibmF2U2Nyb2xsQm91bmRpbmciLCJtYXhPZmZzZXQiLCJvZmZzZXRXaWR0aCIsIndpZHRoIiwib2Zmc2V0SGVpZ2h0IiwiaGVpZ2h0IiwibGVmdCIsInJpZ2h0IiwidG9wIiwiYm90dG9tIiwiTWF0aCIsIm1heCIsIm1pbiIsInVwZGF0ZSIsIl9jdXJyZW50T2Zmc2V0IiwicHJldiIsIm5leHQiLCJjaGFuZ2VUYWIiLCJlIiwia2V5Q29kZSIsIm5leHRJbmRleCIsImN1cnJlbnRJbmRleCIsInRhYkxpc3QiLCJjdXJyZW50VGFyZ2V0IiwicXVlcnlTZWxlY3RvckFsbCIsInRhcmdldCIsImZvY3VzIiwiY2xpY2siLCJzZXRGb2N1cyIsInJlbW92ZUZvY3VzIiwidmlzaWJpbGl0eUNoYW5nZUhhbmRsZXIiLCJ2aXNpYmlsaXR5IiwiZG9jdW1lbnQiLCJ2aXNpYmlsaXR5U3RhdGUiLCJzZXRUaW1lb3V0Iiwid2luZG93Qmx1ckhhbmRsZXIiLCJ3aW5kb3dGb2N1c0hhbmRsZXIiLCJfdGhpczIiLCJ1cGRhdGVkIiwiX3RoaXMzIiwic2Nyb2xsQnRuIiwib24iLCJfbCIsInBhbmUiLCJfcmVmIiwidGFiTmFtZSIsImNsb3NhYmxlIiwiaXNDbG9zYWJsZSIsImJ0bkNsb3NlIiwiZXYiLCJ0YWJMYWJlbENvbnRlbnQiLCIkc2xvdHMiLCJsYWJlbCIsInRhYmluZGV4IiwiZGlzYWJsZWQiLCJhdHRycyIsInJvbGUiLCJyZWYiLCJyZWZJbkZvciIsImJsdXIiLCJrZXlkb3duIiwibW91bnRlZCIsIl90aGlzNCIsImFkZEV2ZW50TGlzdGVuZXIiLCJiZWZvcmVEZXN0cm95IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInNyY190YWJfbmF2dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfIiwidGFiX25hdl9yZW5kZXIiLCJ0YWJfbmF2X3N0YXRpY1JlbmRlckZucyIsInRhYl9uYXZfY29tcG9uZW50IiwidGFiX25hdiIsInRhYnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18iLCJUYWJOYXYiLCJhY3RpdmVOYW1lIiwiYWRkYWJsZSIsImJlZm9yZUxlYXZlIiwicHJvdmlkZSIsIndhdGNoIiwic2V0Q3VycmVudE5hbWUiLCJfdmFsdWUiLCIkbmV4dFRpY2siLCJfIiwiY2FsY1BhbmVJbnN0YW5jZXMiLCJpc0ZvcmNlVXBkYXRlIiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwicGFuZVNsb3RzIiwiZmlsdGVyIiwidm5vZGUiLCJ0YWciLCJjb21wb25lbnRPcHRpb25zIiwiQ3RvciIsIm1hcCIsImNvbXBvbmVudEluc3RhbmNlIiwicGFuZXNDaGFuZ2VkIiwiaGFuZGxlVGFiQ2xpY2siLCJldmVudCIsIiRlbWl0IiwiaGFuZGxlVGFiUmVtb3ZlIiwic3RvcFByb3BhZ2F0aW9uIiwiaGFuZGxlVGFiQWRkIiwiY2hhbmdlQ3VycmVudE5hbWUiLCJiZWZvcmUiLCJ0aGVuIiwiX3JlZjIiLCJuZXdCdXR0b24iLCJuYXZEYXRhIiwiaGVhZGVyIiwicGFuZWxzIiwiY3JlYXRlZCIsIiRvbiIsInNyY190YWJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfIiwidGFic19yZW5kZXIiLCJ0YWJzX3N0YXRpY1JlbmRlckZucyIsInRhYnNfY29tcG9uZW50IiwiaW5zdGFsbCIsIlZ1ZSIsInBhY2thZ2VzX3RhYnMiXSwibWFwcGluZ3MiOiJBQUFBQSxNQUFNLENBQUNDLE9BQVA7QUFDQTtBQUFVLFVBQVNDLE9BQVQsRUFBa0I7QUFBRTs7QUFDOUI7QUFBVTs7QUFDVjtB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bGUiOiIuL25vZGVfbW9kdWxlcy9lbGVtZW50LXVpL2xpYi90YWJzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPVxuLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIi9kaXN0L1wiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA2MCk7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovICh7XG5cbi8qKiovIDA6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcImFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBub3JtYWxpemVDb21wb25lbnQ7IH0pO1xuLyogZ2xvYmFscyBfX1ZVRV9TU1JfQ09OVEVYVF9fICovXG5cbi8vIElNUE9SVEFOVDogRG8gTk9UIHVzZSBFUzIwMTUgZmVhdHVyZXMgaW4gdGhpcyBmaWxlIChleGNlcHQgZm9yIG1vZHVsZXMpLlxuLy8gVGhpcyBtb2R1bGUgaXMgYSBydW50aW1lIHV0aWxpdHkgZm9yIGNsZWFuZXIgY29tcG9uZW50IG1vZHVsZSBvdXRwdXQgYW5kIHdpbGxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlLlxuXG5mdW5jdGlvbiBub3JtYWxpemVDb21wb25lbnQgKFxuICBzY3JpcHRFeHBvcnRzLFxuICByZW5kZXIsXG4gIHN0YXRpY1JlbmRlckZucyxcbiAgZnVuY3Rpb25hbFRlbXBsYXRlLFxuICBpbmplY3RTdHlsZXMsXG4gIHNjb3BlSWQsXG4gIG1vZHVsZUlkZW50aWZpZXIsIC8qIHNlcnZlciBvbmx5ICovXG4gIHNoYWRvd01vZGUgLyogdnVlLWNsaSBvbmx5ICovXG4pIHtcbiAgLy8gVnVlLmV4dGVuZCBjb25zdHJ1Y3RvciBleHBvcnQgaW50ZXJvcFxuICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzY3JpcHRFeHBvcnRzID09PSAnZnVuY3Rpb24nXG4gICAgPyBzY3JpcHRFeHBvcnRzLm9wdGlvbnNcbiAgICA6IHNjcmlwdEV4cG9ydHNcblxuICAvLyByZW5kZXIgZnVuY3Rpb25zXG4gIGlmIChyZW5kZXIpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IHJlbmRlclxuICAgIG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zID0gc3RhdGljUmVuZGVyRm5zXG4gICAgb3B0aW9ucy5fY29tcGlsZWQgPSB0cnVlXG4gIH1cblxuICAvLyBmdW5jdGlvbmFsIHRlbXBsYXRlXG4gIGlmIChmdW5jdGlvbmFsVGVtcGxhdGUpIHtcbiAgICBvcHRpb25zLmZ1bmN0aW9uYWwgPSB0cnVlXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSAnZGF0YS12LScgKyBzY29wZUlkXG4gIH1cblxuICB2YXIgaG9va1xuICBpZiAobW9kdWxlSWRlbnRpZmllcikgeyAvLyBzZXJ2ZXIgYnVpbGRcbiAgICBob29rID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIC8vIDIuMyBpbmplY3Rpb25cbiAgICAgIGNvbnRleHQgPVxuICAgICAgICBjb250ZXh0IHx8IC8vIGNhY2hlZCBjYWxsXG4gICAgICAgICh0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0KSB8fCAvLyBzdGF0ZWZ1bFxuICAgICAgICAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuJHZub2RlICYmIHRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0KSAvLyBmdW5jdGlvbmFsXG4gICAgICAvLyAyLjIgd2l0aCBydW5Jbk5ld0NvbnRleHQ6IHRydWVcbiAgICAgIGlmICghY29udGV4dCAmJiB0eXBlb2YgX19WVUVfU1NSX0NPTlRFWFRfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29udGV4dCA9IF9fVlVFX1NTUl9DT05URVhUX19cbiAgICAgIH1cbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgc3R5bGVzXG4gICAgICBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIGNvbnRleHQpXG4gICAgICB9XG4gICAgICAvLyByZWdpc3RlciBjb21wb25lbnQgbW9kdWxlIGlkZW50aWZpZXIgZm9yIGFzeW5jIGNodW5rIGluZmVycmVuY2VcbiAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzLmFkZChtb2R1bGVJZGVudGlmaWVyKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1c2VkIGJ5IHNzciBpbiBjYXNlIGNvbXBvbmVudCBpcyBjYWNoZWQgYW5kIGJlZm9yZUNyZWF0ZVxuICAgIC8vIG5ldmVyIGdldHMgY2FsbGVkXG4gICAgb3B0aW9ucy5fc3NyUmVnaXN0ZXIgPSBob29rXG4gIH0gZWxzZSBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgaG9vayA9IHNoYWRvd01vZGVcbiAgICAgID8gZnVuY3Rpb24gKCkgeyBpbmplY3RTdHlsZXMuY2FsbCh0aGlzLCB0aGlzLiRyb290LiRvcHRpb25zLnNoYWRvd1Jvb3QpIH1cbiAgICAgIDogaW5qZWN0U3R5bGVzXG4gIH1cblxuICBpZiAoaG9vaykge1xuICAgIGlmIChvcHRpb25zLmZ1bmN0aW9uYWwpIHtcbiAgICAgIC8vIGZvciB0ZW1wbGF0ZS1vbmx5IGhvdC1yZWxvYWQgYmVjYXVzZSBpbiB0aGF0IGNhc2UgdGhlIHJlbmRlciBmbiBkb2Vzbid0XG4gICAgICAvLyBnbyB0aHJvdWdoIHRoZSBub3JtYWxpemVyXG4gICAgICBvcHRpb25zLl9pbmplY3RTdHlsZXMgPSBob29rXG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb2FsIGNvbXBvbmVudCBpbiB2dWUgZmlsZVxuICAgICAgdmFyIG9yaWdpbmFsUmVuZGVyID0gb3B0aW9ucy5yZW5kZXJcbiAgICAgIG9wdGlvbnMucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyV2l0aFN0eWxlSW5qZWN0aW9uIChoLCBjb250ZXh0KSB7XG4gICAgICAgIGhvb2suY2FsbChjb250ZXh0KVxuICAgICAgICByZXR1cm4gb3JpZ2luYWxSZW5kZXIoaCwgY29udGV4dClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCByZWdpc3RyYXRpb24gYXMgYmVmb3JlQ3JlYXRlIGhvb2tcbiAgICAgIHZhciBleGlzdGluZyA9IG9wdGlvbnMuYmVmb3JlQ3JlYXRlXG4gICAgICBvcHRpb25zLmJlZm9yZUNyZWF0ZSA9IGV4aXN0aW5nXG4gICAgICAgID8gW10uY29uY2F0KGV4aXN0aW5nLCBob29rKVxuICAgICAgICA6IFtob29rXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXhwb3J0czogc2NyaXB0RXhwb3J0cyxcbiAgICBvcHRpb25zOiBvcHRpb25zXG4gIH1cbn1cblxuXG4vKioqLyB9KSxcblxuLyoqKi8gMTY6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImVsZW1lbnQtdWkvbGliL3V0aWxzL3Jlc2l6ZS1ldmVudFwiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIDM6XG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcImVsZW1lbnQtdWkvbGliL3V0aWxzL3V0aWxcIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyA2MDpcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2xvYWRlcnMvdGVtcGxhdGVMb2FkZXIuanM/P3Z1ZS1sb2FkZXItb3B0aW9ucyEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vcGFja2FnZXMvdGFicy9zcmMvdGFiLWJhci52dWU/dnVlJnR5cGU9dGVtcGxhdGUmaWQ9MjAzMWYzM2EmXG52YXIgcmVuZGVyID0gZnVuY3Rpb24oKSB7XG4gIHZhciBfdm0gPSB0aGlzXG4gIHZhciBfaCA9IF92bS4kY3JlYXRlRWxlbWVudFxuICB2YXIgX2MgPSBfdm0uX3NlbGYuX2MgfHwgX2hcbiAgcmV0dXJuIF9jKFwiZGl2XCIsIHtcbiAgICBzdGF0aWNDbGFzczogXCJlbC10YWJzX19hY3RpdmUtYmFyXCIsXG4gICAgY2xhc3M6IFwiaXMtXCIgKyBfdm0ucm9vdFRhYnMudGFiUG9zaXRpb24sXG4gICAgc3R5bGU6IF92bS5iYXJTdHlsZVxuICB9KVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcblxuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL3RhYnMvc3JjL3RhYi1iYXIudnVlP3Z1ZSZ0eXBlPXRlbXBsYXRlJmlkPTIwMzFmMzNhJlxuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IGV4dGVybmFsIFwiZWxlbWVudC11aS9saWIvdXRpbHMvdXRpbFwiXG52YXIgdXRpbF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9wYWNrYWdlcy90YWJzL3NyYy90YWItYmFyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbi8vXG4vL1xuLy9cblxuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0YWJfYmFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHtcbiAgbmFtZTogJ1RhYkJhcicsXG5cbiAgcHJvcHM6IHtcbiAgICB0YWJzOiBBcnJheVxuICB9LFxuXG4gIGluamVjdDogWydyb290VGFicyddLFxuXG4gIGNvbXB1dGVkOiB7XG4gICAgYmFyU3R5bGU6IHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICAgIHZhciBzdHlsZSA9IHt9O1xuICAgICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIHRhYlNpemUgPSAwO1xuICAgICAgICB2YXIgc2l6ZU5hbWUgPSBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHRoaXMucm9vdFRhYnMudGFiUG9zaXRpb24pICE9PSAtMSA/ICd3aWR0aCcgOiAnaGVpZ2h0JztcbiAgICAgICAgdmFyIHNpemVEaXIgPSBzaXplTmFtZSA9PT0gJ3dpZHRoJyA/ICd4JyA6ICd5JztcbiAgICAgICAgdmFyIGZpcnN0VXBwZXJDYXNlID0gZnVuY3Rpb24gZmlyc3RVcHBlckNhc2Uoc3RyKSB7XG4gICAgICAgICAgcmV0dXJuIHN0ci50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoLyggfF4pW2Etel0vZywgZnVuY3Rpb24gKEwpIHtcbiAgICAgICAgICAgIHJldHVybiBMLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudGFicy5ldmVyeShmdW5jdGlvbiAodGFiLCBpbmRleCkge1xuICAgICAgICAgIHZhciAkZWwgPSBPYmplY3QodXRpbF9bXCJhcnJheUZpbmRcIl0pKF90aGlzLiRwYXJlbnQuJHJlZnMudGFicyB8fCBbXSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0LmlkLnJlcGxhY2UoJ3RhYi0nLCAnJykgPT09IHRhYi5wYW5lTmFtZTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoISRlbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICghdGFiLmFjdGl2ZSkge1xuICAgICAgICAgICAgb2Zmc2V0ICs9ICRlbFsnY2xpZW50JyArIGZpcnN0VXBwZXJDYXNlKHNpemVOYW1lKV07XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGFiU2l6ZSA9ICRlbFsnY2xpZW50JyArIGZpcnN0VXBwZXJDYXNlKHNpemVOYW1lKV07XG4gICAgICAgICAgICB2YXIgdGFiU3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoJGVsKTtcbiAgICAgICAgICAgIGlmIChzaXplTmFtZSA9PT0gJ3dpZHRoJyAmJiBfdGhpcy50YWJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgdGFiU2l6ZSAtPSBwYXJzZUZsb2F0KHRhYlN0eWxlcy5wYWRkaW5nTGVmdCkgKyBwYXJzZUZsb2F0KHRhYlN0eWxlcy5wYWRkaW5nUmlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNpemVOYW1lID09PSAnd2lkdGgnKSB7XG4gICAgICAgICAgICAgIG9mZnNldCArPSBwYXJzZUZsb2F0KHRhYlN0eWxlcy5wYWRkaW5nTGVmdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdHJhbnNmb3JtID0gJ3RyYW5zbGF0ZScgKyBmaXJzdFVwcGVyQ2FzZShzaXplRGlyKSArICcoJyArIG9mZnNldCArICdweCknO1xuICAgICAgICBzdHlsZVtzaXplTmFtZV0gPSB0YWJTaXplICsgJ3B4JztcbiAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgICAgICBzdHlsZS5tc1RyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICAgICAgc3R5bGUud2Via2l0VHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuXG4gICAgICAgIHJldHVybiBzdHlsZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy90YWJzL3NyYy90YWItYmFyLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfdGFiX2JhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh0YWJfYmFydnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3J1bnRpbWUvY29tcG9uZW50Tm9ybWFsaXplci5qc1xudmFyIGNvbXBvbmVudE5vcm1hbGl6ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL3RhYnMvc3JjL3RhYi1iYXIudnVlXG5cblxuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgY29tcG9uZW50ID0gT2JqZWN0KGNvbXBvbmVudE5vcm1hbGl6ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pKFxuICBzcmNfdGFiX2JhcnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgcmVuZGVyLFxuICBzdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIGFwaTsgfVxuY29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJwYWNrYWdlcy90YWJzL3NyYy90YWItYmFyLnZ1ZVwiXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB0YWJfYmFyID0gKGNvbXBvbmVudC5leHBvcnRzKTtcbi8vIEVYVEVSTkFMIE1PRFVMRTogZXh0ZXJuYWwgXCJlbGVtZW50LXVpL2xpYi91dGlscy9yZXNpemUtZXZlbnRcIlxudmFyIHJlc2l6ZV9ldmVudF8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvYmFiZWwtbG9hZGVyL2xpYiEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYj8/dnVlLWxvYWRlci1vcHRpb25zIS4vcGFja2FnZXMvdGFicy9zcmMvdGFiLW5hdi52dWU/dnVlJnR5cGU9c2NyaXB0Jmxhbmc9anMmXG5cblxuXG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxudmFyIHRhYl9uYXZ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19maXJzdFVwcGVyQ2FzZSA9IGZ1bmN0aW9uIGZpcnN0VXBwZXJDYXNlKHN0cikge1xuICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvKCB8XilbYS16XS9nLCBmdW5jdGlvbiAoTCkge1xuICAgIHJldHVybiBMLnRvVXBwZXJDYXNlKCk7XG4gIH0pO1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdGFiX25hdnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh7XG4gIG5hbWU6ICdUYWJOYXYnLFxuXG4gIGNvbXBvbmVudHM6IHtcbiAgICBUYWJCYXI6IHRhYl9iYXJcbiAgfSxcblxuICBpbmplY3Q6IFsncm9vdFRhYnMnXSxcblxuICBwcm9wczoge1xuICAgIHBhbmVzOiBBcnJheSxcbiAgICBjdXJyZW50TmFtZTogU3RyaW5nLFxuICAgIGVkaXRhYmxlOiBCb29sZWFuLFxuICAgIG9uVGFiQ2xpY2s6IHtcbiAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgZGVmYXVsdDogbm9vcFxuICAgIH0sXG4gICAgb25UYWJSZW1vdmU6IHtcbiAgICAgIHR5cGU6IEZ1bmN0aW9uLFxuICAgICAgZGVmYXVsdDogbm9vcFxuICAgIH0sXG4gICAgdHlwZTogU3RyaW5nLFxuICAgIHN0cmV0Y2g6IEJvb2xlYW5cbiAgfSxcblxuICBkYXRhOiBmdW5jdGlvbiBkYXRhKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzY3JvbGxhYmxlOiBmYWxzZSxcbiAgICAgIG5hdk9mZnNldDogMCxcbiAgICAgIGlzRm9jdXM6IGZhbHNlLFxuICAgICAgZm9jdXNhYmxlOiB0cnVlXG4gICAgfTtcbiAgfSxcblxuXG4gIGNvbXB1dGVkOiB7XG4gICAgbmF2U3R5bGU6IGZ1bmN0aW9uIG5hdlN0eWxlKCkge1xuICAgICAgdmFyIGRpciA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YodGhpcy5yb290VGFicy50YWJQb3NpdGlvbikgIT09IC0xID8gJ1gnIDogJ1knO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlJyArIGRpciArICcoLScgKyB0aGlzLm5hdk9mZnNldCArICdweCknXG4gICAgICB9O1xuICAgIH0sXG4gICAgc2l6ZU5hbWU6IGZ1bmN0aW9uIHNpemVOYW1lKCkge1xuICAgICAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YodGhpcy5yb290VGFicy50YWJQb3NpdGlvbikgIT09IC0xID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgIH1cbiAgfSxcblxuICBtZXRob2RzOiB7XG4gICAgc2Nyb2xsUHJldjogZnVuY3Rpb24gc2Nyb2xsUHJldigpIHtcbiAgICAgIHZhciBjb250YWluZXJTaXplID0gdGhpcy4kcmVmcy5uYXZTY3JvbGxbJ29mZnNldCcgKyB0YWJfbmF2dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfZmlyc3RVcHBlckNhc2UodGhpcy5zaXplTmFtZSldO1xuICAgICAgdmFyIGN1cnJlbnRPZmZzZXQgPSB0aGlzLm5hdk9mZnNldDtcblxuICAgICAgaWYgKCFjdXJyZW50T2Zmc2V0KSByZXR1cm47XG5cbiAgICAgIHZhciBuZXdPZmZzZXQgPSBjdXJyZW50T2Zmc2V0ID4gY29udGFpbmVyU2l6ZSA/IGN1cnJlbnRPZmZzZXQgLSBjb250YWluZXJTaXplIDogMDtcblxuICAgICAgdGhpcy5uYXZPZmZzZXQgPSBuZXdPZmZzZXQ7XG4gICAgfSxcbiAgICBzY3JvbGxOZXh0OiBmdW5jdGlvbiBzY3JvbGxOZXh0KCkge1xuICAgICAgdmFyIG5hdlNpemUgPSB0aGlzLiRyZWZzLm5hdlsnb2Zmc2V0JyArIHRhYl9uYXZ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19maXJzdFVwcGVyQ2FzZSh0aGlzLnNpemVOYW1lKV07XG4gICAgICB2YXIgY29udGFpbmVyU2l6ZSA9IHRoaXMuJHJlZnMubmF2U2Nyb2xsWydvZmZzZXQnICsgdGFiX25hdnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzX2ZpcnN0VXBwZXJDYXNlKHRoaXMuc2l6ZU5hbWUpXTtcbiAgICAgIHZhciBjdXJyZW50T2Zmc2V0ID0gdGhpcy5uYXZPZmZzZXQ7XG5cbiAgICAgIGlmIChuYXZTaXplIC0gY3VycmVudE9mZnNldCA8PSBjb250YWluZXJTaXplKSByZXR1cm47XG5cbiAgICAgIHZhciBuZXdPZmZzZXQgPSBuYXZTaXplIC0gY3VycmVudE9mZnNldCA+IGNvbnRhaW5lclNpemUgKiAyID8gY3VycmVudE9mZnNldCArIGNvbnRhaW5lclNpemUgOiBuYXZTaXplIC0gY29udGFpbmVyU2l6ZTtcblxuICAgICAgdGhpcy5uYXZPZmZzZXQgPSBuZXdPZmZzZXQ7XG4gICAgfSxcbiAgICBzY3JvbGxUb0FjdGl2ZVRhYjogZnVuY3Rpb24gc2Nyb2xsVG9BY3RpdmVUYWIoKSB7XG4gICAgICBpZiAoIXRoaXMuc2Nyb2xsYWJsZSkgcmV0dXJuO1xuICAgICAgdmFyIG5hdiA9IHRoaXMuJHJlZnMubmF2O1xuICAgICAgdmFyIGFjdGl2ZVRhYiA9IHRoaXMuJGVsLnF1ZXJ5U2VsZWN0b3IoJy5pcy1hY3RpdmUnKTtcbiAgICAgIGlmICghYWN0aXZlVGFiKSByZXR1cm47XG4gICAgICB2YXIgbmF2U2Nyb2xsID0gdGhpcy4kcmVmcy5uYXZTY3JvbGw7XG4gICAgICB2YXIgaXNIb3Jpem9udGFsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZih0aGlzLnJvb3RUYWJzLnRhYlBvc2l0aW9uKSAhPT0gLTE7XG4gICAgICB2YXIgYWN0aXZlVGFiQm91bmRpbmcgPSBhY3RpdmVUYWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgbmF2U2Nyb2xsQm91bmRpbmcgPSBuYXZTY3JvbGwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgbWF4T2Zmc2V0ID0gaXNIb3Jpem9udGFsID8gbmF2Lm9mZnNldFdpZHRoIC0gbmF2U2Nyb2xsQm91bmRpbmcud2lkdGggOiBuYXYub2Zmc2V0SGVpZ2h0IC0gbmF2U2Nyb2xsQm91bmRpbmcuaGVpZ2h0O1xuICAgICAgdmFyIGN1cnJlbnRPZmZzZXQgPSB0aGlzLm5hdk9mZnNldDtcbiAgICAgIHZhciBuZXdPZmZzZXQgPSBjdXJyZW50T2Zmc2V0O1xuXG4gICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgIGlmIChhY3RpdmVUYWJCb3VuZGluZy5sZWZ0IDwgbmF2U2Nyb2xsQm91bmRpbmcubGVmdCkge1xuICAgICAgICAgIG5ld09mZnNldCA9IGN1cnJlbnRPZmZzZXQgLSAobmF2U2Nyb2xsQm91bmRpbmcubGVmdCAtIGFjdGl2ZVRhYkJvdW5kaW5nLmxlZnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhY3RpdmVUYWJCb3VuZGluZy5yaWdodCA+IG5hdlNjcm9sbEJvdW5kaW5nLnJpZ2h0KSB7XG4gICAgICAgICAgbmV3T2Zmc2V0ID0gY3VycmVudE9mZnNldCArIGFjdGl2ZVRhYkJvdW5kaW5nLnJpZ2h0IC0gbmF2U2Nyb2xsQm91bmRpbmcucmlnaHQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChhY3RpdmVUYWJCb3VuZGluZy50b3AgPCBuYXZTY3JvbGxCb3VuZGluZy50b3ApIHtcbiAgICAgICAgICBuZXdPZmZzZXQgPSBjdXJyZW50T2Zmc2V0IC0gKG5hdlNjcm9sbEJvdW5kaW5nLnRvcCAtIGFjdGl2ZVRhYkJvdW5kaW5nLnRvcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGl2ZVRhYkJvdW5kaW5nLmJvdHRvbSA+IG5hdlNjcm9sbEJvdW5kaW5nLmJvdHRvbSkge1xuICAgICAgICAgIG5ld09mZnNldCA9IGN1cnJlbnRPZmZzZXQgKyAoYWN0aXZlVGFiQm91bmRpbmcuYm90dG9tIC0gbmF2U2Nyb2xsQm91bmRpbmcuYm90dG9tKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV3T2Zmc2V0ID0gTWF0aC5tYXgobmV3T2Zmc2V0LCAwKTtcbiAgICAgIHRoaXMubmF2T2Zmc2V0ID0gTWF0aC5taW4obmV3T2Zmc2V0LCBtYXhPZmZzZXQpO1xuICAgIH0sXG4gICAgdXBkYXRlOiBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgICBpZiAoIXRoaXMuJHJlZnMubmF2KSByZXR1cm47XG4gICAgICB2YXIgc2l6ZU5hbWUgPSB0aGlzLnNpemVOYW1lO1xuICAgICAgdmFyIG5hdlNpemUgPSB0aGlzLiRyZWZzLm5hdlsnb2Zmc2V0JyArIHRhYl9uYXZ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19maXJzdFVwcGVyQ2FzZShzaXplTmFtZSldO1xuICAgICAgdmFyIGNvbnRhaW5lclNpemUgPSB0aGlzLiRyZWZzLm5hdlNjcm9sbFsnb2Zmc2V0JyArIHRhYl9uYXZ2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc19maXJzdFVwcGVyQ2FzZShzaXplTmFtZSldO1xuICAgICAgdmFyIGN1cnJlbnRPZmZzZXQgPSB0aGlzLm5hdk9mZnNldDtcblxuICAgICAgaWYgKGNvbnRhaW5lclNpemUgPCBuYXZTaXplKSB7XG4gICAgICAgIHZhciBfY3VycmVudE9mZnNldCA9IHRoaXMubmF2T2Zmc2V0O1xuICAgICAgICB0aGlzLnNjcm9sbGFibGUgPSB0aGlzLnNjcm9sbGFibGUgfHwge307XG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZS5wcmV2ID0gX2N1cnJlbnRPZmZzZXQ7XG4gICAgICAgIHRoaXMuc2Nyb2xsYWJsZS5uZXh0ID0gX2N1cnJlbnRPZmZzZXQgKyBjb250YWluZXJTaXplIDwgbmF2U2l6ZTtcbiAgICAgICAgaWYgKG5hdlNpemUgLSBfY3VycmVudE9mZnNldCA8IGNvbnRhaW5lclNpemUpIHtcbiAgICAgICAgICB0aGlzLm5hdk9mZnNldCA9IG5hdlNpemUgLSBjb250YWluZXJTaXplO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNjcm9sbGFibGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGN1cnJlbnRPZmZzZXQgPiAwKSB7XG4gICAgICAgICAgdGhpcy5uYXZPZmZzZXQgPSAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjaGFuZ2VUYWI6IGZ1bmN0aW9uIGNoYW5nZVRhYihlKSB7XG4gICAgICB2YXIga2V5Q29kZSA9IGUua2V5Q29kZTtcbiAgICAgIHZhciBuZXh0SW5kZXggPSB2b2lkIDA7XG4gICAgICB2YXIgY3VycmVudEluZGV4ID0gdm9pZCAwLFxuICAgICAgICAgIHRhYkxpc3QgPSB2b2lkIDA7XG4gICAgICBpZiAoWzM3LCAzOCwgMzksIDQwXS5pbmRleE9mKGtleUNvZGUpICE9PSAtMSkge1xuICAgICAgICAvLyDlt6blj7PkuIrkuIvplK7mm7TmjaJ0YWJcbiAgICAgICAgdGFiTGlzdCA9IGUuY3VycmVudFRhcmdldC5xdWVyeVNlbGVjdG9yQWxsKCdbcm9sZT10YWJdJyk7XG4gICAgICAgIGN1cnJlbnRJbmRleCA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwodGFiTGlzdCwgZS50YXJnZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleUNvZGUgPT09IDM3IHx8IGtleUNvZGUgPT09IDM4KSB7XG4gICAgICAgIC8vIGxlZnRcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gMCkge1xuICAgICAgICAgIC8vIGZpcnN0XG4gICAgICAgICAgbmV4dEluZGV4ID0gdGFiTGlzdC5sZW5ndGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRJbmRleCA9IGN1cnJlbnRJbmRleCAtIDE7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJpZ2h0XG4gICAgICAgIGlmIChjdXJyZW50SW5kZXggPCB0YWJMaXN0Lmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAvLyBub3QgbGFzdFxuICAgICAgICAgIG5leHRJbmRleCA9IGN1cnJlbnRJbmRleCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGFiTGlzdFtuZXh0SW5kZXhdLmZvY3VzKCk7IC8vIOaUueWPmOeEpueCueWFg+e0oFxuICAgICAgdGFiTGlzdFtuZXh0SW5kZXhdLmNsaWNrKCk7IC8vIOmAieS4reS4i+S4gOS4qnRhYlxuICAgICAgdGhpcy5zZXRGb2N1cygpO1xuICAgIH0sXG4gICAgc2V0Rm9jdXM6IGZ1bmN0aW9uIHNldEZvY3VzKCkge1xuICAgICAgaWYgKHRoaXMuZm9jdXNhYmxlKSB7XG4gICAgICAgIHRoaXMuaXNGb2N1cyA9IHRydWU7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW1vdmVGb2N1czogZnVuY3Rpb24gcmVtb3ZlRm9jdXMoKSB7XG4gICAgICB0aGlzLmlzRm9jdXMgPSBmYWxzZTtcbiAgICB9LFxuICAgIHZpc2liaWxpdHlDaGFuZ2VIYW5kbGVyOiBmdW5jdGlvbiB2aXNpYmlsaXR5Q2hhbmdlSGFuZGxlcigpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciB2aXNpYmlsaXR5ID0gZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlO1xuICAgICAgaWYgKHZpc2liaWxpdHkgPT09ICdoaWRkZW4nKSB7XG4gICAgICAgIHRoaXMuZm9jdXNhYmxlID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKHZpc2liaWxpdHkgPT09ICd2aXNpYmxlJykge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpcy5mb2N1c2FibGUgPSB0cnVlO1xuICAgICAgICB9LCA1MCk7XG4gICAgICB9XG4gICAgfSxcbiAgICB3aW5kb3dCbHVySGFuZGxlcjogZnVuY3Rpb24gd2luZG93Qmx1ckhhbmRsZXIoKSB7XG4gICAgICB0aGlzLmZvY3VzYWJsZSA9IGZhbHNlO1xuICAgIH0sXG4gICAgd2luZG93Rm9jdXNIYW5kbGVyOiBmdW5jdGlvbiB3aW5kb3dGb2N1c0hhbmRsZXIoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5mb2N1c2FibGUgPSB0cnVlO1xuICAgICAgfSwgNTApO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkKCkge1xuICAgIHRoaXMudXBkYXRlKCk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyKGgpIHtcbiAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgIHZhciB0eXBlID0gdGhpcy50eXBlLFxuICAgICAgICBwYW5lcyA9IHRoaXMucGFuZXMsXG4gICAgICAgIGVkaXRhYmxlID0gdGhpcy5lZGl0YWJsZSxcbiAgICAgICAgc3RyZXRjaCA9IHRoaXMuc3RyZXRjaCxcbiAgICAgICAgb25UYWJDbGljayA9IHRoaXMub25UYWJDbGljayxcbiAgICAgICAgb25UYWJSZW1vdmUgPSB0aGlzLm9uVGFiUmVtb3ZlLFxuICAgICAgICBuYXZTdHlsZSA9IHRoaXMubmF2U3R5bGUsXG4gICAgICAgIHNjcm9sbGFibGUgPSB0aGlzLnNjcm9sbGFibGUsXG4gICAgICAgIHNjcm9sbE5leHQgPSB0aGlzLnNjcm9sbE5leHQsXG4gICAgICAgIHNjcm9sbFByZXYgPSB0aGlzLnNjcm9sbFByZXYsXG4gICAgICAgIGNoYW5nZVRhYiA9IHRoaXMuY2hhbmdlVGFiLFxuICAgICAgICBzZXRGb2N1cyA9IHRoaXMuc2V0Rm9jdXMsXG4gICAgICAgIHJlbW92ZUZvY3VzID0gdGhpcy5yZW1vdmVGb2N1cztcblxuICAgIHZhciBzY3JvbGxCdG4gPSBzY3JvbGxhYmxlID8gW2goXG4gICAgICAnc3BhbicsXG4gICAgICB7ICdjbGFzcyc6IFsnZWwtdGFic19fbmF2LXByZXYnLCBzY3JvbGxhYmxlLnByZXYgPyAnJyA6ICdpcy1kaXNhYmxlZCddLCBvbjoge1xuICAgICAgICAgICdjbGljayc6IHNjcm9sbFByZXZcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtoKCdpJywgeyAnY2xhc3MnOiAnZWwtaWNvbi1hcnJvdy1sZWZ0JyB9KV1cbiAgICApLCBoKFxuICAgICAgJ3NwYW4nLFxuICAgICAgeyAnY2xhc3MnOiBbJ2VsLXRhYnNfX25hdi1uZXh0Jywgc2Nyb2xsYWJsZS5uZXh0ID8gJycgOiAnaXMtZGlzYWJsZWQnXSwgb246IHtcbiAgICAgICAgICAnY2xpY2snOiBzY3JvbGxOZXh0XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBbaCgnaScsIHsgJ2NsYXNzJzogJ2VsLWljb24tYXJyb3ctcmlnaHQnIH0pXVxuICAgICldIDogbnVsbDtcblxuICAgIHZhciB0YWJzID0gdGhpcy5fbChwYW5lcywgZnVuY3Rpb24gKHBhbmUsIGluZGV4KSB7XG4gICAgICB2YXIgX3JlZjtcblxuICAgICAgdmFyIHRhYk5hbWUgPSBwYW5lLm5hbWUgfHwgcGFuZS5pbmRleCB8fCBpbmRleDtcbiAgICAgIHZhciBjbG9zYWJsZSA9IHBhbmUuaXNDbG9zYWJsZSB8fCBlZGl0YWJsZTtcblxuICAgICAgcGFuZS5pbmRleCA9ICcnICsgaW5kZXg7XG5cbiAgICAgIHZhciBidG5DbG9zZSA9IGNsb3NhYmxlID8gaCgnc3BhbicsIHsgJ2NsYXNzJzogJ2VsLWljb24tY2xvc2UnLCBvbjoge1xuICAgICAgICAgICdjbGljayc6IGZ1bmN0aW9uIGNsaWNrKGV2KSB7XG4gICAgICAgICAgICBvblRhYlJlbW92ZShwYW5lLCBldik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSA6IG51bGw7XG5cbiAgICAgIHZhciB0YWJMYWJlbENvbnRlbnQgPSBwYW5lLiRzbG90cy5sYWJlbCB8fCBwYW5lLmxhYmVsO1xuICAgICAgdmFyIHRhYmluZGV4ID0gcGFuZS5hY3RpdmUgPyAwIDogLTE7XG4gICAgICByZXR1cm4gaChcbiAgICAgICAgJ2RpdicsXG4gICAgICAgIHtcbiAgICAgICAgICAnY2xhc3MnOiAoX3JlZiA9IHtcbiAgICAgICAgICAgICdlbC10YWJzX19pdGVtJzogdHJ1ZVxuICAgICAgICAgIH0sIF9yZWZbJ2lzLScgKyBfdGhpczMucm9vdFRhYnMudGFiUG9zaXRpb25dID0gdHJ1ZSwgX3JlZlsnaXMtYWN0aXZlJ10gPSBwYW5lLmFjdGl2ZSwgX3JlZlsnaXMtZGlzYWJsZWQnXSA9IHBhbmUuZGlzYWJsZWQsIF9yZWZbJ2lzLWNsb3NhYmxlJ10gPSBjbG9zYWJsZSwgX3JlZlsnaXMtZm9jdXMnXSA9IF90aGlzMy5pc0ZvY3VzLCBfcmVmKSxcbiAgICAgICAgICBhdHRyczogeyBpZDogJ3RhYi0nICsgdGFiTmFtZSxcblxuICAgICAgICAgICAgJ2FyaWEtY29udHJvbHMnOiAncGFuZS0nICsgdGFiTmFtZSxcbiAgICAgICAgICAgIHJvbGU6ICd0YWInLFxuICAgICAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiBwYW5lLmFjdGl2ZSxcblxuICAgICAgICAgICAgdGFiaW5kZXg6IHRhYmluZGV4XG4gICAgICAgICAgfSxcbiAgICAgICAgICBrZXk6ICd0YWItJyArIHRhYk5hbWUsIHJlZjogJ3RhYnMnLCByZWZJbkZvcjogdHJ1ZSxcbiAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgJ2ZvY3VzJzogZnVuY3Rpb24gZm9jdXMoKSB7XG4gICAgICAgICAgICAgIHNldEZvY3VzKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2JsdXInOiBmdW5jdGlvbiBibHVyKCkge1xuICAgICAgICAgICAgICByZW1vdmVGb2N1cygpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdjbGljayc6IGZ1bmN0aW9uIGNsaWNrKGV2KSB7XG4gICAgICAgICAgICAgIHJlbW92ZUZvY3VzKCk7b25UYWJDbGljayhwYW5lLCB0YWJOYW1lLCBldik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgJ2tleWRvd24nOiBmdW5jdGlvbiBrZXlkb3duKGV2KSB7XG4gICAgICAgICAgICAgIGlmIChjbG9zYWJsZSAmJiAoZXYua2V5Q29kZSA9PT0gNDYgfHwgZXYua2V5Q29kZSA9PT0gOCkpIHtcbiAgICAgICAgICAgICAgICBvblRhYlJlbW92ZShwYW5lLCBldik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIFt0YWJMYWJlbENvbnRlbnQsIGJ0bkNsb3NlXVxuICAgICAgKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaChcbiAgICAgICdkaXYnLFxuICAgICAgeyAnY2xhc3MnOiBbJ2VsLXRhYnNfX25hdi13cmFwJywgc2Nyb2xsYWJsZSA/ICdpcy1zY3JvbGxhYmxlJyA6ICcnLCAnaXMtJyArIHRoaXMucm9vdFRhYnMudGFiUG9zaXRpb25dIH0sXG4gICAgICBbc2Nyb2xsQnRuLCBoKFxuICAgICAgICAnZGl2JyxcbiAgICAgICAgeyAnY2xhc3MnOiBbJ2VsLXRhYnNfX25hdi1zY3JvbGwnXSwgcmVmOiAnbmF2U2Nyb2xsJyB9LFxuICAgICAgICBbaChcbiAgICAgICAgICAnZGl2JyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICAnY2xhc3MnOiBbJ2VsLXRhYnNfX25hdicsICdpcy0nICsgdGhpcy5yb290VGFicy50YWJQb3NpdGlvbiwgc3RyZXRjaCAmJiBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHRoaXMucm9vdFRhYnMudGFiUG9zaXRpb24pICE9PSAtMSA/ICdpcy1zdHJldGNoJyA6ICcnXSxcbiAgICAgICAgICAgIHJlZjogJ25hdicsXG4gICAgICAgICAgICBzdHlsZTogbmF2U3R5bGUsXG4gICAgICAgICAgICBhdHRyczogeyByb2xlOiAndGFibGlzdCdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAna2V5ZG93bic6IGNoYW5nZVRhYlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgWyF0eXBlID8gaCgndGFiLWJhcicsIHtcbiAgICAgICAgICAgIGF0dHJzOiB7IHRhYnM6IHBhbmVzIH1cbiAgICAgICAgICB9KSA6IG51bGwsIHRhYnNdXG4gICAgICAgICldXG4gICAgICApXVxuICAgICk7XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICBPYmplY3QocmVzaXplX2V2ZW50X1tcImFkZFJlc2l6ZUxpc3RlbmVyXCJdKSh0aGlzLiRlbCwgdGhpcy51cGRhdGUpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLnZpc2liaWxpdHlDaGFuZ2VIYW5kbGVyKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMud2luZG93Qmx1ckhhbmRsZXIpO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIHRoaXMud2luZG93Rm9jdXNIYW5kbGVyKTtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzNC5zY3JvbGxUb0FjdGl2ZVRhYigpO1xuICAgIH0sIDApO1xuICB9LFxuICBiZWZvcmVEZXN0cm95OiBmdW5jdGlvbiBiZWZvcmVEZXN0cm95KCkge1xuICAgIGlmICh0aGlzLiRlbCAmJiB0aGlzLnVwZGF0ZSkgT2JqZWN0KHJlc2l6ZV9ldmVudF9bXCJyZW1vdmVSZXNpemVMaXN0ZW5lclwiXSkodGhpcy4kZWwsIHRoaXMudXBkYXRlKTtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy52aXNpYmlsaXR5Q2hhbmdlSGFuZGxlcik7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCB0aGlzLndpbmRvd0JsdXJIYW5kbGVyKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLndpbmRvd0ZvY3VzSGFuZGxlcik7XG4gIH1cbn0pO1xuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9wYWNrYWdlcy90YWJzL3NyYy90YWItbmF2LnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcbiAvKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBzcmNfdGFiX25hdnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyA9ICh0YWJfbmF2dnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfKTsgXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL3RhYnMvc3JjL3RhYi1uYXYudnVlXG52YXIgdGFiX25hdl9yZW5kZXIsIHRhYl9uYXZfc3RhdGljUmVuZGVyRm5zXG5cblxuXG5cbi8qIG5vcm1hbGl6ZSBjb21wb25lbnQgKi9cblxudmFyIHRhYl9uYXZfY29tcG9uZW50ID0gT2JqZWN0KGNvbXBvbmVudE5vcm1hbGl6ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pKFxuICBzcmNfdGFiX25hdnZ1ZV90eXBlX3NjcmlwdF9sYW5nX2pzXyxcbiAgdGFiX25hdl9yZW5kZXIsXG4gIHRhYl9uYXZfc3RhdGljUmVuZGVyRm5zLFxuICBmYWxzZSxcbiAgbnVsbCxcbiAgbnVsbCxcbiAgbnVsbFxuICBcbilcblxuLyogaG90IHJlbG9hZCAqL1xuaWYgKGZhbHNlKSB7IHZhciB0YWJfbmF2X2FwaTsgfVxudGFiX25hdl9jb21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInBhY2thZ2VzL3RhYnMvc3JjL3RhYi1uYXYudnVlXCJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRhYl9uYXYgPSAodGFiX25hdl9jb21wb25lbnQuZXhwb3J0cyk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliPz92dWUtbG9hZGVyLW9wdGlvbnMhLi9wYWNrYWdlcy90YWJzL3NyYy90YWJzLnZ1ZT92dWUmdHlwZT1zY3JpcHQmbGFuZz1qcyZcblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRhYnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18gPSAoe1xuICBuYW1lOiAnRWxUYWJzJyxcblxuICBjb21wb25lbnRzOiB7XG4gICAgVGFiTmF2OiB0YWJfbmF2XG4gIH0sXG5cbiAgcHJvcHM6IHtcbiAgICB0eXBlOiBTdHJpbmcsXG4gICAgYWN0aXZlTmFtZTogU3RyaW5nLFxuICAgIGNsb3NhYmxlOiBCb29sZWFuLFxuICAgIGFkZGFibGU6IEJvb2xlYW4sXG4gICAgdmFsdWU6IHt9LFxuICAgIGVkaXRhYmxlOiBCb29sZWFuLFxuICAgIHRhYlBvc2l0aW9uOiB7XG4gICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICBkZWZhdWx0OiAndG9wJ1xuICAgIH0sXG4gICAgYmVmb3JlTGVhdmU6IEZ1bmN0aW9uLFxuICAgIHN0cmV0Y2g6IEJvb2xlYW5cbiAgfSxcblxuICBwcm92aWRlOiBmdW5jdGlvbiBwcm92aWRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICByb290VGFiczogdGhpc1xuICAgIH07XG4gIH0sXG4gIGRhdGE6IGZ1bmN0aW9uIGRhdGEoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN1cnJlbnROYW1lOiB0aGlzLnZhbHVlIHx8IHRoaXMuYWN0aXZlTmFtZSxcbiAgICAgIHBhbmVzOiBbXVxuICAgIH07XG4gIH0sXG5cblxuICB3YXRjaDoge1xuICAgIGFjdGl2ZU5hbWU6IGZ1bmN0aW9uIGFjdGl2ZU5hbWUodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0Q3VycmVudE5hbWUodmFsdWUpO1xuICAgIH0sXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKF92YWx1ZSkge1xuICAgICAgdGhpcy5zZXRDdXJyZW50TmFtZShfdmFsdWUpO1xuICAgIH0sXG4gICAgY3VycmVudE5hbWU6IGZ1bmN0aW9uIGN1cnJlbnROYW1lKHZhbHVlKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy4kcmVmcy5uYXYpIHtcbiAgICAgICAgdGhpcy4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIF90aGlzLiRyZWZzLm5hdi4kbmV4dFRpY2soZnVuY3Rpb24gKF8pIHtcbiAgICAgICAgICAgIF90aGlzLiRyZWZzLm5hdi5zY3JvbGxUb0FjdGl2ZVRhYigpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGNhbGNQYW5lSW5zdGFuY2VzOiBmdW5jdGlvbiBjYWxjUGFuZUluc3RhbmNlcygpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgaXNGb3JjZVVwZGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG5cbiAgICAgIGlmICh0aGlzLiRzbG90cy5kZWZhdWx0KSB7XG4gICAgICAgIHZhciBwYW5lU2xvdHMgPSB0aGlzLiRzbG90cy5kZWZhdWx0LmZpbHRlcihmdW5jdGlvbiAodm5vZGUpIHtcbiAgICAgICAgICByZXR1cm4gdm5vZGUudGFnICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnMgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucy5DdG9yLm9wdGlvbnMubmFtZSA9PT0gJ0VsVGFiUGFuZSc7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyB1cGRhdGUgaW5kZWVkXG4gICAgICAgIHZhciBwYW5lcyA9IHBhbmVTbG90cy5tYXAoZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgICAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSBfcmVmLmNvbXBvbmVudEluc3RhbmNlO1xuICAgICAgICAgIHJldHVybiBjb21wb25lbnRJbnN0YW5jZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwYW5lc0NoYW5nZWQgPSAhKHBhbmVzLmxlbmd0aCA9PT0gdGhpcy5wYW5lcy5sZW5ndGggJiYgcGFuZXMuZXZlcnkoZnVuY3Rpb24gKHBhbmUsIGluZGV4KSB7XG4gICAgICAgICAgcmV0dXJuIHBhbmUgPT09IF90aGlzMi5wYW5lc1tpbmRleF07XG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKGlzRm9yY2VVcGRhdGUgfHwgcGFuZXNDaGFuZ2VkKSB7XG4gICAgICAgICAgdGhpcy5wYW5lcyA9IHBhbmVzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucGFuZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIHRoaXMucGFuZXMgPSBbXTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGhhbmRsZVRhYkNsaWNrOiBmdW5jdGlvbiBoYW5kbGVUYWJDbGljayh0YWIsIHRhYk5hbWUsIGV2ZW50KSB7XG4gICAgICBpZiAodGFiLmRpc2FibGVkKSByZXR1cm47XG4gICAgICB0aGlzLnNldEN1cnJlbnROYW1lKHRhYk5hbWUpO1xuICAgICAgdGhpcy4kZW1pdCgndGFiLWNsaWNrJywgdGFiLCBldmVudCk7XG4gICAgfSxcbiAgICBoYW5kbGVUYWJSZW1vdmU6IGZ1bmN0aW9uIGhhbmRsZVRhYlJlbW92ZShwYW5lLCBldikge1xuICAgICAgaWYgKHBhbmUuZGlzYWJsZWQpIHJldHVybjtcbiAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgdGhpcy4kZW1pdCgnZWRpdCcsIHBhbmUubmFtZSwgJ3JlbW92ZScpO1xuICAgICAgdGhpcy4kZW1pdCgndGFiLXJlbW92ZScsIHBhbmUubmFtZSk7XG4gICAgfSxcbiAgICBoYW5kbGVUYWJBZGQ6IGZ1bmN0aW9uIGhhbmRsZVRhYkFkZCgpIHtcbiAgICAgIHRoaXMuJGVtaXQoJ2VkaXQnLCBudWxsLCAnYWRkJyk7XG4gICAgICB0aGlzLiRlbWl0KCd0YWItYWRkJyk7XG4gICAgfSxcbiAgICBzZXRDdXJyZW50TmFtZTogZnVuY3Rpb24gc2V0Q3VycmVudE5hbWUodmFsdWUpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgY2hhbmdlQ3VycmVudE5hbWUgPSBmdW5jdGlvbiBjaGFuZ2VDdXJyZW50TmFtZSgpIHtcbiAgICAgICAgX3RoaXMzLmN1cnJlbnROYW1lID0gdmFsdWU7XG4gICAgICAgIF90aGlzMy4kZW1pdCgnaW5wdXQnLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY3VycmVudE5hbWUgIT09IHZhbHVlICYmIHRoaXMuYmVmb3JlTGVhdmUpIHtcbiAgICAgICAgdmFyIGJlZm9yZSA9IHRoaXMuYmVmb3JlTGVhdmUodmFsdWUsIHRoaXMuY3VycmVudE5hbWUpO1xuICAgICAgICBpZiAoYmVmb3JlICYmIGJlZm9yZS50aGVuKSB7XG4gICAgICAgICAgYmVmb3JlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2hhbmdlQ3VycmVudE5hbWUoKTtcbiAgICAgICAgICAgIF90aGlzMy4kcmVmcy5uYXYgJiYgX3RoaXMzLiRyZWZzLm5hdi5yZW1vdmVGb2N1cygpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9FbGVtZUZFL2VsZW1lbnQvcHVsbC8xNDgxNlxuICAgICAgICAgICAgLy8gaWdub3JlIHByb21pc2UgcmVqZWN0aW9uIGluIGBiZWZvcmUtbGVhdmVgIGhvb2tcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIGlmIChiZWZvcmUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgY2hhbmdlQ3VycmVudE5hbWUoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hhbmdlQ3VycmVudE5hbWUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoaCkge1xuICAgIHZhciBfcmVmMjtcblxuICAgIHZhciB0eXBlID0gdGhpcy50eXBlLFxuICAgICAgICBoYW5kbGVUYWJDbGljayA9IHRoaXMuaGFuZGxlVGFiQ2xpY2ssXG4gICAgICAgIGhhbmRsZVRhYlJlbW92ZSA9IHRoaXMuaGFuZGxlVGFiUmVtb3ZlLFxuICAgICAgICBoYW5kbGVUYWJBZGQgPSB0aGlzLmhhbmRsZVRhYkFkZCxcbiAgICAgICAgY3VycmVudE5hbWUgPSB0aGlzLmN1cnJlbnROYW1lLFxuICAgICAgICBwYW5lcyA9IHRoaXMucGFuZXMsXG4gICAgICAgIGVkaXRhYmxlID0gdGhpcy5lZGl0YWJsZSxcbiAgICAgICAgYWRkYWJsZSA9IHRoaXMuYWRkYWJsZSxcbiAgICAgICAgdGFiUG9zaXRpb24gPSB0aGlzLnRhYlBvc2l0aW9uLFxuICAgICAgICBzdHJldGNoID0gdGhpcy5zdHJldGNoO1xuXG5cbiAgICB2YXIgbmV3QnV0dG9uID0gZWRpdGFibGUgfHwgYWRkYWJsZSA/IGgoXG4gICAgICAnc3BhbicsXG4gICAgICB7XG4gICAgICAgICdjbGFzcyc6ICdlbC10YWJzX19uZXctdGFiJyxcbiAgICAgICAgb246IHtcbiAgICAgICAgICAnY2xpY2snOiBoYW5kbGVUYWJBZGQsXG4gICAgICAgICAgJ2tleWRvd24nOiBmdW5jdGlvbiBrZXlkb3duKGV2KSB7XG4gICAgICAgICAgICBpZiAoZXYua2V5Q29kZSA9PT0gMTMpIHtcbiAgICAgICAgICAgICAgaGFuZGxlVGFiQWRkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhdHRyczoge1xuICAgICAgICAgIHRhYmluZGV4OiAnMCdcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIFtoKCdpJywgeyAnY2xhc3MnOiAnZWwtaWNvbi1wbHVzJyB9KV1cbiAgICApIDogbnVsbDtcblxuICAgIHZhciBuYXZEYXRhID0ge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgY3VycmVudE5hbWU6IGN1cnJlbnROYW1lLFxuICAgICAgICBvblRhYkNsaWNrOiBoYW5kbGVUYWJDbGljayxcbiAgICAgICAgb25UYWJSZW1vdmU6IGhhbmRsZVRhYlJlbW92ZSxcbiAgICAgICAgZWRpdGFibGU6IGVkaXRhYmxlLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBwYW5lczogcGFuZXMsXG4gICAgICAgIHN0cmV0Y2g6IHN0cmV0Y2hcbiAgICAgIH0sXG4gICAgICByZWY6ICduYXYnXG4gICAgfTtcbiAgICB2YXIgaGVhZGVyID0gaChcbiAgICAgICdkaXYnLFxuICAgICAgeyAnY2xhc3MnOiBbJ2VsLXRhYnNfX2hlYWRlcicsICdpcy0nICsgdGFiUG9zaXRpb25dIH0sXG4gICAgICBbbmV3QnV0dG9uLCBoKCd0YWItbmF2JywgbmF2RGF0YSldXG4gICAgKTtcbiAgICB2YXIgcGFuZWxzID0gaChcbiAgICAgICdkaXYnLFxuICAgICAgeyAnY2xhc3MnOiAnZWwtdGFic19fY29udGVudCcgfSxcbiAgICAgIFt0aGlzLiRzbG90cy5kZWZhdWx0XVxuICAgICk7XG5cbiAgICByZXR1cm4gaChcbiAgICAgICdkaXYnLFxuICAgICAgeyAnY2xhc3MnOiAoX3JlZjIgPSB7XG4gICAgICAgICAgJ2VsLXRhYnMnOiB0cnVlLFxuICAgICAgICAgICdlbC10YWJzLS1jYXJkJzogdHlwZSA9PT0gJ2NhcmQnXG4gICAgICAgIH0sIF9yZWYyWydlbC10YWJzLS0nICsgdGFiUG9zaXRpb25dID0gdHJ1ZSwgX3JlZjJbJ2VsLXRhYnMtLWJvcmRlci1jYXJkJ10gPSB0eXBlID09PSAnYm9yZGVyLWNhcmQnLCBfcmVmMikgfSxcbiAgICAgIFt0YWJQb3NpdGlvbiAhPT0gJ2JvdHRvbScgPyBbaGVhZGVyLCBwYW5lbHNdIDogW3BhbmVscywgaGVhZGVyXV1cbiAgICApO1xuICB9LFxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkKCkge1xuICAgIGlmICghdGhpcy5jdXJyZW50TmFtZSkge1xuICAgICAgdGhpcy5zZXRDdXJyZW50TmFtZSgnMCcpO1xuICAgIH1cblxuICAgIHRoaXMuJG9uKCd0YWItbmF2LXVwZGF0ZScsIHRoaXMuY2FsY1BhbmVJbnN0YW5jZXMuYmluZChudWxsLCB0cnVlKSk7XG4gIH0sXG4gIG1vdW50ZWQ6IGZ1bmN0aW9uIG1vdW50ZWQoKSB7XG4gICAgdGhpcy5jYWxjUGFuZUluc3RhbmNlcygpO1xuICB9LFxuICB1cGRhdGVkOiBmdW5jdGlvbiB1cGRhdGVkKCkge1xuICAgIHRoaXMuY2FsY1BhbmVJbnN0YW5jZXMoKTtcbiAgfVxufSk7XG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL3BhY2thZ2VzL3RhYnMvc3JjL3RhYnMudnVlP3Z1ZSZ0eXBlPXNjcmlwdCZsYW5nPWpzJlxuIC8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHNyY190YWJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfID0gKHRhYnN2dWVfdHlwZV9zY3JpcHRfbGFuZ19qc18pOyBcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvdGFicy9zcmMvdGFicy52dWVcbnZhciB0YWJzX3JlbmRlciwgdGFic19zdGF0aWNSZW5kZXJGbnNcblxuXG5cblxuLyogbm9ybWFsaXplIGNvbXBvbmVudCAqL1xuXG52YXIgdGFic19jb21wb25lbnQgPSBPYmplY3QoY29tcG9uZW50Tm9ybWFsaXplcltcImFcIiAvKiBkZWZhdWx0ICovXSkoXG4gIHNyY190YWJzdnVlX3R5cGVfc2NyaXB0X2xhbmdfanNfLFxuICB0YWJzX3JlbmRlcixcbiAgdGFic19zdGF0aWNSZW5kZXJGbnMsXG4gIGZhbHNlLFxuICBudWxsLFxuICBudWxsLFxuICBudWxsXG4gIFxuKVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAoZmFsc2UpIHsgdmFyIHRhYnNfYXBpOyB9XG50YWJzX2NvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwicGFja2FnZXMvdGFicy9zcmMvdGFicy52dWVcIlxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdGFicyA9ICh0YWJzX2NvbXBvbmVudC5leHBvcnRzKTtcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vcGFja2FnZXMvdGFicy9pbmRleC5qc1xuXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG50YWJzLmluc3RhbGwgPSBmdW5jdGlvbiAoVnVlKSB7XG4gIFZ1ZS5jb21wb25lbnQodGFicy5uYW1lLCB0YWJzKTtcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHBhY2thZ2VzX3RhYnMgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh0YWJzKTtcblxuLyoqKi8gfSlcblxuLyoqKioqKi8gfSk7Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/element-ui/lib/tabs.js\n");

/***/ }),

/***/ "./node_modules/element-ui/lib/utils/resize-event.js":
/*!***********************************************************!*\
  !*** ./node_modules/element-ui/lib/utils/resize-event.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.removeResizeListener = exports.addResizeListener = undefined;\n\nvar _resizeObserverPolyfill = __webpack_require__(/*! resize-observer-polyfill */ \"./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\");\n\nvar _resizeObserverPolyfill2 = _interopRequireDefault(_resizeObserverPolyfill);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar isServer = typeof window === 'undefined';\n/* istanbul ignore next */\n\nvar resizeHandler = function resizeHandler(entries) {\n  for (var _iterator = entries, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var entry = _ref;\n    var listeners = entry.target.__resizeListeners__ || [];\n\n    if (listeners.length) {\n      listeners.forEach(function (fn) {\n        fn();\n      });\n    }\n  }\n};\n/* istanbul ignore next */\n\n\nvar addResizeListener = exports.addResizeListener = function addResizeListener(element, fn) {\n  if (isServer) return;\n\n  if (!element.__resizeListeners__) {\n    element.__resizeListeners__ = [];\n    element.__ro__ = new _resizeObserverPolyfill2.default(resizeHandler);\n\n    element.__ro__.observe(element);\n  }\n\n  element.__resizeListeners__.push(fn);\n};\n/* istanbul ignore next */\n\n\nvar removeResizeListener = exports.removeResizeListener = function removeResizeListener(element, fn) {\n  if (!element || !element.__resizeListeners__) return;\n\n  element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);\n\n  if (!element.__resizeListeners__.length) {\n    element.__ro__.disconnect();\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdXRpbHMvcmVzaXplLWV2ZW50LmpzPzQwMTAiXSwibmFtZXMiOlsiZXhwb3J0cyIsIl9fZXNNb2R1bGUiLCJyZW1vdmVSZXNpemVMaXN0ZW5lciIsImFkZFJlc2l6ZUxpc3RlbmVyIiwidW5kZWZpbmVkIiwiX3Jlc2l6ZU9ic2VydmVyUG9seWZpbGwiLCJyZXF1aXJlIiwiX3Jlc2l6ZU9ic2VydmVyUG9seWZpbGwyIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIm9iaiIsImRlZmF1bHQiLCJpc1NlcnZlciIsIndpbmRvdyIsInJlc2l6ZUhhbmRsZXIiLCJlbnRyaWVzIiwiX2l0ZXJhdG9yIiwiX2lzQXJyYXkiLCJBcnJheSIsImlzQXJyYXkiLCJfaSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiX3JlZiIsImxlbmd0aCIsIm5leHQiLCJkb25lIiwidmFsdWUiLCJlbnRyeSIsImxpc3RlbmVycyIsInRhcmdldCIsIl9fcmVzaXplTGlzdGVuZXJzX18iLCJmb3JFYWNoIiwiZm4iLCJlbGVtZW50IiwiX19yb19fIiwib2JzZXJ2ZSIsInB1c2giLCJzcGxpY2UiLCJpbmRleE9mIiwiZGlzY29ubmVjdCJdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWJBLE9BQU8sQ0FBQ0MsVUFBUixHQUFxQixJQUFyQjtBQUNBRCxPQUFPLENBQUNFLG9CQUFSLEdBQStCRixPQUFPLENBQUNHLGlCQUFSLEdBQTRCQyxTQUEzRDs7QUFFQSxJQUFJQyx1QkFBdUIsR0FBR0MsbUJBQU8sQ0FBQyxtR0FBRCxDQUFyQzs7QUFFQSxJQUFJQyx3QkFBd0IsR0FBR0Msc0JBQXNCLENBQUNILHVCQUFELENBQXJEOztBQUVBLFNBQVNHLHNCQUFULENBQWdDQyxHQUFoQyxFQUFxQztBQUFFLFNBQU9BLEdBQUcsSUFBSUEsR0FBRyxDQUFDUixVQUFYLEdBQXdCUSxHQUF4QixHQUE4QjtBQUFFQyxXQUFPLEVBQUVEO0FBQVgsR0FBckM7QUFBd0Q7O0FBRS9GLElBQUlFLFFBQVEsR0FBRyxPQUFPQyxNQUFQLEtBQWtCLFdBQWpDO0FBRUE7O0FBQ0EsSUFBSUMsYUFBYSxHQUFHLFNBQVNBLGFBQVQsQ0FBdUJDLE9BQXZCLEVBQWdDO0FBQ2xELE9BQUssSUFBSUMsU0FBUyxHQUFHRCxPQUFoQixFQUF5QkUsUUFBUSxHQUFHQyxLQUFLLENBQUNDLE9BQU4sQ0FBY0gsU0FBZCxDQUFwQyxFQUE4REksRUFBRSxHQUFHLENBQW5FLEVBQXNFSixTQUFTLEdBQUdDLFFBQVEsR0FBR0QsU0FBSCxHQUFlQSxTQUFTLENBQUNLLE1BQU0sQ0FBQ0MsUUFBUixDQUFULEVBQTlHLElBQThJO0FBQzVJLFFBQUlDLElBQUo7O0FBRUEsUUFBSU4sUUFBSixFQUFjO0FBQ1osVUFBSUcsRUFBRSxJQUFJSixTQUFTLENBQUNRLE1BQXBCLEVBQTRCO0FBQzVCRCxVQUFJLEdBQUdQLFNBQVMsQ0FBQ0ksRUFBRSxFQUFILENBQWhCO0FBQ0QsS0FIRCxNQUdPO0FBQ0xBLFFBQUUsR0FBR0osU0FBUyxDQUFDUyxJQUFWLEVBQUw7QUFDQSxVQUFJTCxFQUFFLENBQUNNLElBQVAsRUFBYTtBQUNiSCxVQUFJLEdBQUdILEVBQUUsQ0FBQ08sS0FBVjtBQUNEOztBQUVELFFBQUlDLEtBQUssR0FBR0wsSUFBWjtBQUVBLFFBQUlNLFNBQVMsR0FBR0QsS0FBSyxDQUFDRSxNQUFOLENBQWFDLG1CQUFiLElBQW9DLEVBQXBEOztBQUNBLFFBQUlGLFNBQVMsQ0FBQ0wsTUFBZCxFQUFzQjtBQUNwQkssZUFBUyxDQUFDRyxPQUFWLENBQWtCLFVBQVVDLEVBQVYsRUFBYztBQUM5QkEsVUFBRTtBQUNILE9BRkQ7QUFHRDtBQUNGO0FBQ0YsQ0F0QkQ7QUF3QkE7OztBQUNBLElBQUk3QixpQkFBaUIsR0FBR0gsT0FBTyxDQUFDRyxpQkFBUixHQUE0QixTQUFTQSxpQkFBVCxDQUEyQjhCLE9BQTNCLEVBQW9DRCxFQUFwQyxFQUF3QztBQUMxRixNQUFJckIsUUFBSixFQUFjOztBQUNkLE1BQUksQ0FBQ3NCLE9BQU8sQ0FBQ0gsbUJBQWIsRUFBa0M7QUFDaENHLFdBQU8sQ0FBQ0gsbUJBQVIsR0FBOEIsRUFBOUI7QUFDQUcsV0FBTyxDQUFDQyxNQUFSLEdBQWlCLElBQUkzQix3QkFBd0IsQ0FBQ0csT0FBN0IsQ0FBcUNHLGFBQXJDLENBQWpCOztBQUNBb0IsV0FBTyxDQUFDQyxNQUFSLENBQWVDLE9BQWYsQ0FBdUJGLE9BQXZCO0FBQ0Q7O0FBQ0RBLFNBQU8sQ0FBQ0gsbUJBQVIsQ0FBNEJNLElBQTVCLENBQWlDSixFQUFqQztBQUNELENBUkQ7QUFVQTs7O0FBQ0EsSUFBSTlCLG9CQUFvQixHQUFHRixPQUFPLENBQUNFLG9CQUFSLEdBQStCLFNBQVNBLG9CQUFULENBQThCK0IsT0FBOUIsRUFBdUNELEVBQXZDLEVBQTJDO0FBQ25HLE1BQUksQ0FBQ0MsT0FBRCxJQUFZLENBQUNBLE9BQU8sQ0FBQ0gsbUJBQXpCLEVBQThDOztBQUM5Q0csU0FBTyxDQUFDSCxtQkFBUixDQUE0Qk8sTUFBNUIsQ0FBbUNKLE9BQU8sQ0FBQ0gsbUJBQVIsQ0FBNEJRLE9BQTVCLENBQW9DTixFQUFwQyxDQUFuQyxFQUE0RSxDQUE1RTs7QUFDQSxNQUFJLENBQUNDLE9BQU8sQ0FBQ0gsbUJBQVIsQ0FBNEJQLE1BQWpDLEVBQXlDO0FBQ3ZDVSxXQUFPLENBQUNDLE1BQVIsQ0FBZUssVUFBZjtBQUNEO0FBQ0YsQ0FORCIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9lbGVtZW50LXVpL2xpYi91dGlscy9yZXNpemUtZXZlbnQuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnJlbW92ZVJlc2l6ZUxpc3RlbmVyID0gZXhwb3J0cy5hZGRSZXNpemVMaXN0ZW5lciA9IHVuZGVmaW5lZDtcblxudmFyIF9yZXNpemVPYnNlcnZlclBvbHlmaWxsID0gcmVxdWlyZSgncmVzaXplLW9ic2VydmVyLXBvbHlmaWxsJyk7XG5cbnZhciBfcmVzaXplT2JzZXJ2ZXJQb2x5ZmlsbDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZXNpemVPYnNlcnZlclBvbHlmaWxsKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGlzU2VydmVyID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG52YXIgcmVzaXplSGFuZGxlciA9IGZ1bmN0aW9uIHJlc2l6ZUhhbmRsZXIoZW50cmllcykge1xuICBmb3IgKHZhciBfaXRlcmF0b3IgPSBlbnRyaWVzLCBfaXNBcnJheSA9IEFycmF5LmlzQXJyYXkoX2l0ZXJhdG9yKSwgX2kgPSAwLCBfaXRlcmF0b3IgPSBfaXNBcnJheSA/IF9pdGVyYXRvciA6IF9pdGVyYXRvcltTeW1ib2wuaXRlcmF0b3JdKCk7Oykge1xuICAgIHZhciBfcmVmO1xuXG4gICAgaWYgKF9pc0FycmF5KSB7XG4gICAgICBpZiAoX2kgPj0gX2l0ZXJhdG9yLmxlbmd0aCkgYnJlYWs7XG4gICAgICBfcmVmID0gX2l0ZXJhdG9yW19pKytdO1xuICAgIH0gZWxzZSB7XG4gICAgICBfaSA9IF9pdGVyYXRvci5uZXh0KCk7XG4gICAgICBpZiAoX2kuZG9uZSkgYnJlYWs7XG4gICAgICBfcmVmID0gX2kudmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGVudHJ5ID0gX3JlZjtcblxuICAgIHZhciBsaXN0ZW5lcnMgPSBlbnRyeS50YXJnZXQuX19yZXNpemVMaXN0ZW5lcnNfXyB8fCBbXTtcbiAgICBpZiAobGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG52YXIgYWRkUmVzaXplTGlzdGVuZXIgPSBleHBvcnRzLmFkZFJlc2l6ZUxpc3RlbmVyID0gZnVuY3Rpb24gYWRkUmVzaXplTGlzdGVuZXIoZWxlbWVudCwgZm4pIHtcbiAgaWYgKGlzU2VydmVyKSByZXR1cm47XG4gIGlmICghZWxlbWVudC5fX3Jlc2l6ZUxpc3RlbmVyc19fKSB7XG4gICAgZWxlbWVudC5fX3Jlc2l6ZUxpc3RlbmVyc19fID0gW107XG4gICAgZWxlbWVudC5fX3JvX18gPSBuZXcgX3Jlc2l6ZU9ic2VydmVyUG9seWZpbGwyLmRlZmF1bHQocmVzaXplSGFuZGxlcik7XG4gICAgZWxlbWVudC5fX3JvX18ub2JzZXJ2ZShlbGVtZW50KTtcbiAgfVxuICBlbGVtZW50Ll9fcmVzaXplTGlzdGVuZXJzX18ucHVzaChmbik7XG59O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xudmFyIHJlbW92ZVJlc2l6ZUxpc3RlbmVyID0gZXhwb3J0cy5yZW1vdmVSZXNpemVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZVJlc2l6ZUxpc3RlbmVyKGVsZW1lbnQsIGZuKSB7XG4gIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5fX3Jlc2l6ZUxpc3RlbmVyc19fKSByZXR1cm47XG4gIGVsZW1lbnQuX19yZXNpemVMaXN0ZW5lcnNfXy5zcGxpY2UoZWxlbWVudC5fX3Jlc2l6ZUxpc3RlbmVyc19fLmluZGV4T2YoZm4pLCAxKTtcbiAgaWYgKCFlbGVtZW50Ll9fcmVzaXplTGlzdGVuZXJzX18ubGVuZ3RoKSB7XG4gICAgZWxlbWVudC5fX3JvX18uZGlzY29ubmVjdCgpO1xuICB9XG59OyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/element-ui/lib/utils/resize-event.js\n");

/***/ }),

/***/ "./node_modules/element-ui/lib/utils/types.js":
/*!****************************************************!*\
  !*** ./node_modules/element-ui/lib/utils/types.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.isString = isString;\nexports.isObject = isObject;\nexports.isHtmlElement = isHtmlElement;\n\nfunction isString(obj) {\n  return Object.prototype.toString.call(obj) === '[object String]';\n}\n\nfunction isObject(obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n}\n\nfunction isHtmlElement(node) {\n  return node && node.nodeType === Node.ELEMENT_NODE;\n}\n\nvar isFunction = exports.isFunction = function isFunction(functionToCheck) {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n};\n\nvar isUndefined = exports.isUndefined = function isUndefined(val) {\n  return val === void 0;\n};\n\nvar isDefined = exports.isDefined = function isDefined(val) {\n  return val !== undefined && val !== null;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdXRpbHMvdHlwZXMuanM/YTc0MiJdLCJuYW1lcyI6WyJleHBvcnRzIiwiX19lc01vZHVsZSIsImlzU3RyaW5nIiwiaXNPYmplY3QiLCJpc0h0bWxFbGVtZW50Iiwib2JqIiwiT2JqZWN0IiwicHJvdG90eXBlIiwidG9TdHJpbmciLCJjYWxsIiwibm9kZSIsIm5vZGVUeXBlIiwiTm9kZSIsIkVMRU1FTlRfTk9ERSIsImlzRnVuY3Rpb24iLCJmdW5jdGlvblRvQ2hlY2siLCJnZXRUeXBlIiwiaXNVbmRlZmluZWQiLCJ2YWwiLCJpc0RlZmluZWQiLCJ1bmRlZmluZWQiXSwibWFwcGluZ3MiOiJBQUFhOztBQUViQSxPQUFPLENBQUNDLFVBQVIsR0FBcUIsSUFBckI7QUFDQUQsT0FBTyxDQUFDRSxRQUFSLEdBQW1CQSxRQUFuQjtBQUNBRixPQUFPLENBQUNHLFFBQVIsR0FBbUJBLFFBQW5CO0FBQ0FILE9BQU8sQ0FBQ0ksYUFBUixHQUF3QkEsYUFBeEI7O0FBQ0EsU0FBU0YsUUFBVCxDQUFrQkcsR0FBbEIsRUFBdUI7QUFDckIsU0FBT0MsTUFBTSxDQUFDQyxTQUFQLENBQWlCQyxRQUFqQixDQUEwQkMsSUFBMUIsQ0FBK0JKLEdBQS9CLE1BQXdDLGlCQUEvQztBQUNEOztBQUVELFNBQVNGLFFBQVQsQ0FBa0JFLEdBQWxCLEVBQXVCO0FBQ3JCLFNBQU9DLE1BQU0sQ0FBQ0MsU0FBUCxDQUFpQkMsUUFBakIsQ0FBMEJDLElBQTFCLENBQStCSixHQUEvQixNQUF3QyxpQkFBL0M7QUFDRDs7QUFFRCxTQUFTRCxhQUFULENBQXVCTSxJQUF2QixFQUE2QjtBQUMzQixTQUFPQSxJQUFJLElBQUlBLElBQUksQ0FBQ0MsUUFBTCxLQUFrQkMsSUFBSSxDQUFDQyxZQUF0QztBQUNEOztBQUVELElBQUlDLFVBQVUsR0FBR2QsT0FBTyxDQUFDYyxVQUFSLEdBQXFCLFNBQVNBLFVBQVQsQ0FBb0JDLGVBQXBCLEVBQXFDO0FBQ3pFLE1BQUlDLE9BQU8sR0FBRyxFQUFkO0FBQ0EsU0FBT0QsZUFBZSxJQUFJQyxPQUFPLENBQUNSLFFBQVIsQ0FBaUJDLElBQWpCLENBQXNCTSxlQUF0QixNQUEyQyxtQkFBckU7QUFDRCxDQUhEOztBQUtBLElBQUlFLFdBQVcsR0FBR2pCLE9BQU8sQ0FBQ2lCLFdBQVIsR0FBc0IsU0FBU0EsV0FBVCxDQUFxQkMsR0FBckIsRUFBMEI7QUFDaEUsU0FBT0EsR0FBRyxLQUFLLEtBQUssQ0FBcEI7QUFDRCxDQUZEOztBQUlBLElBQUlDLFNBQVMsR0FBR25CLE9BQU8sQ0FBQ21CLFNBQVIsR0FBb0IsU0FBU0EsU0FBVCxDQUFtQkQsR0FBbkIsRUFBd0I7QUFDMUQsU0FBT0EsR0FBRyxLQUFLRSxTQUFSLElBQXFCRixHQUFHLEtBQUssSUFBcEM7QUFDRCxDQUZEIiwiZmlsZSI6Ii4vbm9kZV9tb2R1bGVzL2VsZW1lbnQtdWkvbGliL3V0aWxzL3R5cGVzLmpzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuZXhwb3J0cy5pc0h0bWxFbGVtZW50ID0gaXNIdG1sRWxlbWVudDtcbmZ1bmN0aW9uIGlzU3RyaW5nKG9iaikge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuZnVuY3Rpb24gaXNIdG1sRWxlbWVudChub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFO1xufVxuXG52YXIgaXNGdW5jdGlvbiA9IGV4cG9ydHMuaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24oZnVuY3Rpb25Ub0NoZWNrKSB7XG4gIHZhciBnZXRUeXBlID0ge307XG4gIHJldHVybiBmdW5jdGlvblRvQ2hlY2sgJiYgZ2V0VHlwZS50b1N0cmluZy5jYWxsKGZ1bmN0aW9uVG9DaGVjaykgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG52YXIgaXNVbmRlZmluZWQgPSBleHBvcnRzLmlzVW5kZWZpbmVkID0gZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB2YWwgPT09IHZvaWQgMDtcbn07XG5cbnZhciBpc0RlZmluZWQgPSBleHBvcnRzLmlzRGVmaW5lZCA9IGZ1bmN0aW9uIGlzRGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkICYmIHZhbCAhPT0gbnVsbDtcbn07Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/element-ui/lib/utils/types.js\n");

/***/ }),

/***/ "./node_modules/element-ui/lib/utils/util.js":
/*!***************************************************!*\
  !*** ./node_modules/element-ui/lib/utils/util.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.__esModule = true;\nexports.isEmpty = exports.isEqual = exports.arrayEquals = exports.looseEqual = exports.capitalize = exports.kebabCase = exports.autoprefixer = exports.isFirefox = exports.isEdge = exports.isIE = exports.coerceTruthyValueToArray = exports.arrayFind = exports.arrayFindIndex = exports.escapeRegexpString = exports.valueEquals = exports.generateId = exports.getValueByPath = undefined;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nexports.noop = noop;\nexports.hasOwn = hasOwn;\nexports.toObject = toObject;\nexports.getPropByPath = getPropByPath;\nexports.rafThrottle = rafThrottle;\nexports.objToArray = objToArray;\n\nvar _vue = __webpack_require__(/*! vue */ \"./node_modules/vue/dist/vue.runtime.esm.js\");\n\nvar _vue2 = _interopRequireDefault(_vue);\n\nvar _types = __webpack_require__(/*! element-ui/lib/utils/types */ \"./node_modules/element-ui/lib/utils/types.js\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction noop() {}\n\n;\n\nfunction hasOwn(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\n\n;\n\nfunction extend(to, _from) {\n  for (var key in _from) {\n    to[key] = _from[key];\n  }\n\n  return to;\n}\n\n;\n\nfunction toObject(arr) {\n  var res = {};\n\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i]) {\n      extend(res, arr[i]);\n    }\n  }\n\n  return res;\n}\n\n;\n\nvar getValueByPath = exports.getValueByPath = function getValueByPath(object, prop) {\n  prop = prop || '';\n  var paths = prop.split('.');\n  var current = object;\n  var result = null;\n\n  for (var i = 0, j = paths.length; i < j; i++) {\n    var path = paths[i];\n    if (!current) break;\n\n    if (i === j - 1) {\n      result = current[path];\n      break;\n    }\n\n    current = current[path];\n  }\n\n  return result;\n};\n\nfunction getPropByPath(obj, path, strict) {\n  var tempObj = obj;\n  path = path.replace(/\\[(\\w+)\\]/g, '.$1');\n  path = path.replace(/^\\./, '');\n  var keyArr = path.split('.');\n  var i = 0;\n\n  for (var len = keyArr.length; i < len - 1; ++i) {\n    if (!tempObj && !strict) break;\n    var key = keyArr[i];\n\n    if (key in tempObj) {\n      tempObj = tempObj[key];\n    } else {\n      if (strict) {\n        throw new Error('please transfer a valid prop path to form item!');\n      }\n\n      break;\n    }\n  }\n\n  return {\n    o: tempObj,\n    k: keyArr[i],\n    v: tempObj ? tempObj[keyArr[i]] : null\n  };\n}\n\n;\n\nvar generateId = exports.generateId = function generateId() {\n  return Math.floor(Math.random() * 10000);\n};\n\nvar valueEquals = exports.valueEquals = function valueEquals(a, b) {\n  // see: https://stackoverflow.com/questions/3115982/how-to-check-if-two-arrays-are-equal-with-javascript\n  if (a === b) return true;\n  if (!(a instanceof Array)) return false;\n  if (!(b instanceof Array)) return false;\n  if (a.length !== b.length) return false;\n\n  for (var i = 0; i !== a.length; ++i) {\n    if (a[i] !== b[i]) return false;\n  }\n\n  return true;\n};\n\nvar escapeRegexpString = exports.escapeRegexpString = function escapeRegexpString() {\n  var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n  return String(value).replace(/[|\\\\{}()[\\]^$+*?.]/g, '\\\\$&');\n}; // TODO: use native Array.find, Array.findIndex when IE support is dropped\n\n\nvar arrayFindIndex = exports.arrayFindIndex = function arrayFindIndex(arr, pred) {\n  for (var i = 0; i !== arr.length; ++i) {\n    if (pred(arr[i])) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n\nvar arrayFind = exports.arrayFind = function arrayFind(arr, pred) {\n  var idx = arrayFindIndex(arr, pred);\n  return idx !== -1 ? arr[idx] : undefined;\n}; // coerce truthy value to array\n\n\nvar coerceTruthyValueToArray = exports.coerceTruthyValueToArray = function coerceTruthyValueToArray(val) {\n  if (Array.isArray(val)) {\n    return val;\n  } else if (val) {\n    return [val];\n  } else {\n    return [];\n  }\n};\n\nvar isIE = exports.isIE = function isIE() {\n  return !_vue2.default.prototype.$isServer && !isNaN(Number(document.documentMode));\n};\n\nvar isEdge = exports.isEdge = function isEdge() {\n  return !_vue2.default.prototype.$isServer && navigator.userAgent.indexOf('Edge') > -1;\n};\n\nvar isFirefox = exports.isFirefox = function isFirefox() {\n  return !_vue2.default.prototype.$isServer && !!window.navigator.userAgent.match(/firefox/i);\n};\n\nvar autoprefixer = exports.autoprefixer = function autoprefixer(style) {\n  if ((typeof style === 'undefined' ? 'undefined' : _typeof(style)) !== 'object') return style;\n  var rules = ['transform', 'transition', 'animation'];\n  var prefixes = ['ms-', 'webkit-'];\n  rules.forEach(function (rule) {\n    var value = style[rule];\n\n    if (rule && value) {\n      prefixes.forEach(function (prefix) {\n        style[prefix + rule] = value;\n      });\n    }\n  });\n  return style;\n};\n\nvar kebabCase = exports.kebabCase = function kebabCase(str) {\n  var hyphenateRE = /([^-])([A-Z])/g;\n  return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();\n};\n\nvar capitalize = exports.capitalize = function capitalize(str) {\n  if (!(0, _types.isString)(str)) return str;\n  return str.charAt(0).toUpperCase() + str.slice(1);\n};\n\nvar looseEqual = exports.looseEqual = function looseEqual(a, b) {\n  var isObjectA = (0, _types.isObject)(a);\n  var isObjectB = (0, _types.isObject)(b);\n\n  if (isObjectA && isObjectB) {\n    return JSON.stringify(a) === JSON.stringify(b);\n  } else if (!isObjectA && !isObjectB) {\n    return String(a) === String(b);\n  } else {\n    return false;\n  }\n};\n\nvar arrayEquals = exports.arrayEquals = function arrayEquals(arrayA, arrayB) {\n  arrayA = arrayA || [];\n  arrayB = arrayB || [];\n\n  if (arrayA.length !== arrayB.length) {\n    return false;\n  }\n\n  for (var i = 0; i < arrayA.length; i++) {\n    if (!looseEqual(arrayA[i], arrayB[i])) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar isEqual = exports.isEqual = function isEqual(value1, value2) {\n  if (Array.isArray(value1) && Array.isArray(value2)) {\n    return arrayEquals(value1, value2);\n  }\n\n  return looseEqual(value1, value2);\n};\n\nvar isEmpty = exports.isEmpty = function isEmpty(val) {\n  // null or undefined\n  if (val == null) return true;\n  if (typeof val === 'boolean') return false;\n  if (typeof val === 'number') return !val;\n  if (val instanceof Error) return val.message === '';\n\n  switch (Object.prototype.toString.call(val)) {\n    // String or Array\n    case '[object String]':\n    case '[object Array]':\n      return !val.length;\n    // Map or Set or File\n\n    case '[object File]':\n    case '[object Map]':\n    case '[object Set]':\n      {\n        return !val.size;\n      }\n    // Plain Object\n\n    case '[object Object]':\n      {\n        return !Object.keys(val).length;\n      }\n  }\n\n  return false;\n};\n\nfunction rafThrottle(fn) {\n  var locked = false;\n  return function () {\n    var _this = this;\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (locked) return;\n    locked = true;\n    window.requestAnimationFrame(function (_) {\n      fn.apply(_this, args);\n      locked = false;\n    });\n  };\n}\n\nfunction objToArray(obj) {\n  if (Array.isArray(obj)) {\n    return obj;\n  }\n\n  return isEmpty(obj) ? [] : [obj];\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdXRpbHMvdXRpbC5qcz84MTIyIl0sIm5hbWVzIjpbImV4cG9ydHMiLCJfX2VzTW9kdWxlIiwiaXNFbXB0eSIsImlzRXF1YWwiLCJhcnJheUVxdWFscyIsImxvb3NlRXF1YWwiLCJjYXBpdGFsaXplIiwia2ViYWJDYXNlIiwiYXV0b3ByZWZpeGVyIiwiaXNGaXJlZm94IiwiaXNFZGdlIiwiaXNJRSIsImNvZXJjZVRydXRoeVZhbHVlVG9BcnJheSIsImFycmF5RmluZCIsImFycmF5RmluZEluZGV4IiwiZXNjYXBlUmVnZXhwU3RyaW5nIiwidmFsdWVFcXVhbHMiLCJnZW5lcmF0ZUlkIiwiZ2V0VmFsdWVCeVBhdGgiLCJ1bmRlZmluZWQiLCJfdHlwZW9mIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJvYmoiLCJjb25zdHJ1Y3RvciIsInByb3RvdHlwZSIsIm5vb3AiLCJoYXNPd24iLCJ0b09iamVjdCIsImdldFByb3BCeVBhdGgiLCJyYWZUaHJvdHRsZSIsIm9ialRvQXJyYXkiLCJfdnVlIiwicmVxdWlyZSIsIl92dWUyIiwiX2ludGVyb3BSZXF1aXJlRGVmYXVsdCIsIl90eXBlcyIsImRlZmF1bHQiLCJoYXNPd25Qcm9wZXJ0eSIsIk9iamVjdCIsImtleSIsImNhbGwiLCJleHRlbmQiLCJ0byIsIl9mcm9tIiwiYXJyIiwicmVzIiwiaSIsImxlbmd0aCIsIm9iamVjdCIsInByb3AiLCJwYXRocyIsInNwbGl0IiwiY3VycmVudCIsInJlc3VsdCIsImoiLCJwYXRoIiwic3RyaWN0IiwidGVtcE9iaiIsInJlcGxhY2UiLCJrZXlBcnIiLCJsZW4iLCJFcnJvciIsIm8iLCJrIiwidiIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImEiLCJiIiwiQXJyYXkiLCJ2YWx1ZSIsImFyZ3VtZW50cyIsIlN0cmluZyIsInByZWQiLCJpZHgiLCJ2YWwiLCJpc0FycmF5IiwiJGlzU2VydmVyIiwiaXNOYU4iLCJOdW1iZXIiLCJkb2N1bWVudCIsImRvY3VtZW50TW9kZSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImluZGV4T2YiLCJ3aW5kb3ciLCJtYXRjaCIsInN0eWxlIiwicnVsZXMiLCJwcmVmaXhlcyIsImZvckVhY2giLCJydWxlIiwicHJlZml4Iiwic3RyIiwiaHlwaGVuYXRlUkUiLCJ0b0xvd2VyQ2FzZSIsImlzU3RyaW5nIiwiY2hhckF0IiwidG9VcHBlckNhc2UiLCJzbGljZSIsImlzT2JqZWN0QSIsImlzT2JqZWN0IiwiaXNPYmplY3RCIiwiSlNPTiIsInN0cmluZ2lmeSIsImFycmF5QSIsImFycmF5QiIsInZhbHVlMSIsInZhbHVlMiIsIm1lc3NhZ2UiLCJ0b1N0cmluZyIsInNpemUiLCJrZXlzIiwiZm4iLCJsb2NrZWQiLCJfdGhpcyIsIl9sZW4iLCJhcmdzIiwiX2tleSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsIl8iLCJhcHBseSJdLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWJBLE9BQU8sQ0FBQ0MsVUFBUixHQUFxQixJQUFyQjtBQUNBRCxPQUFPLENBQUNFLE9BQVIsR0FBa0JGLE9BQU8sQ0FBQ0csT0FBUixHQUFrQkgsT0FBTyxDQUFDSSxXQUFSLEdBQXNCSixPQUFPLENBQUNLLFVBQVIsR0FBcUJMLE9BQU8sQ0FBQ00sVUFBUixHQUFxQk4sT0FBTyxDQUFDTyxTQUFSLEdBQW9CUCxPQUFPLENBQUNRLFlBQVIsR0FBdUJSLE9BQU8sQ0FBQ1MsU0FBUixHQUFvQlQsT0FBTyxDQUFDVSxNQUFSLEdBQWlCVixPQUFPLENBQUNXLElBQVIsR0FBZVgsT0FBTyxDQUFDWSx3QkFBUixHQUFtQ1osT0FBTyxDQUFDYSxTQUFSLEdBQW9CYixPQUFPLENBQUNjLGNBQVIsR0FBeUJkLE9BQU8sQ0FBQ2Usa0JBQVIsR0FBNkJmLE9BQU8sQ0FBQ2dCLFdBQVIsR0FBc0JoQixPQUFPLENBQUNpQixVQUFSLEdBQXFCakIsT0FBTyxDQUFDa0IsY0FBUixHQUF5QkMsU0FBcFg7O0FBRUEsSUFBSUMsT0FBTyxHQUFH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QUFLLGlCQUFMO0FBQ0U7QUFDRSxlQUFPLENBQUMxRSxNQUFNLENBQUMyRSxJQUFQLENBQVlyQyxHQUFaLEVBQWlCN0IsTUFBekI7QUFDRDtBQWpCTDs7QUFvQkEsU0FBTyxLQUFQO0FBQ0QsQ0EvQkQ7O0FBaUNBLFNBQVNsQixXQUFULENBQXFCcUYsRUFBckIsRUFBeUI7QUFDdkIsTUFBSUMsTUFBTSxHQUFHLEtBQWI7QUFDQSxTQUFPLFlBQVk7QUFDakIsUUFBSUMsS0FBSyxHQUFHLElBQVo7O0FBRUEsU0FBSyxJQUFJQyxJQUFJLEdBQUc3QyxTQUFTLENBQUN6QixNQUFyQixFQUE2QnVFLElBQUksR0FBR2hELEtBQUssQ0FBQytDLElBQUQsQ0FBekMsRUFBaURFLElBQUksR0FBRyxDQUE3RCxFQUFnRUEsSUFBSSxHQUFHRixJQUF2RSxFQUE2RUUsSUFBSSxFQUFqRixFQUFxRjtBQUNuRkQsVUFBSSxDQUFDQyxJQUFELENBQUosR0FBYS9DLFNBQVMsQ0FBQytDLElBQUQsQ0FBdEI7QUFDRDs7QUFFRCxRQUFJSixNQUFKLEVBQVk7QUFDWkEsVUFBTSxHQUFHLElBQVQ7QUFDQTdCLFVBQU0sQ0FBQ2tDLHFCQUFQLENBQTZCLFVBQVVDLENBQVYsRUFBYTtBQUN4Q1AsUUFBRSxDQUFDUSxLQUFILENBQVNOLEtBQVQsRUFBZ0JFLElBQWhCO0FBQ0FILFlBQU0sR0FBRyxLQUFUO0FBQ0QsS0FIRDtBQUlELEdBYkQ7QUFjRDs7QUFFRCxTQUFTckYsVUFBVCxDQUFvQlIsR0FBcEIsRUFBeUI7QUFDdkIsTUFBSWdELEtBQUssQ0FBQ08sT0FBTixDQUFjdkQsR0FBZCxDQUFKLEVBQXdCO0FBQ3RCLFdBQU9BLEdBQVA7QUFDRDs7QUFDRCxTQUFPckIsT0FBTyxDQUFDcUIsR0FBRCxDQUFQLEdBQWUsRUFBZixHQUFvQixDQUFDQSxHQUFELENBQTNCO0FBQ0QiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWxlbWVudC11aS9saWIvdXRpbHMvdXRpbC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuaXNFbXB0eSA9IGV4cG9ydHMuaXNFcXVhbCA9IGV4cG9ydHMuYXJyYXlFcXVhbHMgPSBleHBvcnRzLmxvb3NlRXF1YWwgPSBleHBvcnRzLmNhcGl0YWxpemUgPSBleHBvcnRzLmtlYmFiQ2FzZSA9IGV4cG9ydHMuYXV0b3ByZWZpeGVyID0gZXhwb3J0cy5pc0ZpcmVmb3ggPSBleHBvcnRzLmlzRWRnZSA9IGV4cG9ydHMuaXNJRSA9IGV4cG9ydHMuY29lcmNlVHJ1dGh5VmFsdWVUb0FycmF5ID0gZXhwb3J0cy5hcnJheUZpbmQgPSBleHBvcnRzLmFycmF5RmluZEluZGV4ID0gZXhwb3J0cy5lc2NhcGVSZWdleHBTdHJpbmcgPSBleHBvcnRzLnZhbHVlRXF1YWxzID0gZXhwb3J0cy5nZW5lcmF0ZUlkID0gZXhwb3J0cy5nZXRWYWx1ZUJ5UGF0aCA9IHVuZGVmaW5lZDtcblxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqOyB9O1xuXG5leHBvcnRzLm5vb3AgPSBub29wO1xuZXhwb3J0cy5oYXNPd24gPSBoYXNPd247XG5leHBvcnRzLnRvT2JqZWN0ID0gdG9PYmplY3Q7XG5leHBvcnRzLmdldFByb3BCeVBhdGggPSBnZXRQcm9wQnlQYXRoO1xuZXhwb3J0cy5yYWZUaHJvdHRsZSA9IHJhZlRocm90dGxlO1xuZXhwb3J0cy5vYmpUb0FycmF5ID0gb2JqVG9BcnJheTtcblxudmFyIF92dWUgPSByZXF1aXJlKCd2dWUnKTtcblxudmFyIF92dWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdnVlKTtcblxudmFyIF90eXBlcyA9IHJlcXVpcmUoJ2VsZW1lbnQtdWkvbGliL3V0aWxzL3R5cGVzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fTtcblxuZnVuY3Rpb24gaGFzT3duKG9iaiwga2V5KSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KTtcbn07XG5cbmZ1bmN0aW9uIGV4dGVuZCh0bywgX2Zyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcblxuZnVuY3Rpb24gdG9PYmplY3QoYXJyKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoYXJyW2ldKSB7XG4gICAgICBleHRlbmQocmVzLCBhcnJbaV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxudmFyIGdldFZhbHVlQnlQYXRoID0gZXhwb3J0cy5nZXRWYWx1ZUJ5UGF0aCA9IGZ1bmN0aW9uIGdldFZhbHVlQnlQYXRoKG9iamVjdCwgcHJvcCkge1xuICBwcm9wID0gcHJvcCB8fCAnJztcbiAgdmFyIHBhdGhzID0gcHJvcC5zcGxpdCgnLicpO1xuICB2YXIgY3VycmVudCA9IG9iamVjdDtcbiAgdmFyIHJlc3VsdCA9IG51bGw7XG4gIGZvciAodmFyIGkgPSAwLCBqID0gcGF0aHMubGVuZ3RoOyBpIDwgajsgaSsrKSB7XG4gICAgdmFyIHBhdGggPSBwYXRoc1tpXTtcbiAgICBpZiAoIWN1cnJlbnQpIGJyZWFrO1xuXG4gICAgaWYgKGkgPT09IGogLSAxKSB7XG4gICAgICByZXN1bHQgPSBjdXJyZW50W3BhdGhdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGN1cnJlbnQgPSBjdXJyZW50W3BhdGhdO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5mdW5jdGlvbiBnZXRQcm9wQnlQYXRoKG9iaiwgcGF0aCwgc3RyaWN0KSB7XG4gIHZhciB0ZW1wT2JqID0gb2JqO1xuICBwYXRoID0gcGF0aC5yZXBsYWNlKC9cXFsoXFx3KylcXF0vZywgJy4kMScpO1xuICBwYXRoID0gcGF0aC5yZXBsYWNlKC9eXFwuLywgJycpO1xuXG4gIHZhciBrZXlBcnIgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHZhciBpID0gMDtcbiAgZm9yICh2YXIgbGVuID0ga2V5QXJyLmxlbmd0aDsgaSA8IGxlbiAtIDE7ICsraSkge1xuICAgIGlmICghdGVtcE9iaiAmJiAhc3RyaWN0KSBicmVhaztcbiAgICB2YXIga2V5ID0ga2V5QXJyW2ldO1xuICAgIGlmIChrZXkgaW4gdGVtcE9iaikge1xuICAgICAgdGVtcE9iaiA9IHRlbXBPYmpba2V5XTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BsZWFzZSB0cmFuc2ZlciBhIHZhbGlkIHByb3AgcGF0aCB0byBmb3JtIGl0ZW0hJyk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBvOiB0ZW1wT2JqLFxuICAgIGs6IGtleUFycltpXSxcbiAgICB2OiB0ZW1wT2JqID8gdGVtcE9ialtrZXlBcnJbaV1dIDogbnVsbFxuICB9O1xufTtcblxudmFyIGdlbmVyYXRlSWQgPSBleHBvcnRzLmdlbmVyYXRlSWQgPSBmdW5jdGlvbiBnZW5lcmF0ZUlkKCkge1xuICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApO1xufTtcblxudmFyIHZhbHVlRXF1YWxzID0gZXhwb3J0cy52YWx1ZUVxdWFscyA9IGZ1bmN0aW9uIHZhbHVlRXF1YWxzKGEsIGIpIHtcbiAgLy8gc2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zMTE1OTgyL2hvdy10by1jaGVjay1pZi10d28tYXJyYXlzLWFyZS1lcXVhbC13aXRoLWphdmFzY3JpcHRcbiAgaWYgKGEgPT09IGIpIHJldHVybiB0cnVlO1xuICBpZiAoIShhIGluc3RhbmNlb2YgQXJyYXkpKSByZXR1cm4gZmFsc2U7XG4gIGlmICghKGIgaW5zdGFuY2VvZiBBcnJheSkpIHJldHVybiBmYWxzZTtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKHZhciBpID0gMDsgaSAhPT0gYS5sZW5ndGg7ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgZXNjYXBlUmVnZXhwU3RyaW5nID0gZXhwb3J0cy5lc2NhcGVSZWdleHBTdHJpbmcgPSBmdW5jdGlvbiBlc2NhcGVSZWdleHBTdHJpbmcoKSB7XG4gIHZhciB2YWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG4gIHJldHVybiBTdHJpbmcodmFsdWUpLnJlcGxhY2UoL1t8XFxcXHt9KClbXFxdXiQrKj8uXS9nLCAnXFxcXCQmJyk7XG59O1xuXG4vLyBUT0RPOiB1c2UgbmF0aXZlIEFycmF5LmZpbmQsIEFycmF5LmZpbmRJbmRleCB3aGVuIElFIHN1cHBvcnQgaXMgZHJvcHBlZFxudmFyIGFycmF5RmluZEluZGV4ID0gZXhwb3J0cy5hcnJheUZpbmRJbmRleCA9IGZ1bmN0aW9uIGFycmF5RmluZEluZGV4KGFyciwgcHJlZCkge1xuICBmb3IgKHZhciBpID0gMDsgaSAhPT0gYXJyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHByZWQoYXJyW2ldKSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn07XG5cbnZhciBhcnJheUZpbmQgPSBleHBvcnRzLmFycmF5RmluZCA9IGZ1bmN0aW9uIGFycmF5RmluZChhcnIsIHByZWQpIHtcbiAgdmFyIGlkeCA9IGFycmF5RmluZEluZGV4KGFyciwgcHJlZCk7XG4gIHJldHVybiBpZHggIT09IC0xID8gYXJyW2lkeF0gOiB1bmRlZmluZWQ7XG59O1xuXG4vLyBjb2VyY2UgdHJ1dGh5IHZhbHVlIHRvIGFycmF5XG52YXIgY29lcmNlVHJ1dGh5VmFsdWVUb0FycmF5ID0gZXhwb3J0cy5jb2VyY2VUcnV0aHlWYWx1ZVRvQXJyYXkgPSBmdW5jdGlvbiBjb2VyY2VUcnV0aHlWYWx1ZVRvQXJyYXkodmFsKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9IGVsc2UgaWYgKHZhbCkge1xuICAgIHJldHVybiBbdmFsXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn07XG5cbnZhciBpc0lFID0gZXhwb3J0cy5pc0lFID0gZnVuY3Rpb24gaXNJRSgpIHtcbiAgcmV0dXJuICFfdnVlMi5kZWZhdWx0LnByb3RvdHlwZS4kaXNTZXJ2ZXIgJiYgIWlzTmFOKE51bWJlcihkb2N1bWVudC5kb2N1bWVudE1vZGUpKTtcbn07XG5cbnZhciBpc0VkZ2UgPSBleHBvcnRzLmlzRWRnZSA9IGZ1bmN0aW9uIGlzRWRnZSgpIHtcbiAgcmV0dXJuICFfdnVlMi5kZWZhdWx0LnByb3RvdHlwZS4kaXNTZXJ2ZXIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdFZGdlJykgPiAtMTtcbn07XG5cbnZhciBpc0ZpcmVmb3ggPSBleHBvcnRzLmlzRmlyZWZveCA9IGZ1bmN0aW9uIGlzRmlyZWZveCgpIHtcbiAgcmV0dXJuICFfdnVlMi5kZWZhdWx0LnByb3RvdHlwZS4kaXNTZXJ2ZXIgJiYgISF3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvZmlyZWZveC9pKTtcbn07XG5cbnZhciBhdXRvcHJlZml4ZXIgPSBleHBvcnRzLmF1dG9wcmVmaXhlciA9IGZ1bmN0aW9uIGF1dG9wcmVmaXhlcihzdHlsZSkge1xuICBpZiAoKHR5cGVvZiBzdHlsZSA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yoc3R5bGUpKSAhPT0gJ29iamVjdCcpIHJldHVybiBzdHlsZTtcbiAgdmFyIHJ1bGVzID0gWyd0cmFuc2Zvcm0nLCAndHJhbnNpdGlvbicsICdhbmltYXRpb24nXTtcbiAgdmFyIHByZWZpeGVzID0gWydtcy0nLCAnd2Via2l0LSddO1xuICBydWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChydWxlKSB7XG4gICAgdmFyIHZhbHVlID0gc3R5bGVbcnVsZV07XG4gICAgaWYgKHJ1bGUgJiYgdmFsdWUpIHtcbiAgICAgIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgICAgICBzdHlsZVtwcmVmaXggKyBydWxlXSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHN0eWxlO1xufTtcblxudmFyIGtlYmFiQ2FzZSA9IGV4cG9ydHMua2ViYWJDYXNlID0gZnVuY3Rpb24ga2ViYWJDYXNlKHN0cikge1xuICB2YXIgaHlwaGVuYXRlUkUgPSAvKFteLV0pKFtBLVpdKS9nO1xuICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpLnJlcGxhY2UoaHlwaGVuYXRlUkUsICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG59O1xuXG52YXIgY2FwaXRhbGl6ZSA9IGV4cG9ydHMuY2FwaXRhbGl6ZSA9IGZ1bmN0aW9uIGNhcGl0YWxpemUoc3RyKSB7XG4gIGlmICghKDAsIF90eXBlcy5pc1N0cmluZykoc3RyKSkgcmV0dXJuIHN0cjtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKTtcbn07XG5cbnZhciBsb29zZUVxdWFsID0gZXhwb3J0cy5sb29zZUVxdWFsID0gZnVuY3Rpb24gbG9vc2VFcXVhbChhLCBiKSB7XG4gIHZhciBpc09iamVjdEEgPSAoMCwgX3R5cGVzLmlzT2JqZWN0KShhKTtcbiAgdmFyIGlzT2JqZWN0QiA9ICgwLCBfdHlwZXMuaXNPYmplY3QpKGIpO1xuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShhKSA9PT0gSlNPTi5zdHJpbmdpZnkoYik7XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyIGFycmF5RXF1YWxzID0gZXhwb3J0cy5hcnJheUVxdWFscyA9IGZ1bmN0aW9uIGFycmF5RXF1YWxzKGFycmF5QSwgYXJyYXlCKSB7XG4gIGFycmF5QSA9IGFycmF5QSB8fCBbXTtcbiAgYXJyYXlCID0gYXJyYXlCIHx8IFtdO1xuXG4gIGlmIChhcnJheUEubGVuZ3RoICE9PSBhcnJheUIubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheUEubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWxvb3NlRXF1YWwoYXJyYXlBW2ldLCBhcnJheUJbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgaXNFcXVhbCA9IGV4cG9ydHMuaXNFcXVhbCA9IGZ1bmN0aW9uIGlzRXF1YWwodmFsdWUxLCB2YWx1ZTIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUxKSAmJiBBcnJheS5pc0FycmF5KHZhbHVlMikpIHtcbiAgICByZXR1cm4gYXJyYXlFcXVhbHModmFsdWUxLCB2YWx1ZTIpO1xuICB9XG4gIHJldHVybiBsb29zZUVxdWFsKHZhbHVlMSwgdmFsdWUyKTtcbn07XG5cbnZhciBpc0VtcHR5ID0gZXhwb3J0cy5pc0VtcHR5ID0gZnVuY3Rpb24gaXNFbXB0eSh2YWwpIHtcbiAgLy8gbnVsbCBvciB1bmRlZmluZWRcbiAgaWYgKHZhbCA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcblxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSByZXR1cm4gIXZhbDtcblxuICBpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiB2YWwubWVzc2FnZSA9PT0gJyc7XG5cbiAgc3dpdGNoIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsKSkge1xuICAgIC8vIFN0cmluZyBvciBBcnJheVxuICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgY2FzZSAnW29iamVjdCBBcnJheV0nOlxuICAgICAgcmV0dXJuICF2YWwubGVuZ3RoO1xuXG4gICAgLy8gTWFwIG9yIFNldCBvciBGaWxlXG4gICAgY2FzZSAnW29iamVjdCBGaWxlXSc6XG4gICAgY2FzZSAnW29iamVjdCBNYXBdJzpcbiAgICBjYXNlICdbb2JqZWN0IFNldF0nOlxuICAgICAge1xuICAgICAgICByZXR1cm4gIXZhbC5zaXplO1xuICAgICAgfVxuICAgIC8vIFBsYWluIE9iamVjdFxuICAgIGNhc2UgJ1tvYmplY3QgT2JqZWN0XSc6XG4gICAgICB7XG4gICAgICAgIHJldHVybiAhT2JqZWN0LmtleXModmFsKS5sZW5ndGg7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiByYWZUaHJvdHRsZShmbikge1xuICB2YXIgbG9ja2VkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIGlmIChsb2NrZWQpIHJldHVybjtcbiAgICBsb2NrZWQgPSB0cnVlO1xuICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKF8pIHtcbiAgICAgIGZuLmFwcGx5KF90aGlzLCBhcmdzKTtcbiAgICAgIGxvY2tlZCA9IGZhbHNlO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvYmpUb0FycmF5KG9iaikge1xuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgcmV0dXJuIG9iajtcbiAgfVxuICByZXR1cm4gaXNFbXB0eShvYmopID8gW10gOiBbb2JqXTtcbn0iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/element-ui/lib/utils/util.js\n");

/***/ }),

/***/ "./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js":
/*!*************************************************************************!*\
  !*** ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/**\r\n * A collection of shims that provide minimal functionality of the ES6 collections.\r\n *\r\n * These implementations are not meant to be used outside of the ResizeObserver\r\n * modules as they cover only a limited range of use cases.\r\n */\n\n/* eslint-disable require-jsdoc, valid-jsdoc */\nvar MapShim = function () {\n  if (typeof Map !== 'undefined') {\n    return Map;\n  }\n  /**\r\n   * Returns index in provided array that matches the specified key.\r\n   *\r\n   * @param {Array<Array>} arr\r\n   * @param {*} key\r\n   * @returns {number}\r\n   */\n\n\n  function getIndex(arr, key) {\n    var result = -1;\n    arr.some(function (entry, index) {\n      if (entry[0] === key) {\n        result = index;\n        return true;\n      }\n\n      return false;\n    });\n    return result;\n  }\n\n  return (\n    /** @class */\n    function () {\n      function class_1() {\n        this.__entries__ = [];\n      }\n\n      Object.defineProperty(class_1.prototype, \"size\", {\n        /**\r\n         * @returns {boolean}\r\n         */\n        get: function () {\n          return this.__entries__.length;\n        },\n        enumerable: true,\n        configurable: true\n      });\n      /**\r\n       * @param {*} key\r\n       * @returns {*}\r\n       */\n\n      class_1.prototype.get = function (key) {\n        var index = getIndex(this.__entries__, key);\n        var entry = this.__entries__[index];\n        return entry && entry[1];\n      };\n      /**\r\n       * @param {*} key\r\n       * @param {*} value\r\n       * @returns {void}\r\n       */\n\n\n      class_1.prototype.set = function (key, value) {\n        var index = getIndex(this.__entries__, key);\n\n        if (~index) {\n          this.__entries__[index][1] = value;\n        } else {\n          this.__entries__.push([key, value]);\n        }\n      };\n      /**\r\n       * @param {*} key\r\n       * @returns {void}\r\n       */\n\n\n      class_1.prototype.delete = function (key) {\n        var entries = this.__entries__;\n        var index = getIndex(entries, key);\n\n        if (~index) {\n          entries.splice(index, 1);\n        }\n      };\n      /**\r\n       * @param {*} key\r\n       * @returns {void}\r\n       */\n\n\n      class_1.prototype.has = function (key) {\n        return !!~getIndex(this.__entries__, key);\n      };\n      /**\r\n       * @returns {void}\r\n       */\n\n\n      class_1.prototype.clear = function () {\n        this.__entries__.splice(0);\n      };\n      /**\r\n       * @param {Function} callback\r\n       * @param {*} [ctx=null]\r\n       * @returns {void}\r\n       */\n\n\n      class_1.prototype.forEach = function (callback, ctx) {\n        if (ctx === void 0) {\n          ctx = null;\n        }\n\n        for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {\n          var entry = _a[_i];\n          callback.call(ctx, entry[1], entry[0]);\n        }\n      };\n\n      return class_1;\n    }()\n  );\n}();\n/**\r\n * Detects whether window and document objects are available in current environment.\r\n */\n\n\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document; // Returns global object of a current environment.\n\nvar global$1 = function () {\n  if (typeof global !== 'undefined' && global.Math === Math) {\n    return global;\n  }\n\n  if (typeof self !== 'undefined' && self.Math === Math) {\n    return self;\n  }\n\n  if (typeof window !== 'undefined' && window.Math === Math) {\n    return window;\n  } // eslint-disable-next-line no-new-func\n\n\n  return Function('return this')();\n}();\n/**\r\n * A shim for the requestAnimationFrame which falls back to the setTimeout if\r\n * first one is not supported.\r\n *\r\n * @returns {number} Requests' identifier.\r\n */\n\n\nvar requestAnimationFrame$1 = function () {\n  if (typeof requestAnimationFrame === 'function') {\n    // It's required to use a bounded function because IE sometimes throws\n    // an \"Invalid calling object\" error if rAF is invoked without the global\n    // object on the left hand side.\n    return requestAnimationFrame.bind(global$1);\n  }\n\n  return function (callback) {\n    return setTimeout(function () {\n      return callback(Date.now());\n    }, 1000 / 60);\n  };\n}(); // Defines minimum timeout before adding a trailing call.\n\n\nvar trailingTimeout = 2;\n/**\r\n * Creates a wrapper function which ensures that provided callback will be\r\n * invoked only once during the specified delay period.\r\n *\r\n * @param {Function} callback - Function to be invoked after the delay period.\r\n * @param {number} delay - Delay after which to invoke callback.\r\n * @returns {Function}\r\n */\n\nfunction throttle(callback, delay) {\n  var leadingCall = false,\n      trailingCall = false,\n      lastCallTime = 0;\n  /**\r\n   * Invokes the original callback function and schedules new invocation if\r\n   * the \"proxy\" was called during current request.\r\n   *\r\n   * @returns {void}\r\n   */\n\n  function resolvePending() {\n    if (leadingCall) {\n      leadingCall = false;\n      callback();\n    }\n\n    if (trailingCall) {\n      proxy();\n    }\n  }\n  /**\r\n   * Callback invoked after the specified delay. It will further postpone\r\n   * invocation of the original function delegating it to the\r\n   * requestAnimationFrame.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  function timeoutCallback() {\n    requestAnimationFrame$1(resolvePending);\n  }\n  /**\r\n   * Schedules invocation of the original function.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  function proxy() {\n    var timeStamp = Date.now();\n\n    if (leadingCall) {\n      // Reject immediately following calls.\n      if (timeStamp - lastCallTime < trailingTimeout) {\n        return;\n      } // Schedule new call to be in invoked when the pending one is resolved.\n      // This is important for \"transitions\" which never actually start\n      // immediately so there is a chance that we might miss one if change\n      // happens amids the pending invocation.\n\n\n      trailingCall = true;\n    } else {\n      leadingCall = true;\n      trailingCall = false;\n      setTimeout(timeoutCallback, delay);\n    }\n\n    lastCallTime = timeStamp;\n  }\n\n  return proxy;\n} // Minimum delay before invoking the update of observers.\n\n\nvar REFRESH_DELAY = 20; // A list of substrings of CSS properties used to find transition events that\n// might affect dimensions of observed elements.\n\nvar transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight']; // Check if MutationObserver is available.\n\nvar mutationObserverSupported = typeof MutationObserver !== 'undefined';\n/**\r\n * Singleton controller class which handles updates of ResizeObserver instances.\r\n */\n\nvar ResizeObserverController =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance of ResizeObserverController.\r\n   *\r\n   * @private\r\n   */\n  function ResizeObserverController() {\n    /**\r\n     * Indicates whether DOM listeners have been added.\r\n     *\r\n     * @private {boolean}\r\n     */\n    this.connected_ = false;\n    /**\r\n     * Tells that controller has subscribed for Mutation Events.\r\n     *\r\n     * @private {boolean}\r\n     */\n\n    this.mutationEventsAdded_ = false;\n    /**\r\n     * Keeps reference to the instance of MutationObserver.\r\n     *\r\n     * @private {MutationObserver}\r\n     */\n\n    this.mutationsObserver_ = null;\n    /**\r\n     * A list of connected observers.\r\n     *\r\n     * @private {Array<ResizeObserverSPI>}\r\n     */\n\n    this.observers_ = [];\n    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);\n    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);\n  }\n  /**\r\n   * Adds observer to observers list.\r\n   *\r\n   * @param {ResizeObserverSPI} observer - Observer to be added.\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverController.prototype.addObserver = function (observer) {\n    if (!~this.observers_.indexOf(observer)) {\n      this.observers_.push(observer);\n    } // Add listeners if they haven't been added yet.\n\n\n    if (!this.connected_) {\n      this.connect_();\n    }\n  };\n  /**\r\n   * Removes observer from observers list.\r\n   *\r\n   * @param {ResizeObserverSPI} observer - Observer to be removed.\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverController.prototype.removeObserver = function (observer) {\n    var observers = this.observers_;\n    var index = observers.indexOf(observer); // Remove observer if it's present in registry.\n\n    if (~index) {\n      observers.splice(index, 1);\n    } // Remove listeners if controller has no connected observers.\n\n\n    if (!observers.length && this.connected_) {\n      this.disconnect_();\n    }\n  };\n  /**\r\n   * Invokes the update of observers. It will continue running updates insofar\r\n   * it detects changes.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverController.prototype.refresh = function () {\n    var changesDetected = this.updateObservers_(); // Continue running updates if changes have been detected as there might\n    // be future ones caused by CSS transitions.\n\n    if (changesDetected) {\n      this.refresh();\n    }\n  };\n  /**\r\n   * Updates every observer from observers list and notifies them of queued\r\n   * entries.\r\n   *\r\n   * @private\r\n   * @returns {boolean} Returns \"true\" if any observer has detected changes in\r\n   *      dimensions of it's elements.\r\n   */\n\n\n  ResizeObserverController.prototype.updateObservers_ = function () {\n    // Collect observers that have active observations.\n    var activeObservers = this.observers_.filter(function (observer) {\n      return observer.gatherActive(), observer.hasActive();\n    }); // Deliver notifications in a separate cycle in order to avoid any\n    // collisions between observers, e.g. when multiple instances of\n    // ResizeObserver are tracking the same element and the callback of one\n    // of them changes content dimensions of the observed target. Sometimes\n    // this may result in notifications being blocked for the rest of observers.\n\n    activeObservers.forEach(function (observer) {\n      return observer.broadcastActive();\n    });\n    return activeObservers.length > 0;\n  };\n  /**\r\n   * Initializes DOM listeners.\r\n   *\r\n   * @private\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverController.prototype.connect_ = function () {\n    // Do nothing if running in a non-browser environment or if listeners\n    // have been already added.\n    if (!isBrowser || this.connected_) {\n      return;\n    } // Subscription to the \"Transitionend\" event is used as a workaround for\n    // delayed transitions. This way it's possible to capture at least the\n    // final state of an element.\n\n\n    document.addEventListener('transitionend', this.onTransitionEnd_);\n    window.addEventListener('resize', this.refresh);\n\n    if (mutationObserverSupported) {\n      this.mutationsObserver_ = new MutationObserver(this.refresh);\n      this.mutationsObserver_.observe(document, {\n        attributes: true,\n        childList: true,\n        characterData: true,\n        subtree: true\n      });\n    } else {\n      document.addEventListener('DOMSubtreeModified', this.refresh);\n      this.mutationEventsAdded_ = true;\n    }\n\n    this.connected_ = true;\n  };\n  /**\r\n   * Removes DOM listeners.\r\n   *\r\n   * @private\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverController.prototype.disconnect_ = function () {\n    // Do nothing if running in a non-browser environment or if listeners\n    // have been already removed.\n    if (!isBrowser || !this.connected_) {\n      return;\n    }\n\n    document.removeEventListener('transitionend', this.onTransitionEnd_);\n    window.removeEventListener('resize', this.refresh);\n\n    if (this.mutationsObserver_) {\n      this.mutationsObserver_.disconnect();\n    }\n\n    if (this.mutationEventsAdded_) {\n      document.removeEventListener('DOMSubtreeModified', this.refresh);\n    }\n\n    this.mutationsObserver_ = null;\n    this.mutationEventsAdded_ = false;\n    this.connected_ = false;\n  };\n  /**\r\n   * \"Transitionend\" event handler.\r\n   *\r\n   * @private\r\n   * @param {TransitionEvent} event\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {\n    var _b = _a.propertyName,\n        propertyName = _b === void 0 ? '' : _b; // Detect whether transition may affect dimensions of an element.\n\n    var isReflowProperty = transitionKeys.some(function (key) {\n      return !!~propertyName.indexOf(key);\n    });\n\n    if (isReflowProperty) {\n      this.refresh();\n    }\n  };\n  /**\r\n   * Returns instance of the ResizeObserverController.\r\n   *\r\n   * @returns {ResizeObserverController}\r\n   */\n\n\n  ResizeObserverController.getInstance = function () {\n    if (!this.instance_) {\n      this.instance_ = new ResizeObserverController();\n    }\n\n    return this.instance_;\n  };\n  /**\r\n   * Holds reference to the controller's instance.\r\n   *\r\n   * @private {ResizeObserverController}\r\n   */\n\n\n  ResizeObserverController.instance_ = null;\n  return ResizeObserverController;\n}();\n/**\r\n * Defines non-writable/enumerable properties of the provided target object.\r\n *\r\n * @param {Object} target - Object for which to define properties.\r\n * @param {Object} props - Properties to be defined.\r\n * @returns {Object} Target object.\r\n */\n\n\nvar defineConfigurable = function (target, props) {\n  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {\n    var key = _a[_i];\n    Object.defineProperty(target, key, {\n      value: props[key],\n      enumerable: false,\n      writable: false,\n      configurable: true\n    });\n  }\n\n  return target;\n};\n/**\r\n * Returns the global object associated with provided element.\r\n *\r\n * @param {Object} target\r\n * @returns {Object}\r\n */\n\n\nvar getWindowOf = function (target) {\n  // Assume that the element is an instance of Node, which means that it\n  // has the \"ownerDocument\" property from which we can retrieve a\n  // corresponding global object.\n  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView; // Return the local global object if it's not possible extract one from\n  // provided element.\n\n  return ownerGlobal || global$1;\n}; // Placeholder of an empty content rectangle.\n\n\nvar emptyRect = createRectInit(0, 0, 0, 0);\n/**\r\n * Converts provided string to a number.\r\n *\r\n * @param {number|string} value\r\n * @returns {number}\r\n */\n\nfunction toFloat(value) {\n  return parseFloat(value) || 0;\n}\n/**\r\n * Extracts borders size from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @param {...string} positions - Borders positions (top, right, ...)\r\n * @returns {number}\r\n */\n\n\nfunction getBordersSize(styles) {\n  var positions = [];\n\n  for (var _i = 1; _i < arguments.length; _i++) {\n    positions[_i - 1] = arguments[_i];\n  }\n\n  return positions.reduce(function (size, position) {\n    var value = styles['border-' + position + '-width'];\n    return size + toFloat(value);\n  }, 0);\n}\n/**\r\n * Extracts paddings sizes from provided styles.\r\n *\r\n * @param {CSSStyleDeclaration} styles\r\n * @returns {Object} Paddings box.\r\n */\n\n\nfunction getPaddings(styles) {\n  var positions = ['top', 'right', 'bottom', 'left'];\n  var paddings = {};\n\n  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {\n    var position = positions_1[_i];\n    var value = styles['padding-' + position];\n    paddings[position] = toFloat(value);\n  }\n\n  return paddings;\n}\n/**\r\n * Calculates content rectangle of provided SVG element.\r\n *\r\n * @param {SVGGraphicsElement} target - Element content rectangle of which needs\r\n *      to be calculated.\r\n * @returns {DOMRectInit}\r\n */\n\n\nfunction getSVGContentRect(target) {\n  var bbox = target.getBBox();\n  return createRectInit(0, 0, bbox.width, bbox.height);\n}\n/**\r\n * Calculates content rectangle of provided HTMLElement.\r\n *\r\n * @param {HTMLElement} target - Element for which to calculate the content rectangle.\r\n * @returns {DOMRectInit}\r\n */\n\n\nfunction getHTMLElementContentRect(target) {\n  // Client width & height properties can't be\n  // used exclusively as they provide rounded values.\n  var clientWidth = target.clientWidth,\n      clientHeight = target.clientHeight; // By this condition we can catch all non-replaced inline, hidden and\n  // detached elements. Though elements with width & height properties less\n  // than 0.5 will be discarded as well.\n  //\n  // Without it we would need to implement separate methods for each of\n  // those cases and it's not possible to perform a precise and performance\n  // effective test for hidden elements. E.g. even jQuery's ':visible' filter\n  // gives wrong results for elements with width & height less than 0.5.\n\n  if (!clientWidth && !clientHeight) {\n    return emptyRect;\n  }\n\n  var styles = getWindowOf(target).getComputedStyle(target);\n  var paddings = getPaddings(styles);\n  var horizPad = paddings.left + paddings.right;\n  var vertPad = paddings.top + paddings.bottom; // Computed styles of width & height are being used because they are the\n  // only dimensions available to JS that contain non-rounded values. It could\n  // be possible to utilize the getBoundingClientRect if only it's data wasn't\n  // affected by CSS transformations let alone paddings, borders and scroll bars.\n\n  var width = toFloat(styles.width),\n      height = toFloat(styles.height); // Width & height include paddings and borders when the 'border-box' box\n  // model is applied (except for IE).\n\n  if (styles.boxSizing === 'border-box') {\n    // Following conditions are required to handle Internet Explorer which\n    // doesn't include paddings and borders to computed CSS dimensions.\n    //\n    // We can say that if CSS dimensions + paddings are equal to the \"client\"\n    // properties then it's either IE, and thus we don't need to subtract\n    // anything, or an element merely doesn't have paddings/borders styles.\n    if (Math.round(width + horizPad) !== clientWidth) {\n      width -= getBordersSize(styles, 'left', 'right') + horizPad;\n    }\n\n    if (Math.round(height + vertPad) !== clientHeight) {\n      height -= getBordersSize(styles, 'top', 'bottom') + vertPad;\n    }\n  } // Following steps can't be applied to the document's root element as its\n  // client[Width/Height] properties represent viewport area of the window.\n  // Besides, it's as well not necessary as the <html> itself neither has\n  // rendered scroll bars nor it can be clipped.\n\n\n  if (!isDocumentElement(target)) {\n    // In some browsers (only in Firefox, actually) CSS width & height\n    // include scroll bars size which can be removed at this step as scroll\n    // bars are the only difference between rounded dimensions + paddings\n    // and \"client\" properties, though that is not always true in Chrome.\n    var vertScrollbar = Math.round(width + horizPad) - clientWidth;\n    var horizScrollbar = Math.round(height + vertPad) - clientHeight; // Chrome has a rather weird rounding of \"client\" properties.\n    // E.g. for an element with content width of 314.2px it sometimes gives\n    // the client width of 315px and for the width of 314.7px it may give\n    // 314px. And it doesn't happen all the time. So just ignore this delta\n    // as a non-relevant.\n\n    if (Math.abs(vertScrollbar) !== 1) {\n      width -= vertScrollbar;\n    }\n\n    if (Math.abs(horizScrollbar) !== 1) {\n      height -= horizScrollbar;\n    }\n  }\n\n  return createRectInit(paddings.left, paddings.top, width, height);\n}\n/**\r\n * Checks whether provided element is an instance of the SVGGraphicsElement.\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\n\n\nvar isSVGGraphicsElement = function () {\n  // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement\n  // interface.\n  if (typeof SVGGraphicsElement !== 'undefined') {\n    return function (target) {\n      return target instanceof getWindowOf(target).SVGGraphicsElement;\n    };\n  } // If it's so, then check that element is at least an instance of the\n  // SVGElement and that it has the \"getBBox\" method.\n  // eslint-disable-next-line no-extra-parens\n\n\n  return function (target) {\n    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function';\n  };\n}();\n/**\r\n * Checks whether provided element is a document element (<html>).\r\n *\r\n * @param {Element} target - Element to be checked.\r\n * @returns {boolean}\r\n */\n\n\nfunction isDocumentElement(target) {\n  return target === getWindowOf(target).document.documentElement;\n}\n/**\r\n * Calculates an appropriate content rectangle for provided html or svg element.\r\n *\r\n * @param {Element} target - Element content rectangle of which needs to be calculated.\r\n * @returns {DOMRectInit}\r\n */\n\n\nfunction getContentRect(target) {\n  if (!isBrowser) {\n    return emptyRect;\n  }\n\n  if (isSVGGraphicsElement(target)) {\n    return getSVGContentRect(target);\n  }\n\n  return getHTMLElementContentRect(target);\n}\n/**\r\n * Creates rectangle with an interface of the DOMRectReadOnly.\r\n * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly\r\n *\r\n * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.\r\n * @returns {DOMRectReadOnly}\r\n */\n\n\nfunction createReadOnlyRect(_a) {\n  var x = _a.x,\n      y = _a.y,\n      width = _a.width,\n      height = _a.height; // If DOMRectReadOnly is available use it as a prototype for the rectangle.\n\n  var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;\n  var rect = Object.create(Constr.prototype); // Rectangle's properties are not writable and non-enumerable.\n\n  defineConfigurable(rect, {\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    top: y,\n    right: x + width,\n    bottom: height + y,\n    left: x\n  });\n  return rect;\n}\n/**\r\n * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.\r\n * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} width - Rectangle's width.\r\n * @param {number} height - Rectangle's height.\r\n * @returns {DOMRectInit}\r\n */\n\n\nfunction createRectInit(x, y, width, height) {\n  return {\n    x: x,\n    y: y,\n    width: width,\n    height: height\n  };\n}\n/**\r\n * Class that is responsible for computations of the content rectangle of\r\n * provided DOM element and for keeping track of it's changes.\r\n */\n\n\nvar ResizeObservation =\n/** @class */\nfunction () {\n  /**\r\n   * Creates an instance of ResizeObservation.\r\n   *\r\n   * @param {Element} target - Element to be observed.\r\n   */\n  function ResizeObservation(target) {\n    /**\r\n     * Broadcasted width of content rectangle.\r\n     *\r\n     * @type {number}\r\n     */\n    this.broadcastWidth = 0;\n    /**\r\n     * Broadcasted height of content rectangle.\r\n     *\r\n     * @type {number}\r\n     */\n\n    this.broadcastHeight = 0;\n    /**\r\n     * Reference to the last observed content rectangle.\r\n     *\r\n     * @private {DOMRectInit}\r\n     */\n\n    this.contentRect_ = createRectInit(0, 0, 0, 0);\n    this.target = target;\n  }\n  /**\r\n   * Updates content rectangle and tells whether it's width or height properties\r\n   * have changed since the last broadcast.\r\n   *\r\n   * @returns {boolean}\r\n   */\n\n\n  ResizeObservation.prototype.isActive = function () {\n    var rect = getContentRect(this.target);\n    this.contentRect_ = rect;\n    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;\n  };\n  /**\r\n   * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data\r\n   * from the corresponding properties of the last observed content rectangle.\r\n   *\r\n   * @returns {DOMRectInit} Last observed content rectangle.\r\n   */\n\n\n  ResizeObservation.prototype.broadcastRect = function () {\n    var rect = this.contentRect_;\n    this.broadcastWidth = rect.width;\n    this.broadcastHeight = rect.height;\n    return rect;\n  };\n\n  return ResizeObservation;\n}();\n\nvar ResizeObserverEntry =\n/** @class */\nfunction () {\n  /**\r\n   * Creates an instance of ResizeObserverEntry.\r\n   *\r\n   * @param {Element} target - Element that is being observed.\r\n   * @param {DOMRectInit} rectInit - Data of the element's content rectangle.\r\n   */\n  function ResizeObserverEntry(target, rectInit) {\n    var contentRect = createReadOnlyRect(rectInit); // According to the specification following properties are not writable\n    // and are also not enumerable in the native implementation.\n    //\n    // Property accessors are not being used as they'd require to define a\n    // private WeakMap storage which may cause memory leaks in browsers that\n    // don't support this type of collections.\n\n    defineConfigurable(this, {\n      target: target,\n      contentRect: contentRect\n    });\n  }\n\n  return ResizeObserverEntry;\n}();\n\nvar ResizeObserverSPI =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance of ResizeObserver.\r\n   *\r\n   * @param {ResizeObserverCallback} callback - Callback function that is invoked\r\n   *      when one of the observed elements changes it's content dimensions.\r\n   * @param {ResizeObserverController} controller - Controller instance which\r\n   *      is responsible for the updates of observer.\r\n   * @param {ResizeObserver} callbackCtx - Reference to the public\r\n   *      ResizeObserver instance which will be passed to callback function.\r\n   */\n  function ResizeObserverSPI(callback, controller, callbackCtx) {\n    /**\r\n     * Collection of resize observations that have detected changes in dimensions\r\n     * of elements.\r\n     *\r\n     * @private {Array<ResizeObservation>}\r\n     */\n    this.activeObservations_ = [];\n    /**\r\n     * Registry of the ResizeObservation instances.\r\n     *\r\n     * @private {Map<Element, ResizeObservation>}\r\n     */\n\n    this.observations_ = new MapShim();\n\n    if (typeof callback !== 'function') {\n      throw new TypeError('The callback provided as parameter 1 is not a function.');\n    }\n\n    this.callback_ = callback;\n    this.controller_ = controller;\n    this.callbackCtx_ = callbackCtx;\n  }\n  /**\r\n   * Starts observing provided element.\r\n   *\r\n   * @param {Element} target - Element to be observed.\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverSPI.prototype.observe = function (target) {\n    if (!arguments.length) {\n      throw new TypeError('1 argument required, but only 0 present.');\n    } // Do nothing if current environment doesn't have the Element interface.\n\n\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\n      return;\n    }\n\n    if (!(target instanceof getWindowOf(target).Element)) {\n      throw new TypeError('parameter 1 is not of type \"Element\".');\n    }\n\n    var observations = this.observations_; // Do nothing if element is already being observed.\n\n    if (observations.has(target)) {\n      return;\n    }\n\n    observations.set(target, new ResizeObservation(target));\n    this.controller_.addObserver(this); // Force the update of observations.\n\n    this.controller_.refresh();\n  };\n  /**\r\n   * Stops observing provided element.\r\n   *\r\n   * @param {Element} target - Element to stop observing.\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverSPI.prototype.unobserve = function (target) {\n    if (!arguments.length) {\n      throw new TypeError('1 argument required, but only 0 present.');\n    } // Do nothing if current environment doesn't have the Element interface.\n\n\n    if (typeof Element === 'undefined' || !(Element instanceof Object)) {\n      return;\n    }\n\n    if (!(target instanceof getWindowOf(target).Element)) {\n      throw new TypeError('parameter 1 is not of type \"Element\".');\n    }\n\n    var observations = this.observations_; // Do nothing if element is not being observed.\n\n    if (!observations.has(target)) {\n      return;\n    }\n\n    observations.delete(target);\n\n    if (!observations.size) {\n      this.controller_.removeObserver(this);\n    }\n  };\n  /**\r\n   * Stops observing all elements.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverSPI.prototype.disconnect = function () {\n    this.clearActive();\n    this.observations_.clear();\n    this.controller_.removeObserver(this);\n  };\n  /**\r\n   * Collects observation instances the associated element of which has changed\r\n   * it's content rectangle.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverSPI.prototype.gatherActive = function () {\n    var _this = this;\n\n    this.clearActive();\n    this.observations_.forEach(function (observation) {\n      if (observation.isActive()) {\n        _this.activeObservations_.push(observation);\n      }\n    });\n  };\n  /**\r\n   * Invokes initial callback function with a list of ResizeObserverEntry\r\n   * instances collected from active resize observations.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverSPI.prototype.broadcastActive = function () {\n    // Do nothing if observer doesn't have active observations.\n    if (!this.hasActive()) {\n      return;\n    }\n\n    var ctx = this.callbackCtx_; // Create ResizeObserverEntry instance for every active observation.\n\n    var entries = this.activeObservations_.map(function (observation) {\n      return new ResizeObserverEntry(observation.target, observation.broadcastRect());\n    });\n    this.callback_.call(ctx, entries, ctx);\n    this.clearActive();\n  };\n  /**\r\n   * Clears the collection of active observations.\r\n   *\r\n   * @returns {void}\r\n   */\n\n\n  ResizeObserverSPI.prototype.clearActive = function () {\n    this.activeObservations_.splice(0);\n  };\n  /**\r\n   * Tells whether observer has active observations.\r\n   *\r\n   * @returns {boolean}\r\n   */\n\n\n  ResizeObserverSPI.prototype.hasActive = function () {\n    return this.activeObservations_.length > 0;\n  };\n\n  return ResizeObserverSPI;\n}(); // Registry of internal observers. If WeakMap is not available use current shim\n// for the Map collection as it has all required methods and because WeakMap\n// can't be fully polyfilled anyway.\n\n\nvar observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();\n/**\r\n * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation\r\n * exposing only those methods and properties that are defined in the spec.\r\n */\n\nvar ResizeObserver =\n/** @class */\nfunction () {\n  /**\r\n   * Creates a new instance of ResizeObserver.\r\n   *\r\n   * @param {ResizeObserverCallback} callback - Callback that is invoked when\r\n   *      dimensions of the observed elements change.\r\n   */\n  function ResizeObserver(callback) {\n    if (!(this instanceof ResizeObserver)) {\n      throw new TypeError('Cannot call a class as a function.');\n    }\n\n    if (!arguments.length) {\n      throw new TypeError('1 argument required, but only 0 present.');\n    }\n\n    var controller = ResizeObserverController.getInstance();\n    var observer = new ResizeObserverSPI(callback, controller, this);\n    observers.set(this, observer);\n  }\n\n  return ResizeObserver;\n}(); // Expose public methods of ResizeObserver.\n\n\n['observe', 'unobserve', 'disconnect'].forEach(function (method) {\n  ResizeObserver.prototype[method] = function () {\n    var _a;\n\n    return (_a = observers.get(this))[method].apply(_a, arguments);\n  };\n});\n\nvar index = function () {\n  // Export existing implementation if available.\n  if (typeof global$1.ResizeObserver !== 'undefined') {\n    return global$1.ResizeObserver;\n  }\n\n  return ResizeObserver;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (index);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVzaXplLW9ic2VydmVyLXBvbHlmaWxsL2Rpc3QvUmVzaXplT2JzZXJ2ZXIuZXMuanM/NmRkOCJdLCJuYW1lcyI6WyJNYXBTaGltIiwiTWFwIiwiZ2V0SW5kZXgiLCJhcnIiLCJrZXkiLCJyZXN1bHQiLCJzb21lIiwiZW50cnkiLCJpbmRleCIsImNsYXNzXzEiLCJfX2VudHJpZXNfXyIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwicHJvdG90eXBlIiwiZ2V0IiwibGVuZ3RoIiwiZW51bWVyYWJsZSIsImNvbmZpZ3VyYWJsZSIsInNldCIsInZhbHVlIiwicHVzaCIsImRlbGV0ZSIsImVudHJpZXMiLCJzcGxpY2UiLCJoYXMiLCJjbGVhciIsImZvckVhY2giLCJjYWxsYmFjayIsImN0eCIsIl9pIiwiX2EiLCJjYWxsIiwiaXNCcm93c2VyIiwid2luZG93IiwiZG9jdW1lbnQiLCJnbG9iYWwkMSIsImdsb2JhbCIsIk1hdGgiLCJzZWxmIiwiRnVuY3Rpb24iLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUkMSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImJpbmQiLCJzZXRUaW1lb3V0IiwiRGF0ZSIsIm5vdyIsInRyYWlsaW5nVGltZW91dCIsInRocm90dGxlIiwiZGVsYXkiLCJsZWFkaW5nQ2FsbCIsInRyYWlsaW5nQ2FsbCIsImxhc3RDYWxsVGltZSIsInJlc29sdmVQZW5kaW5nIiwicHJveHkiLCJ0aW1lb3V0Q2FsbGJhY2siLCJ0aW1lU3RhbXAiLCJSRUZSRVNIX0RFTEFZIiwidHJhbnNpdGlvbktleXMiLCJtdXRhdGlvbk9ic2VydmVyU3VwcG9ydGVkIiwiTXV0YXRpb25PYnNlcnZlciIsIlJlc2l6ZU9ic2VydmVyQ29udHJvbGxlciIsImNvbm5lY3RlZF8iLCJtdXRhdGlvbkV2ZW50c0FkZGVkXyIsIm11dGF0aW9uc09ic2VydmVyXyIsIm9ic2VydmVyc18iLCJvblRyYW5zaXRpb25FbmRfIiwicmVmcmVzaCIsImFkZE9ic2VydmVyIiwib2JzZXJ2ZXIiLCJpbmRleE9mIiwiY29ubmVjdF8iLCJyZW1vdmVPYnNlcnZlciIsIm9ic2VydmVycyIsImRpc2Nvbm5lY3RfIiwiY2hhbmdlc0RldGVjdGVkIiwidXBkYXRlT2JzZXJ2ZXJzXyIsImFjdGl2ZU9ic2VydmVycyIsImZpbHRlciIsImdhdGhlckFjdGl2ZSIsImhhc0FjdGl2ZSIsImJyb2FkY2FzdEFjdGl2ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJvYnNlcnZlIiwiYXR0cmlidXRlcyIsImNoaWxkTGlzdCIsImNoYXJhY3RlckRhdGEiLCJzdWJ0cmVlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRpc2Nvbm5lY3QiLCJfYiIsInByb3BlcnR5TmFtZSIsImlzUmVmbG93UHJvcGVydHkiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlXyIsImRlZmluZUNvbmZpZ3VyYWJsZSIsInRhcmdldCIsInByb3BzIiwia2V5cyIsIndyaXRhYmxlIiwiZ2V0V2luZG93T2YiLCJvd25lckdsb2JhbCIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImVtcHR5UmVjdCIsImNyZWF0ZVJlY3RJbml0IiwidG9GbG9hdCIsInBhcnNlRmxvYXQiLCJnZXRCb3JkZXJzU2l6ZSIsInN0eWxlcyIsInBvc2l0aW9ucyIsImFyZ3VtZW50cyIsInJlZHVjZSIsInNpemUiLCJwb3NpdGlvbiIsImdldFBhZGRpbmdzIiwicGFkZGluZ3MiLCJwb3NpdGlvbnNfMSIsImdldFNWR0NvbnRlbnRSZWN0IiwiYmJveCIsImdldEJCb3giLCJ3aWR0aCIsImhlaWdodCIsImdldEhUTUxFbGVtZW50Q29udGVudFJlY3QiLCJjbGllbnRXaWR0aCIsImNsaWVudEhlaWdodCIsImdldENvbXB1dGVkU3R5bGUiLCJob3JpelBhZCIsImxlZnQiLCJyaWdodCIsInZlcnRQYWQiLCJ0b3AiLCJib3R0b20iLCJib3hTaXppbmciLCJyb3VuZCIsImlzRG9jdW1lbnRFbGVtZW50IiwidmVydFNjcm9sbGJhciIsImhvcml6U2Nyb2xsYmFyIiwiYWJzIiwiaXNTVkdHcmFwaGljc0VsZW1lbnQiLCJTVkdHcmFwaGljc0VsZW1lbnQiLCJTVkdFbGVtZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiZ2V0Q29udGVudFJlY3QiLCJjcmVhdGVSZWFkT25seVJlY3QiLCJ4IiwieSIsIkNvbnN0ciIsIkRPTVJlY3RSZWFkT25seSIsInJlY3QiLCJjcmVhdGUiLCJSZXNpemVPYnNlcnZhdGlvbiIsImJyb2FkY2FzdFdpZHRoIiwiYnJvYWRjYXN0SGVpZ2h0IiwiY29udGVudFJlY3RfIiwiaXNBY3RpdmUiLCJicm9hZGNhc3RSZWN0IiwiUmVzaXplT2JzZXJ2ZXJFbnRyeSIsInJlY3RJbml0IiwiY29udGVudFJlY3QiLCJSZXNpemVPYnNlcnZlclNQSSIsImNvbnRyb2xsZXIiLCJjYWxsYmFja0N0eCIsImFjdGl2ZU9ic2VydmF0aW9uc18iLCJvYnNlcnZhdGlvbnNfIiwiVHlwZUVycm9yIiwiY2FsbGJhY2tfIiwiY29udHJvbGxlcl8iLCJjYWxsYmFja0N0eF8iLCJFbGVtZW50Iiwib2JzZXJ2YXRpb25zIiwidW5vYnNlcnZlIiwiY2xlYXJBY3RpdmUiLCJfdGhpcyIsIm9ic2VydmF0aW9uIiwibWFwIiwiV2Vha01hcCIsIlJlc2l6ZU9ic2VydmVyIiwibWV0aG9kIiwiYXBwbHkiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7Ozs7Ozs7QUFNQTtBQUNBLElBQUlBLE9BQU8sR0FBSSxZQUFZO0FBQ3ZCLE1BQUksT0FBT0MsR0FBUCxLQUFlLFdBQW5CLEVBQWdDO0FBQzVCLFdBQU9BLEdBQVA7QUFDSDtBQUNEOzs7Ozs7Ozs7QUFPQSxXQUFTQyxRQUFULENBQWtCQyxHQUFsQixFQUF1QkMsR0FBdkIsRUFBNEI7QUFDeEIsUUFBSUMsTUFBTSxHQUFHLENBQUMsQ0FBZDtBQUNBRixPQUFHLENBQUNHLElBQUosQ0FBUyxVQUFVQyxLQUFWLEVBQWlCQyxLQUFqQixFQUF3QjtBQUM3QixVQUFJRCxLQUFLLENBQUMsQ0FBRCxDQUFMLEtBQWFI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dEcsS0FBSyxHQUFJLFlBQVk7QUFDckI7QUFDQSxNQUFJLE9BQU8yQixRQUFRLENBQUM2SSxjQUFoQixLQUFtQyxXQUF2QyxFQUFvRDtBQUNoRCxXQUFPN0ksUUFBUSxDQUFDNkksY0FBaEI7QUFDSDs7QUFDRCxTQUFPQSxjQUFQO0FBQ0gsQ0FOVyxFQUFaOztBQVFleEssb0VBQWYsRSIsImZpbGUiOiIuL25vZGVfbW9kdWxlcy9yZXNpemUtb2JzZXJ2ZXItcG9seWZpbGwvZGlzdC9SZXNpemVPYnNlcnZlci5lcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxyXG4gKiBBIGNvbGxlY3Rpb24gb2Ygc2hpbXMgdGhhdCBwcm92aWRlIG1pbmltYWwgZnVuY3Rpb25hbGl0eSBvZiB0aGUgRVM2IGNvbGxlY3Rpb25zLlxyXG4gKlxyXG4gKiBUaGVzZSBpbXBsZW1lbnRhdGlvbnMgYXJlIG5vdCBtZWFudCB0byBiZSB1c2VkIG91dHNpZGUgb2YgdGhlIFJlc2l6ZU9ic2VydmVyXHJcbiAqIG1vZHVsZXMgYXMgdGhleSBjb3ZlciBvbmx5IGEgbGltaXRlZCByYW5nZSBvZiB1c2UgY2FzZXMuXHJcbiAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWpzZG9jLCB2YWxpZC1qc2RvYyAqL1xyXG52YXIgTWFwU2hpbSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIE1hcCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gTWFwO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIGluZGV4IGluIHByb3ZpZGVkIGFycmF5IHRoYXQgbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0FycmF5PEFycmF5Pn0gYXJyXHJcbiAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICogQHJldHVybnMge251bWJlcn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gZ2V0SW5kZXgoYXJyLCBrZXkpIHtcclxuICAgICAgICB2YXIgcmVzdWx0ID0gLTE7XHJcbiAgICAgICAgYXJyLnNvbWUoZnVuY3Rpb24gKGVudHJ5LCBpbmRleCkge1xyXG4gICAgICAgICAgICBpZiAoZW50cnlbMF0gPT09IGtleSkge1xyXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW5kZXg7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuICAgIHJldHVybiAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gY2xhc3NfMSgpIHtcclxuICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXyA9IFtdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY2xhc3NfMS5wcm90b3R5cGUsIFwic2l6ZVwiLCB7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19lbnRyaWVzX18ubGVuZ3RoO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHsqfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgodGhpcy5fX2VudHJpZXNfXywga2V5KTtcclxuICAgICAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy5fX2VudHJpZXNfX1tpbmRleF07XHJcbiAgICAgICAgICAgIHJldHVybiBlbnRyeSAmJiBlbnRyeVsxXTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0ga2V5XHJcbiAgICAgICAgICogQHBhcmFtIHsqfSB2YWx1ZVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmRleCA9IGdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcbiAgICAgICAgICAgIGlmICh+aW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19lbnRyaWVzX19baW5kZXhdWzFdID0gdmFsdWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZW50cmllc19fLnB1c2goW2tleSwgdmFsdWVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtIHsqfSBrZXlcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgICAgIHZhciBlbnRyaWVzID0gdGhpcy5fX2VudHJpZXNfXztcclxuICAgICAgICAgICAgdmFyIGluZGV4ID0gZ2V0SW5kZXgoZW50cmllcywga2V5KTtcclxuICAgICAgICAgICAgaWYgKH5pbmRleCkge1xyXG4gICAgICAgICAgICAgICAgZW50cmllcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0geyp9IGtleVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhfmdldEluZGV4KHRoaXMuX19lbnRyaWVzX18sIGtleSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAgICAgKi9cclxuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdGhpcy5fX2VudHJpZXNfXy5zcGxpY2UoMCk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xyXG4gICAgICAgICAqIEBwYXJhbSB7Kn0gW2N0eD1udWxsXVxyXG4gICAgICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGN0eCkge1xyXG4gICAgICAgICAgICBpZiAoY3R4ID09PSB2b2lkIDApIHsgY3R4ID0gbnVsbDsgfVxyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5fX2VudHJpZXNfXzsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IF9hW19pXTtcclxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoY3R4LCBlbnRyeVsxXSwgZW50cnlbMF0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gY2xhc3NfMTtcclxuICAgIH0oKSk7XHJcbn0pKCk7XG5cbi8qKlxyXG4gKiBEZXRlY3RzIHdoZXRoZXIgd2luZG93IGFuZCBkb2N1bWVudCBvYmplY3RzIGFyZSBhdmFpbGFibGUgaW4gY3VycmVudCBlbnZpcm9ubWVudC5cclxuICovXHJcbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCA9PT0gZG9jdW1lbnQ7XG5cbi8vIFJldHVybnMgZ2xvYmFsIG9iamVjdCBvZiBhIGN1cnJlbnQgZW52aXJvbm1lbnQuXHJcbnZhciBnbG9iYWwkMSA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLk1hdGggPT09IE1hdGgpIHtcclxuICAgICAgICByZXR1cm4gZ2xvYmFsO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLk1hdGggPT09IE1hdGgpIHtcclxuICAgICAgICByZXR1cm4gc2VsZjtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuTWF0aCA9PT0gTWF0aCkge1xyXG4gICAgICAgIHJldHVybiB3aW5kb3c7XHJcbiAgICB9XHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tbmV3LWZ1bmNcclxuICAgIHJldHVybiBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xyXG59KSgpO1xuXG4vKipcclxuICogQSBzaGltIGZvciB0aGUgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIHdoaWNoIGZhbGxzIGJhY2sgdG8gdGhlIHNldFRpbWVvdXQgaWZcclxuICogZmlyc3Qgb25lIGlzIG5vdCBzdXBwb3J0ZWQuXHJcbiAqXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9IFJlcXVlc3RzJyBpZGVudGlmaWVyLlxyXG4gKi9cclxudmFyIHJlcXVlc3RBbmltYXRpb25GcmFtZSQxID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICh0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgLy8gSXQncyByZXF1aXJlZCB0byB1c2UgYSBib3VuZGVkIGZ1bmN0aW9uIGJlY2F1c2UgSUUgc29tZXRpbWVzIHRocm93c1xyXG4gICAgICAgIC8vIGFuIFwiSW52YWxpZCBjYWxsaW5nIG9iamVjdFwiIGVycm9yIGlmIHJBRiBpcyBpbnZva2VkIHdpdGhvdXQgdGhlIGdsb2JhbFxyXG4gICAgICAgIC8vIG9iamVjdCBvbiB0aGUgbGVmdCBoYW5kIHNpZGUuXHJcbiAgICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZS5iaW5kKGdsb2JhbCQxKTtcclxuICAgIH1cclxuICAgIHJldHVybiBmdW5jdGlvbiAoY2FsbGJhY2spIHsgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gY2FsbGJhY2soRGF0ZS5ub3coKSk7IH0sIDEwMDAgLyA2MCk7IH07XHJcbn0pKCk7XG5cbi8vIERlZmluZXMgbWluaW11bSB0aW1lb3V0IGJlZm9yZSBhZGRpbmcgYSB0cmFpbGluZyBjYWxsLlxyXG52YXIgdHJhaWxpbmdUaW1lb3V0ID0gMjtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSB3cmFwcGVyIGZ1bmN0aW9uIHdoaWNoIGVuc3VyZXMgdGhhdCBwcm92aWRlZCBjYWxsYmFjayB3aWxsIGJlXHJcbiAqIGludm9rZWQgb25seSBvbmNlIGR1cmluZyB0aGUgc3BlY2lmaWVkIGRlbGF5IHBlcmlvZC5cclxuICpcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBiZSBpbnZva2VkIGFmdGVyIHRoZSBkZWxheSBwZXJpb2QuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWxheSAtIERlbGF5IGFmdGVyIHdoaWNoIHRvIGludm9rZSBjYWxsYmFjay5cclxuICogQHJldHVybnMge0Z1bmN0aW9ufVxyXG4gKi9cclxuZnVuY3Rpb24gdGhyb3R0bGUgKGNhbGxiYWNrLCBkZWxheSkge1xyXG4gICAgdmFyIGxlYWRpbmdDYWxsID0gZmFsc2UsIHRyYWlsaW5nQ2FsbCA9IGZhbHNlLCBsYXN0Q2FsbFRpbWUgPSAwO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2VzIHRoZSBvcmlnaW5hbCBjYWxsYmFjayBmdW5jdGlvbiBhbmQgc2NoZWR1bGVzIG5ldyBpbnZvY2F0aW9uIGlmXHJcbiAgICAgKiB0aGUgXCJwcm94eVwiIHdhcyBjYWxsZWQgZHVyaW5nIGN1cnJlbnQgcmVxdWVzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gcmVzb2x2ZVBlbmRpbmcoKSB7XHJcbiAgICAgICAgaWYgKGxlYWRpbmdDYWxsKSB7XHJcbiAgICAgICAgICAgIGxlYWRpbmdDYWxsID0gZmFsc2U7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0cmFpbGluZ0NhbGwpIHtcclxuICAgICAgICAgICAgcHJveHkoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIENhbGxiYWNrIGludm9rZWQgYWZ0ZXIgdGhlIHNwZWNpZmllZCBkZWxheS4gSXQgd2lsbCBmdXJ0aGVyIHBvc3Rwb25lXHJcbiAgICAgKiBpbnZvY2F0aW9uIG9mIHRoZSBvcmlnaW5hbCBmdW5jdGlvbiBkZWxlZ2F0aW5nIGl0IHRvIHRoZVxyXG4gICAgICogcmVxdWVzdEFuaW1hdGlvbkZyYW1lLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiB0aW1lb3V0Q2FsbGJhY2soKSB7XHJcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lJDEocmVzb2x2ZVBlbmRpbmcpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTY2hlZHVsZXMgaW52b2NhdGlvbiBvZiB0aGUgb3JpZ2luYWwgZnVuY3Rpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIHByb3h5KCkge1xyXG4gICAgICAgIHZhciB0aW1lU3RhbXAgPSBEYXRlLm5vdygpO1xyXG4gICAgICAgIGlmIChsZWFkaW5nQ2FsbCkge1xyXG4gICAgICAgICAgICAvLyBSZWplY3QgaW1tZWRpYXRlbHkgZm9sbG93aW5nIGNhbGxzLlxyXG4gICAgICAgICAgICBpZiAodGltZVN0YW1wIC0gbGFzdENhbGxUaW1lIDwgdHJhaWxpbmdUaW1lb3V0KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gU2NoZWR1bGUgbmV3IGNhbGwgdG8gYmUgaW4gaW52b2tlZCB3aGVuIHRoZSBwZW5kaW5nIG9uZSBpcyByZXNvbHZlZC5cclxuICAgICAgICAgICAgLy8gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIFwidHJhbnNpdGlvbnNcIiB3aGljaCBuZXZlciBhY3R1YWxseSBzdGFydFxyXG4gICAgICAgICAgICAvLyBpbW1lZGlhdGVseSBzbyB0aGVyZSBpcyBhIGNoYW5jZSB0aGF0IHdlIG1pZ2h0IG1pc3Mgb25lIGlmIGNoYW5nZVxyXG4gICAgICAgICAgICAvLyBoYXBwZW5zIGFtaWRzIHRoZSBwZW5kaW5nIGludm9jYXRpb24uXHJcbiAgICAgICAgICAgIHRyYWlsaW5nQ2FsbCA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZWFkaW5nQ2FsbCA9IHRydWU7XHJcbiAgICAgICAgICAgIHRyYWlsaW5nQ2FsbCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHRpbWVvdXRDYWxsYmFjaywgZGVsYXkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsYXN0Q2FsbFRpbWUgPSB0aW1lU3RhbXA7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcHJveHk7XHJcbn1cblxuLy8gTWluaW11bSBkZWxheSBiZWZvcmUgaW52b2tpbmcgdGhlIHVwZGF0ZSBvZiBvYnNlcnZlcnMuXHJcbnZhciBSRUZSRVNIX0RFTEFZID0gMjA7XHJcbi8vIEEgbGlzdCBvZiBzdWJzdHJpbmdzIG9mIENTUyBwcm9wZXJ0aWVzIHVzZWQgdG8gZmluZCB0cmFuc2l0aW9uIGV2ZW50cyB0aGF0XHJcbi8vIG1pZ2h0IGFmZmVjdCBkaW1lbnNpb25zIG9mIG9ic2VydmVkIGVsZW1lbnRzLlxyXG52YXIgdHJhbnNpdGlvbktleXMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCcsICd3aWR0aCcsICdoZWlnaHQnLCAnc2l6ZScsICd3ZWlnaHQnXTtcclxuLy8gQ2hlY2sgaWYgTXV0YXRpb25PYnNlcnZlciBpcyBhdmFpbGFibGUuXHJcbnZhciBtdXRhdGlvbk9ic2VydmVyU3VwcG9ydGVkID0gdHlwZW9mIE11dGF0aW9uT2JzZXJ2ZXIgIT09ICd1bmRlZmluZWQnO1xyXG4vKipcclxuICogU2luZ2xldG9uIGNvbnRyb2xsZXIgY2xhc3Mgd2hpY2ggaGFuZGxlcyB1cGRhdGVzIG9mIFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlcy5cclxuICovXHJcbnZhciBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBJbmRpY2F0ZXMgd2hldGhlciBET00gbGlzdGVuZXJzIGhhdmUgYmVlbiBhZGRlZC5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtib29sZWFufVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFRlbGxzIHRoYXQgY29udHJvbGxlciBoYXMgc3Vic2NyaWJlZCBmb3IgTXV0YXRpb24gRXZlbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge2Jvb2xlYW59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IGZhbHNlO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEtlZXBzIHJlZmVyZW5jZSB0byB0aGUgaW5zdGFuY2Ugb2YgTXV0YXRpb25PYnNlcnZlci5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtNdXRhdGlvbk9ic2VydmVyfVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbnVsbDtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBIGxpc3Qgb2YgY29ubmVjdGVkIG9ic2VydmVycy5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEBwcml2YXRlIHtBcnJheTxSZXNpemVPYnNlcnZlclNQST59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vYnNlcnZlcnNfID0gW107XHJcbiAgICAgICAgdGhpcy5vblRyYW5zaXRpb25FbmRfID0gdGhpcy5vblRyYW5zaXRpb25FbmRfLmJpbmQodGhpcyk7XHJcbiAgICAgICAgdGhpcy5yZWZyZXNoID0gdGhyb3R0bGUodGhpcy5yZWZyZXNoLmJpbmQodGhpcyksIFJFRlJFU0hfREVMQVkpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGRzIG9ic2VydmVyIHRvIG9ic2VydmVycyBsaXN0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJTUEl9IG9ic2VydmVyIC0gT2JzZXJ2ZXIgdG8gYmUgYWRkZWQuXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5hZGRPYnNlcnZlciA9IGZ1bmN0aW9uIChvYnNlcnZlcikge1xyXG4gICAgICAgIGlmICghfnRoaXMub2JzZXJ2ZXJzXy5pbmRleE9mKG9ic2VydmVyKSkge1xyXG4gICAgICAgICAgICB0aGlzLm9ic2VydmVyc18ucHVzaChvYnNlcnZlcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFkZCBsaXN0ZW5lcnMgaWYgdGhleSBoYXZlbid0IGJlZW4gYWRkZWQgeWV0LlxyXG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdF8oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIG9ic2VydmVyIGZyb20gb2JzZXJ2ZXJzIGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlclNQSX0gb2JzZXJ2ZXIgLSBPYnNlcnZlciB0byBiZSByZW1vdmVkLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUucmVtb3ZlT2JzZXJ2ZXIgPSBmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICB2YXIgb2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnNfO1xyXG4gICAgICAgIHZhciBpbmRleCA9IG9ic2VydmVycy5pbmRleE9mKG9ic2VydmVyKTtcclxuICAgICAgICAvLyBSZW1vdmUgb2JzZXJ2ZXIgaWYgaXQncyBwcmVzZW50IGluIHJlZ2lzdHJ5LlxyXG4gICAgICAgIGlmICh+aW5kZXgpIHtcclxuICAgICAgICAgICAgb2JzZXJ2ZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFJlbW92ZSBsaXN0ZW5lcnMgaWYgY29udHJvbGxlciBoYXMgbm8gY29ubmVjdGVkIG9ic2VydmVycy5cclxuICAgICAgICBpZiAoIW9ic2VydmVycy5sZW5ndGggJiYgdGhpcy5jb25uZWN0ZWRfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdF8oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnZva2VzIHRoZSB1cGRhdGUgb2Ygb2JzZXJ2ZXJzLiBJdCB3aWxsIGNvbnRpbnVlIHJ1bm5pbmcgdXBkYXRlcyBpbnNvZmFyXHJcbiAgICAgKiBpdCBkZXRlY3RzIGNoYW5nZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgY2hhbmdlc0RldGVjdGVkID0gdGhpcy51cGRhdGVPYnNlcnZlcnNfKCk7XHJcbiAgICAgICAgLy8gQ29udGludWUgcnVubmluZyB1cGRhdGVzIGlmIGNoYW5nZXMgaGF2ZSBiZWVuIGRldGVjdGVkIGFzIHRoZXJlIG1pZ2h0XHJcbiAgICAgICAgLy8gYmUgZnV0dXJlIG9uZXMgY2F1c2VkIGJ5IENTUyB0cmFuc2l0aW9ucy5cclxuICAgICAgICBpZiAoY2hhbmdlc0RldGVjdGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgZXZlcnkgb2JzZXJ2ZXIgZnJvbSBvYnNlcnZlcnMgbGlzdCBhbmQgbm90aWZpZXMgdGhlbSBvZiBxdWV1ZWRcclxuICAgICAqIGVudHJpZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIFwidHJ1ZVwiIGlmIGFueSBvYnNlcnZlciBoYXMgZGV0ZWN0ZWQgY2hhbmdlcyBpblxyXG4gICAgICogICAgICBkaW1lbnNpb25zIG9mIGl0J3MgZWxlbWVudHMuXHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5wcm90b3R5cGUudXBkYXRlT2JzZXJ2ZXJzXyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBDb2xsZWN0IG9ic2VydmVycyB0aGF0IGhhdmUgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAgICB2YXIgYWN0aXZlT2JzZXJ2ZXJzID0gdGhpcy5vYnNlcnZlcnNfLmZpbHRlcihmdW5jdGlvbiAob2JzZXJ2ZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIG9ic2VydmVyLmdhdGhlckFjdGl2ZSgpLCBvYnNlcnZlci5oYXNBY3RpdmUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICAvLyBEZWxpdmVyIG5vdGlmaWNhdGlvbnMgaW4gYSBzZXBhcmF0ZSBjeWNsZSBpbiBvcmRlciB0byBhdm9pZCBhbnlcclxuICAgICAgICAvLyBjb2xsaXNpb25zIGJldHdlZW4gb2JzZXJ2ZXJzLCBlLmcuIHdoZW4gbXVsdGlwbGUgaW5zdGFuY2VzIG9mXHJcbiAgICAgICAgLy8gUmVzaXplT2JzZXJ2ZXIgYXJlIHRyYWNraW5nIHRoZSBzYW1lIGVsZW1lbnQgYW5kIHRoZSBjYWxsYmFjayBvZiBvbmVcclxuICAgICAgICAvLyBvZiB0aGVtIGNoYW5nZXMgY29udGVudCBkaW1lbnNpb25zIG9mIHRoZSBvYnNlcnZlZCB0YXJnZXQuIFNvbWV0aW1lc1xyXG4gICAgICAgIC8vIHRoaXMgbWF5IHJlc3VsdCBpbiBub3RpZmljYXRpb25zIGJlaW5nIGJsb2NrZWQgZm9yIHRoZSByZXN0IG9mIG9ic2VydmVycy5cclxuICAgICAgICBhY3RpdmVPYnNlcnZlcnMuZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2ZXIpIHsgcmV0dXJuIG9ic2VydmVyLmJyb2FkY2FzdEFjdGl2ZSgpOyB9KTtcclxuICAgICAgICByZXR1cm4gYWN0aXZlT2JzZXJ2ZXJzLmxlbmd0aCA+IDA7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbml0aWFsaXplcyBET00gbGlzdGVuZXJzLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLnByb3RvdHlwZS5jb25uZWN0XyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBEbyBub3RoaW5nIGlmIHJ1bm5pbmcgaW4gYSBub24tYnJvd3NlciBlbnZpcm9ubWVudCBvciBpZiBsaXN0ZW5lcnNcclxuICAgICAgICAvLyBoYXZlIGJlZW4gYWxyZWFkeSBhZGRlZC5cclxuICAgICAgICBpZiAoIWlzQnJvd3NlciB8fCB0aGlzLmNvbm5lY3RlZF8pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBTdWJzY3JpcHRpb24gdG8gdGhlIFwiVHJhbnNpdGlvbmVuZFwiIGV2ZW50IGlzIHVzZWQgYXMgYSB3b3JrYXJvdW5kIGZvclxyXG4gICAgICAgIC8vIGRlbGF5ZWQgdHJhbnNpdGlvbnMuIFRoaXMgd2F5IGl0J3MgcG9zc2libGUgdG8gY2FwdHVyZSBhdCBsZWFzdCB0aGVcclxuICAgICAgICAvLyBmaW5hbCBzdGF0ZSBvZiBhbiBlbGVtZW50LlxyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZF8pO1xyXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgIGlmIChtdXRhdGlvbk9ic2VydmVyU3VwcG9ydGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIodGhpcy5yZWZyZXNoKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbnNPYnNlcnZlcl8ub2JzZXJ2ZShkb2N1bWVudCwge1xyXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGNoYXJhY3RlckRhdGE6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBzdWJ0cmVlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NU3VidHJlZU1vZGlmaWVkJywgdGhpcy5yZWZyZXNoKTtcclxuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbkV2ZW50c0FkZGVkXyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY29ubmVjdGVkXyA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW1vdmVzIERPTSBsaXN0ZW5lcnMuXHJcbiAgICAgKlxyXG4gICAgICogQHByaXZhdGVcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLmRpc2Nvbm5lY3RfID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgcnVubmluZyBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50IG9yIGlmIGxpc3RlbmVyc1xyXG4gICAgICAgIC8vIGhhdmUgYmVlbiBhbHJlYWR5IHJlbW92ZWQuXHJcbiAgICAgICAgaWYgKCFpc0Jyb3dzZXIgfHwgIXRoaXMuY29ubmVjdGVkXykge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB0aGlzLm9uVHJhbnNpdGlvbkVuZF8pO1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLnJlZnJlc2gpO1xyXG4gICAgICAgIGlmICh0aGlzLm11dGF0aW9uc09ic2VydmVyXykge1xyXG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uc09ic2VydmVyXy5kaXNjb25uZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfKSB7XHJcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTVN1YnRyZWVNb2RpZmllZCcsIHRoaXMucmVmcmVzaCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMubXV0YXRpb25zT2JzZXJ2ZXJfID0gbnVsbDtcclxuICAgICAgICB0aGlzLm11dGF0aW9uRXZlbnRzQWRkZWRfID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRfID0gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBcIlRyYW5zaXRpb25lbmRcIiBldmVudCBoYW5kbGVyLlxyXG4gICAgICpcclxuICAgICAqIEBwcml2YXRlXHJcbiAgICAgKiBAcGFyYW0ge1RyYW5zaXRpb25FdmVudH0gZXZlbnRcclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIucHJvdG90eXBlLm9uVHJhbnNpdGlvbkVuZF8gPSBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfYS5wcm9wZXJ0eU5hbWUsIHByb3BlcnR5TmFtZSA9IF9iID09PSB2b2lkIDAgPyAnJyA6IF9iO1xyXG4gICAgICAgIC8vIERldGVjdCB3aGV0aGVyIHRyYW5zaXRpb24gbWF5IGFmZmVjdCBkaW1lbnNpb25zIG9mIGFuIGVsZW1lbnQuXHJcbiAgICAgICAgdmFyIGlzUmVmbG93UHJvcGVydHkgPSB0cmFuc2l0aW9uS2V5cy5zb21lKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhfnByb3BlcnR5TmFtZS5pbmRleE9mKGtleSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKGlzUmVmbG93UHJvcGVydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyBpbnN0YW5jZSBvZiB0aGUgUmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtSZXNpemVPYnNlcnZlckNvbnRyb2xsZXJ9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlci5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2VfKSB7XHJcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2VfID0gbmV3IFJlc2l6ZU9ic2VydmVyQ29udHJvbGxlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5pbnN0YW5jZV87XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBIb2xkcyByZWZlcmVuY2UgdG8gdGhlIGNvbnRyb2xsZXIncyBpbnN0YW5jZS5cclxuICAgICAqXHJcbiAgICAgKiBAcHJpdmF0ZSB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuaW5zdGFuY2VfID0gbnVsbDtcclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXI7XHJcbn0oKSk7XG5cbi8qKlxyXG4gKiBEZWZpbmVzIG5vbi13cml0YWJsZS9lbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgdGhlIHByb3ZpZGVkIHRhcmdldCBvYmplY3QuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSB0YXJnZXQgLSBPYmplY3QgZm9yIHdoaWNoIHRvIGRlZmluZSBwcm9wZXJ0aWVzLlxyXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcHMgLSBQcm9wZXJ0aWVzIHRvIGJlIGRlZmluZWQuXHJcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRhcmdldCBvYmplY3QuXHJcbiAqL1xyXG52YXIgZGVmaW5lQ29uZmlndXJhYmxlID0gKGZ1bmN0aW9uICh0YXJnZXQsIHByb3BzKSB7XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gT2JqZWN0LmtleXMocHJvcHMpOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBrZXkgPSBfYVtfaV07XHJcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCB7XHJcbiAgICAgICAgICAgIHZhbHVlOiBwcm9wc1trZXldLFxyXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcclxuICAgICAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn0pO1xuXG4vKipcclxuICogUmV0dXJucyB0aGUgZ2xvYmFsIG9iamVjdCBhc3NvY2lhdGVkIHdpdGggcHJvdmlkZWQgZWxlbWVudC5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IHRhcmdldFxyXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gKi9cclxudmFyIGdldFdpbmRvd09mID0gKGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgIC8vIEFzc3VtZSB0aGF0IHRoZSBlbGVtZW50IGlzIGFuIGluc3RhbmNlIG9mIE5vZGUsIHdoaWNoIG1lYW5zIHRoYXQgaXRcclxuICAgIC8vIGhhcyB0aGUgXCJvd25lckRvY3VtZW50XCIgcHJvcGVydHkgZnJvbSB3aGljaCB3ZSBjYW4gcmV0cmlldmUgYVxyXG4gICAgLy8gY29ycmVzcG9uZGluZyBnbG9iYWwgb2JqZWN0LlxyXG4gICAgdmFyIG93bmVyR2xvYmFsID0gdGFyZ2V0ICYmIHRhcmdldC5vd25lckRvY3VtZW50ICYmIHRhcmdldC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xyXG4gICAgLy8gUmV0dXJuIHRoZSBsb2NhbCBnbG9iYWwgb2JqZWN0IGlmIGl0J3Mgbm90IHBvc3NpYmxlIGV4dHJhY3Qgb25lIGZyb21cclxuICAgIC8vIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICByZXR1cm4gb3duZXJHbG9iYWwgfHwgZ2xvYmFsJDE7XHJcbn0pO1xuXG4vLyBQbGFjZWhvbGRlciBvZiBhbiBlbXB0eSBjb250ZW50IHJlY3RhbmdsZS5cclxudmFyIGVtcHR5UmVjdCA9IGNyZWF0ZVJlY3RJbml0KDAsIDAsIDAsIDApO1xyXG4vKipcclxuICogQ29udmVydHMgcHJvdmlkZWQgc3RyaW5nIHRvIGEgbnVtYmVyLlxyXG4gKlxyXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IHZhbHVlXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiB0b0Zsb2F0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWx1ZSkgfHwgMDtcclxufVxyXG4vKipcclxuICogRXh0cmFjdHMgYm9yZGVycyBzaXplIGZyb20gcHJvdmlkZWQgc3R5bGVzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xyXG4gKiBAcGFyYW0gey4uLnN0cmluZ30gcG9zaXRpb25zIC0gQm9yZGVycyBwb3NpdGlvbnMgKHRvcCwgcmlnaHQsIC4uLilcclxuICogQHJldHVybnMge251bWJlcn1cclxuICovXHJcbmZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcykge1xyXG4gICAgdmFyIHBvc2l0aW9ucyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBwb3NpdGlvbnNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcG9zaXRpb25zLnJlZHVjZShmdW5jdGlvbiAoc2l6ZSwgcG9zaXRpb24pIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBzdHlsZXNbJ2JvcmRlci0nICsgcG9zaXRpb24gKyAnLXdpZHRoJ107XHJcbiAgICAgICAgcmV0dXJuIHNpemUgKyB0b0Zsb2F0KHZhbHVlKTtcclxuICAgIH0sIDApO1xyXG59XHJcbi8qKlxyXG4gKiBFeHRyYWN0cyBwYWRkaW5ncyBzaXplcyBmcm9tIHByb3ZpZGVkIHN0eWxlcy5cclxuICpcclxuICogQHBhcmFtIHtDU1NTdHlsZURlY2xhcmF0aW9ufSBzdHlsZXNcclxuICogQHJldHVybnMge09iamVjdH0gUGFkZGluZ3MgYm94LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UGFkZGluZ3Moc3R5bGVzKSB7XHJcbiAgICB2YXIgcG9zaXRpb25zID0gWyd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXTtcclxuICAgIHZhciBwYWRkaW5ncyA9IHt9O1xyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBwb3NpdGlvbnNfMSA9IHBvc2l0aW9uczsgX2kgPCBwb3NpdGlvbnNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgcG9zaXRpb24gPSBwb3NpdGlvbnNfMVtfaV07XHJcbiAgICAgICAgdmFyIHZhbHVlID0gc3R5bGVzWydwYWRkaW5nLScgKyBwb3NpdGlvbl07XHJcbiAgICAgICAgcGFkZGluZ3NbcG9zaXRpb25dID0gdG9GbG9hdCh2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcGFkZGluZ3M7XHJcbn1cclxuLyoqXHJcbiAqIENhbGN1bGF0ZXMgY29udGVudCByZWN0YW5nbGUgb2YgcHJvdmlkZWQgU1ZHIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U1ZHR3JhcGhpY3NFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHdoaWNoIG5lZWRzXHJcbiAqICAgICAgdG8gYmUgY2FsY3VsYXRlZC5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0U1ZHQ29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICB2YXIgYmJveCA9IHRhcmdldC5nZXRCQm94KCk7XHJcbiAgICByZXR1cm4gY3JlYXRlUmVjdEluaXQoMCwgMCwgYmJveC53aWR0aCwgYmJveC5oZWlnaHQpO1xyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGNvbnRlbnQgcmVjdGFuZ2xlIG9mIHByb3ZpZGVkIEhUTUxFbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IGZvciB3aGljaCB0byBjYWxjdWxhdGUgdGhlIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gKiBAcmV0dXJucyB7RE9NUmVjdEluaXR9XHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRIVE1MRWxlbWVudENvbnRlbnRSZWN0KHRhcmdldCkge1xyXG4gICAgLy8gQ2xpZW50IHdpZHRoICYgaGVpZ2h0IHByb3BlcnRpZXMgY2FuJ3QgYmVcclxuICAgIC8vIHVzZWQgZXhjbHVzaXZlbHkgYXMgdGhleSBwcm92aWRlIHJvdW5kZWQgdmFsdWVzLlxyXG4gICAgdmFyIGNsaWVudFdpZHRoID0gdGFyZ2V0LmNsaWVudFdpZHRoLCBjbGllbnRIZWlnaHQgPSB0YXJnZXQuY2xpZW50SGVpZ2h0O1xyXG4gICAgLy8gQnkgdGhpcyBjb25kaXRpb24gd2UgY2FuIGNhdGNoIGFsbCBub24tcmVwbGFjZWQgaW5saW5lLCBoaWRkZW4gYW5kXHJcbiAgICAvLyBkZXRhY2hlZCBlbGVtZW50cy4gVGhvdWdoIGVsZW1lbnRzIHdpdGggd2lkdGggJiBoZWlnaHQgcHJvcGVydGllcyBsZXNzXHJcbiAgICAvLyB0aGFuIDAuNSB3aWxsIGJlIGRpc2NhcmRlZCBhcyB3ZWxsLlxyXG4gICAgLy9cclxuICAgIC8vIFdpdGhvdXQgaXQgd2Ugd291bGQgbmVlZCB0byBpbXBsZW1lbnQgc2VwYXJhdGUgbWV0aG9kcyBmb3IgZWFjaCBvZlxyXG4gICAgLy8gdGhvc2UgY2FzZXMgYW5kIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHBlcmZvcm0gYSBwcmVjaXNlIGFuZCBwZXJmb3JtYW5jZVxyXG4gICAgLy8gZWZmZWN0aXZlIHRlc3QgZm9yIGhpZGRlbiBlbGVtZW50cy4gRS5nLiBldmVuIGpRdWVyeSdzICc6dmlzaWJsZScgZmlsdGVyXHJcbiAgICAvLyBnaXZlcyB3cm9uZyByZXN1bHRzIGZvciBlbGVtZW50cyB3aXRoIHdpZHRoICYgaGVpZ2h0IGxlc3MgdGhhbiAwLjUuXHJcbiAgICBpZiAoIWNsaWVudFdpZHRoICYmICFjbGllbnRIZWlnaHQpIHtcclxuICAgICAgICByZXR1cm4gZW1wdHlSZWN0O1xyXG4gICAgfVxyXG4gICAgdmFyIHN0eWxlcyA9IGdldFdpbmRvd09mKHRhcmdldCkuZ2V0Q29tcHV0ZWRTdHlsZSh0YXJnZXQpO1xyXG4gICAgdmFyIHBhZGRpbmdzID0gZ2V0UGFkZGluZ3Moc3R5bGVzKTtcclxuICAgIHZhciBob3JpelBhZCA9IHBhZGRpbmdzLmxlZnQgKyBwYWRkaW5ncy5yaWdodDtcclxuICAgIHZhciB2ZXJ0UGFkID0gcGFkZGluZ3MudG9wICsgcGFkZGluZ3MuYm90dG9tO1xyXG4gICAgLy8gQ29tcHV0ZWQgc3R5bGVzIG9mIHdpZHRoICYgaGVpZ2h0IGFyZSBiZWluZyB1c2VkIGJlY2F1c2UgdGhleSBhcmUgdGhlXHJcbiAgICAvLyBvbmx5IGRpbWVuc2lvbnMgYXZhaWxhYmxlIHRvIEpTIHRoYXQgY29udGFpbiBub24tcm91bmRlZCB2YWx1ZXMuIEl0IGNvdWxkXHJcbiAgICAvLyBiZSBwb3NzaWJsZSB0byB1dGlsaXplIHRoZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaWYgb25seSBpdCdzIGRhdGEgd2Fzbid0XHJcbiAgICAvLyBhZmZlY3RlZCBieSBDU1MgdHJhbnNmb3JtYXRpb25zIGxldCBhbG9uZSBwYWRkaW5ncywgYm9yZGVycyBhbmQgc2Nyb2xsIGJhcnMuXHJcbiAgICB2YXIgd2lkdGggPSB0b0Zsb2F0KHN0eWxlcy53aWR0aCksIGhlaWdodCA9IHRvRmxvYXQoc3R5bGVzLmhlaWdodCk7XHJcbiAgICAvLyBXaWR0aCAmIGhlaWdodCBpbmNsdWRlIHBhZGRpbmdzIGFuZCBib3JkZXJzIHdoZW4gdGhlICdib3JkZXItYm94JyBib3hcclxuICAgIC8vIG1vZGVsIGlzIGFwcGxpZWQgKGV4Y2VwdCBmb3IgSUUpLlxyXG4gICAgaWYgKHN0eWxlcy5ib3hTaXppbmcgPT09ICdib3JkZXItYm94Jykge1xyXG4gICAgICAgIC8vIEZvbGxvd2luZyBjb25kaXRpb25zIGFyZSByZXF1aXJlZCB0byBoYW5kbGUgSW50ZXJuZXQgRXhwbG9yZXIgd2hpY2hcclxuICAgICAgICAvLyBkb2Vzbid0IGluY2x1ZGUgcGFkZGluZ3MgYW5kIGJvcmRlcnMgdG8gY29tcHV0ZWQgQ1NTIGRpbWVuc2lvbnMuXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBXZSBjYW4gc2F5IHRoYXQgaWYgQ1NTIGRpbWVuc2lvbnMgKyBwYWRkaW5ncyBhcmUgZXF1YWwgdG8gdGhlIFwiY2xpZW50XCJcclxuICAgICAgICAvLyBwcm9wZXJ0aWVzIHRoZW4gaXQncyBlaXRoZXIgSUUsIGFuZCB0aHVzIHdlIGRvbid0IG5lZWQgdG8gc3VidHJhY3RcclxuICAgICAgICAvLyBhbnl0aGluZywgb3IgYW4gZWxlbWVudCBtZXJlbHkgZG9lc24ndCBoYXZlIHBhZGRpbmdzL2JvcmRlcnMgc3R5bGVzLlxyXG4gICAgICAgIGlmIChNYXRoLnJvdW5kKHdpZHRoICsgaG9yaXpQYWQpICE9PSBjbGllbnRXaWR0aCkge1xyXG4gICAgICAgICAgICB3aWR0aCAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICdsZWZ0JywgJ3JpZ2h0JykgKyBob3JpelBhZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKE1hdGgucm91bmQoaGVpZ2h0ICsgdmVydFBhZCkgIT09IGNsaWVudEhlaWdodCkge1xyXG4gICAgICAgICAgICBoZWlnaHQgLT0gZ2V0Qm9yZGVyc1NpemUoc3R5bGVzLCAndG9wJywgJ2JvdHRvbScpICsgdmVydFBhZDtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBGb2xsb3dpbmcgc3RlcHMgY2FuJ3QgYmUgYXBwbGllZCB0byB0aGUgZG9jdW1lbnQncyByb290IGVsZW1lbnQgYXMgaXRzXHJcbiAgICAvLyBjbGllbnRbV2lkdGgvSGVpZ2h0XSBwcm9wZXJ0aWVzIHJlcHJlc2VudCB2aWV3cG9ydCBhcmVhIG9mIHRoZSB3aW5kb3cuXHJcbiAgICAvLyBCZXNpZGVzLCBpdCdzIGFzIHdlbGwgbm90IG5lY2Vzc2FyeSBhcyB0aGUgPGh0bWw+IGl0c2VsZiBuZWl0aGVyIGhhc1xyXG4gICAgLy8gcmVuZGVyZWQgc2Nyb2xsIGJhcnMgbm9yIGl0IGNhbiBiZSBjbGlwcGVkLlxyXG4gICAgaWYgKCFpc0RvY3VtZW50RWxlbWVudCh0YXJnZXQpKSB7XHJcbiAgICAgICAgLy8gSW4gc29tZSBicm93c2VycyAob25seSBpbiBGaXJlZm94LCBhY3R1YWxseSkgQ1NTIHdpZHRoICYgaGVpZ2h0XHJcbiAgICAgICAgLy8gaW5jbHVkZSBzY3JvbGwgYmFycyBzaXplIHdoaWNoIGNhbiBiZSByZW1vdmVkIGF0IHRoaXMgc3RlcCBhcyBzY3JvbGxcclxuICAgICAgICAvLyBiYXJzIGFyZSB0aGUgb25seSBkaWZmZXJlbmNlIGJldHdlZW4gcm91bmRlZCBkaW1lbnNpb25zICsgcGFkZGluZ3NcclxuICAgICAgICAvLyBhbmQgXCJjbGllbnRcIiBwcm9wZXJ0aWVzLCB0aG91Z2ggdGhhdCBpcyBub3QgYWx3YXlzIHRydWUgaW4gQ2hyb21lLlxyXG4gICAgICAgIHZhciB2ZXJ0U2Nyb2xsYmFyID0gTWF0aC5yb3VuZCh3aWR0aCArIGhvcml6UGFkKSAtIGNsaWVudFdpZHRoO1xyXG4gICAgICAgIHZhciBob3JpelNjcm9sbGJhciA9IE1hdGgucm91bmQoaGVpZ2h0ICsgdmVydFBhZCkgLSBjbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgLy8gQ2hyb21lIGhhcyBhIHJhdGhlciB3ZWlyZCByb3VuZGluZyBvZiBcImNsaWVudFwiIHByb3BlcnRpZXMuXHJcbiAgICAgICAgLy8gRS5nLiBmb3IgYW4gZWxlbWVudCB3aXRoIGNvbnRlbnQgd2lkdGggb2YgMzE0LjJweCBpdCBzb21ldGltZXMgZ2l2ZXNcclxuICAgICAgICAvLyB0aGUgY2xpZW50IHdpZHRoIG9mIDMxNXB4IGFuZCBmb3IgdGhlIHdpZHRoIG9mIDMxNC43cHggaXQgbWF5IGdpdmVcclxuICAgICAgICAvLyAzMTRweC4gQW5kIGl0IGRvZXNuJ3QgaGFwcGVuIGFsbCB0aGUgdGltZS4gU28ganVzdCBpZ25vcmUgdGhpcyBkZWx0YVxyXG4gICAgICAgIC8vIGFzIGEgbm9uLXJlbGV2YW50LlxyXG4gICAgICAgIGlmIChNYXRoLmFicyh2ZXJ0U2Nyb2xsYmFyKSAhPT0gMSkge1xyXG4gICAgICAgICAgICB3aWR0aCAtPSB2ZXJ0U2Nyb2xsYmFyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoTWF0aC5hYnMoaG9yaXpTY3JvbGxiYXIpICE9PSAxKSB7XHJcbiAgICAgICAgICAgIGhlaWdodCAtPSBob3JpelNjcm9sbGJhcjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY3JlYXRlUmVjdEluaXQocGFkZGluZ3MubGVmdCwgcGFkZGluZ3MudG9wLCB3aWR0aCwgaGVpZ2h0KTtcclxufVxyXG4vKipcclxuICogQ2hlY2tzIHdoZXRoZXIgcHJvdmlkZWQgZWxlbWVudCBpcyBhbiBpbnN0YW5jZSBvZiB0aGUgU1ZHR3JhcGhpY3NFbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG52YXIgaXNTVkdHcmFwaGljc0VsZW1lbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgLy8gU29tZSBicm93c2VycywgbmFtZWx5IElFIGFuZCBFZGdlLCBkb24ndCBoYXZlIHRoZSBTVkdHcmFwaGljc0VsZW1lbnRcclxuICAgIC8vIGludGVyZmFjZS5cclxuICAgIGlmICh0eXBlb2YgU1ZHR3JhcGhpY3NFbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiB0YXJnZXQgaW5zdGFuY2VvZiBnZXRXaW5kb3dPZih0YXJnZXQpLlNWR0dyYXBoaWNzRWxlbWVudDsgfTtcclxuICAgIH1cclxuICAgIC8vIElmIGl0J3Mgc28sIHRoZW4gY2hlY2sgdGhhdCBlbGVtZW50IGlzIGF0IGxlYXN0IGFuIGluc3RhbmNlIG9mIHRoZVxyXG4gICAgLy8gU1ZHRWxlbWVudCBhbmQgdGhhdCBpdCBoYXMgdGhlIFwiZ2V0QkJveFwiIG1ldGhvZC5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1leHRyYS1wYXJlbnNcclxuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0KSB7IHJldHVybiAodGFyZ2V0IGluc3RhbmNlb2YgZ2V0V2luZG93T2YodGFyZ2V0KS5TVkdFbGVtZW50ICYmXHJcbiAgICAgICAgdHlwZW9mIHRhcmdldC5nZXRCQm94ID09PSAnZnVuY3Rpb24nKTsgfTtcclxufSkoKTtcclxuLyoqXHJcbiAqIENoZWNrcyB3aGV0aGVyIHByb3ZpZGVkIGVsZW1lbnQgaXMgYSBkb2N1bWVudCBlbGVtZW50ICg8aHRtbD4pLlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdG8gYmUgY2hlY2tlZC5cclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG5mdW5jdGlvbiBpc0RvY3VtZW50RWxlbWVudCh0YXJnZXQpIHtcclxuICAgIHJldHVybiB0YXJnZXQgPT09IGdldFdpbmRvd09mKHRhcmdldCkuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xyXG59XHJcbi8qKlxyXG4gKiBDYWxjdWxhdGVzIGFuIGFwcHJvcHJpYXRlIGNvbnRlbnQgcmVjdGFuZ2xlIGZvciBwcm92aWRlZCBodG1sIG9yIHN2ZyBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgY29udGVudCByZWN0YW5nbGUgb2Ygd2hpY2ggbmVlZHMgdG8gYmUgY2FsY3VsYXRlZC5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q29udGVudFJlY3QodGFyZ2V0KSB7XHJcbiAgICBpZiAoIWlzQnJvd3Nlcikge1xyXG4gICAgICAgIHJldHVybiBlbXB0eVJlY3Q7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNTVkdHcmFwaGljc0VsZW1lbnQodGFyZ2V0KSkge1xyXG4gICAgICAgIHJldHVybiBnZXRTVkdDb250ZW50UmVjdCh0YXJnZXQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdldEhUTUxFbGVtZW50Q29udGVudFJlY3QodGFyZ2V0KTtcclxufVxyXG4vKipcclxuICogQ3JlYXRlcyByZWN0YW5nbGUgd2l0aCBhbiBpbnRlcmZhY2Ugb2YgdGhlIERPTVJlY3RSZWFkT25seS5cclxuICogU3BlYzogaHR0cHM6Ly9kcmFmdHMuZnh0Zi5vcmcvZ2VvbWV0cnkvI2RvbXJlY3RyZWFkb25seVxyXG4gKlxyXG4gKiBAcGFyYW0ge0RPTVJlY3RJbml0fSByZWN0SW5pdCAtIE9iamVjdCB3aXRoIHJlY3RhbmdsZSdzIHgveSBjb29yZGluYXRlcyBhbmQgZGltZW5zaW9ucy5cclxuICogQHJldHVybnMge0RPTVJlY3RSZWFkT25seX1cclxuICovXHJcbmZ1bmN0aW9uIGNyZWF0ZVJlYWRPbmx5UmVjdChfYSkge1xyXG4gICAgdmFyIHggPSBfYS54LCB5ID0gX2EueSwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0O1xyXG4gICAgLy8gSWYgRE9NUmVjdFJlYWRPbmx5IGlzIGF2YWlsYWJsZSB1c2UgaXQgYXMgYSBwcm90b3R5cGUgZm9yIHRoZSByZWN0YW5nbGUuXHJcbiAgICB2YXIgQ29uc3RyID0gdHlwZW9mIERPTVJlY3RSZWFkT25seSAhPT0gJ3VuZGVmaW5lZCcgPyBET01SZWN0UmVhZE9ubHkgOiBPYmplY3Q7XHJcbiAgICB2YXIgcmVjdCA9IE9iamVjdC5jcmVhdGUoQ29uc3RyLnByb3RvdHlwZSk7XHJcbiAgICAvLyBSZWN0YW5nbGUncyBwcm9wZXJ0aWVzIGFyZSBub3Qgd3JpdGFibGUgYW5kIG5vbi1lbnVtZXJhYmxlLlxyXG4gICAgZGVmaW5lQ29uZmlndXJhYmxlKHJlY3QsIHtcclxuICAgICAgICB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICAgIHRvcDogeSxcclxuICAgICAgICByaWdodDogeCArIHdpZHRoLFxyXG4gICAgICAgIGJvdHRvbTogaGVpZ2h0ICsgeSxcclxuICAgICAgICBsZWZ0OiB4XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZWN0O1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGVzIERPTVJlY3RJbml0IG9iamVjdCBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgZGltZW5zaW9ucyBhbmQgdGhlIHgveSBjb29yZGluYXRlcy5cclxuICogU3BlYzogaHR0cHM6Ly9kcmFmdHMuZnh0Zi5vcmcvZ2VvbWV0cnkvI2RpY3RkZWYtZG9tcmVjdGluaXRcclxuICpcclxuICogQHBhcmFtIHtudW1iZXJ9IHggLSBYIGNvb3JkaW5hdGUuXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gWSBjb29yZGluYXRlLlxyXG4gKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBSZWN0YW5nbGUncyB3aWR0aC5cclxuICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFJlY3RhbmdsZSdzIGhlaWdodC5cclxuICogQHJldHVybnMge0RPTVJlY3RJbml0fVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlUmVjdEluaXQoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xyXG4gICAgcmV0dXJuIHsgeDogeCwgeTogeSwgd2lkdGg6IHdpZHRoLCBoZWlnaHQ6IGhlaWdodCB9O1xyXG59XG5cbi8qKlxyXG4gKiBDbGFzcyB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBjb21wdXRhdGlvbnMgb2YgdGhlIGNvbnRlbnQgcmVjdGFuZ2xlIG9mXHJcbiAqIHByb3ZpZGVkIERPTSBlbGVtZW50IGFuZCBmb3Iga2VlcGluZyB0cmFjayBvZiBpdCdzIGNoYW5nZXMuXHJcbiAqL1xyXG52YXIgUmVzaXplT2JzZXJ2YXRpb24gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2YXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIG9ic2VydmVkLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZhdGlvbih0YXJnZXQpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBCcm9hZGNhc3RlZCB3aWR0aCBvZiBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAgICAgKlxyXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5icm9hZGNhc3RXaWR0aCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQnJvYWRjYXN0ZWQgaGVpZ2h0IG9mIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmJyb2FkY2FzdEhlaWdodCA9IDA7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogUmVmZXJlbmNlIHRvIHRoZSBsYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge0RPTVJlY3RJbml0fVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuY29udGVudFJlY3RfID0gY3JlYXRlUmVjdEluaXQoMCwgMCwgMCwgMCk7XHJcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgY29udGVudCByZWN0YW5nbGUgYW5kIHRlbGxzIHdoZXRoZXIgaXQncyB3aWR0aCBvciBoZWlnaHQgcHJvcGVydGllc1xyXG4gICAgICogaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IGJyb2FkY2FzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2YXRpb24ucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciByZWN0ID0gZ2V0Q29udGVudFJlY3QodGhpcy50YXJnZXQpO1xyXG4gICAgICAgIHRoaXMuY29udGVudFJlY3RfID0gcmVjdDtcclxuICAgICAgICByZXR1cm4gKHJlY3Qud2lkdGggIT09IHRoaXMuYnJvYWRjYXN0V2lkdGggfHxcclxuICAgICAgICAgICAgcmVjdC5oZWlnaHQgIT09IHRoaXMuYnJvYWRjYXN0SGVpZ2h0KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgJ2Jyb2FkY2FzdFdpZHRoJyBhbmQgJ2Jyb2FkY2FzdEhlaWdodCcgcHJvcGVydGllcyB3aXRoIGEgZGF0YVxyXG4gICAgICogZnJvbSB0aGUgY29ycmVzcG9uZGluZyBwcm9wZXJ0aWVzIG9mIHRoZSBsYXN0IG9ic2VydmVkIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIHtET01SZWN0SW5pdH0gTGFzdCBvYnNlcnZlZCBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2YXRpb24ucHJvdG90eXBlLmJyb2FkY2FzdFJlY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlY3QgPSB0aGlzLmNvbnRlbnRSZWN0XztcclxuICAgICAgICB0aGlzLmJyb2FkY2FzdFdpZHRoID0gcmVjdC53aWR0aDtcclxuICAgICAgICB0aGlzLmJyb2FkY2FzdEhlaWdodCA9IHJlY3QuaGVpZ2h0O1xyXG4gICAgICAgIHJldHVybiByZWN0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZhdGlvbjtcclxufSgpKTtcblxudmFyIFJlc2l6ZU9ic2VydmVyRW50cnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXJFbnRyeS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHRhcmdldCAtIEVsZW1lbnQgdGhhdCBpcyBiZWluZyBvYnNlcnZlZC5cclxuICAgICAqIEBwYXJhbSB7RE9NUmVjdEluaXR9IHJlY3RJbml0IC0gRGF0YSBvZiB0aGUgZWxlbWVudCdzIGNvbnRlbnQgcmVjdGFuZ2xlLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlckVudHJ5KHRhcmdldCwgcmVjdEluaXQpIHtcclxuICAgICAgICB2YXIgY29udGVudFJlY3QgPSBjcmVhdGVSZWFkT25seVJlY3QocmVjdEluaXQpO1xyXG4gICAgICAgIC8vIEFjY29yZGluZyB0byB0aGUgc3BlY2lmaWNhdGlvbiBmb2xsb3dpbmcgcHJvcGVydGllcyBhcmUgbm90IHdyaXRhYmxlXHJcbiAgICAgICAgLy8gYW5kIGFyZSBhbHNvIG5vdCBlbnVtZXJhYmxlIGluIHRoZSBuYXRpdmUgaW1wbGVtZW50YXRpb24uXHJcbiAgICAgICAgLy9cclxuICAgICAgICAvLyBQcm9wZXJ0eSBhY2Nlc3NvcnMgYXJlIG5vdCBiZWluZyB1c2VkIGFzIHRoZXknZCByZXF1aXJlIHRvIGRlZmluZSBhXHJcbiAgICAgICAgLy8gcHJpdmF0ZSBXZWFrTWFwIHN0b3JhZ2Ugd2hpY2ggbWF5IGNhdXNlIG1lbW9yeSBsZWFrcyBpbiBicm93c2VycyB0aGF0XHJcbiAgICAgICAgLy8gZG9uJ3Qgc3VwcG9ydCB0aGlzIHR5cGUgb2YgY29sbGVjdGlvbnMuXHJcbiAgICAgICAgZGVmaW5lQ29uZmlndXJhYmxlKHRoaXMsIHsgdGFyZ2V0OiB0YXJnZXQsIGNvbnRlbnRSZWN0OiBjb250ZW50UmVjdCB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlckVudHJ5O1xyXG59KCkpO1xuXG52YXIgUmVzaXplT2JzZXJ2ZXJTUEkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZFxyXG4gICAgICogICAgICB3aGVuIG9uZSBvZiB0aGUgb2JzZXJ2ZWQgZWxlbWVudHMgY2hhbmdlcyBpdCdzIGNvbnRlbnQgZGltZW5zaW9ucy5cclxuICAgICAqIEBwYXJhbSB7UmVzaXplT2JzZXJ2ZXJDb250cm9sbGVyfSBjb250cm9sbGVyIC0gQ29udHJvbGxlciBpbnN0YW5jZSB3aGljaFxyXG4gICAgICogICAgICBpcyByZXNwb25zaWJsZSBmb3IgdGhlIHVwZGF0ZXMgb2Ygb2JzZXJ2ZXIuXHJcbiAgICAgKiBAcGFyYW0ge1Jlc2l6ZU9ic2VydmVyfSBjYWxsYmFja0N0eCAtIFJlZmVyZW5jZSB0byB0aGUgcHVibGljXHJcbiAgICAgKiAgICAgIFJlc2l6ZU9ic2VydmVyIGluc3RhbmNlIHdoaWNoIHdpbGwgYmUgcGFzc2VkIHRvIGNhbGxiYWNrIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBSZXNpemVPYnNlcnZlclNQSShjYWxsYmFjaywgY29udHJvbGxlciwgY2FsbGJhY2tDdHgpIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDb2xsZWN0aW9uIG9mIHJlc2l6ZSBvYnNlcnZhdGlvbnMgdGhhdCBoYXZlIGRldGVjdGVkIGNoYW5nZXMgaW4gZGltZW5zaW9uc1xyXG4gICAgICAgICAqIG9mIGVsZW1lbnRzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge0FycmF5PFJlc2l6ZU9ic2VydmF0aW9uPn1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18gPSBbXTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBSZWdpc3RyeSBvZiB0aGUgUmVzaXplT2JzZXJ2YXRpb24gaW5zdGFuY2VzLlxyXG4gICAgICAgICAqXHJcbiAgICAgICAgICogQHByaXZhdGUge01hcDxFbGVtZW50LCBSZXNpemVPYnNlcnZhdGlvbj59XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgdGhpcy5vYnNlcnZhdGlvbnNfID0gbmV3IE1hcFNoaW0oKTtcclxuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjYWxsYmFjayBwcm92aWRlZCBhcyBwYXJhbWV0ZXIgMSBpcyBub3QgYSBmdW5jdGlvbi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja18gPSBjYWxsYmFjaztcclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfID0gY29udHJvbGxlcjtcclxuICAgICAgICB0aGlzLmNhbGxiYWNrQ3R4XyA9IGNhbGxiYWNrQ3R4O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBTdGFydHMgb2JzZXJ2aW5nIHByb3ZpZGVkIGVsZW1lbnQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXQgLSBFbGVtZW50IHRvIGJlIG9ic2VydmVkLlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgdGhlIEVsZW1lbnQgaW50ZXJmYWNlLlxyXG4gICAgICAgIGlmICh0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgIShFbGVtZW50IGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgXCJFbGVtZW50XCIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvYnNlcnZhdGlvbnMgPSB0aGlzLm9ic2VydmF0aW9uc187XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBlbGVtZW50IGlzIGFscmVhZHkgYmVpbmcgb2JzZXJ2ZWQuXHJcbiAgICAgICAgaWYgKG9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ic2VydmF0aW9ucy5zZXQodGFyZ2V0LCBuZXcgUmVzaXplT2JzZXJ2YXRpb24odGFyZ2V0KSk7XHJcbiAgICAgICAgdGhpcy5jb250cm9sbGVyXy5hZGRPYnNlcnZlcih0aGlzKTtcclxuICAgICAgICAvLyBGb3JjZSB0aGUgdXBkYXRlIG9mIG9ic2VydmF0aW9ucy5cclxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJfLnJlZnJlc2goKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFN0b3BzIG9ic2VydmluZyBwcm92aWRlZCBlbGVtZW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gdGFyZ2V0IC0gRWxlbWVudCB0byBzdG9wIG9ic2VydmluZy5cclxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxyXG4gICAgICovXHJcbiAgICBSZXNpemVPYnNlcnZlclNQSS5wcm90b3R5cGUudW5vYnNlcnZlID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCcxIGFyZ3VtZW50IHJlcXVpcmVkLCBidXQgb25seSAwIHByZXNlbnQuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIERvIG5vdGhpbmcgaWYgY3VycmVudCBlbnZpcm9ubWVudCBkb2Vzbid0IGhhdmUgdGhlIEVsZW1lbnQgaW50ZXJmYWNlLlxyXG4gICAgICAgIGlmICh0eXBlb2YgRWxlbWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgIShFbGVtZW50IGluc3RhbmNlb2YgT2JqZWN0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghKHRhcmdldCBpbnN0YW5jZW9mIGdldFdpbmRvd09mKHRhcmdldCkuRWxlbWVudCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgXCJFbGVtZW50XCIuJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvYnNlcnZhdGlvbnMgPSB0aGlzLm9ic2VydmF0aW9uc187XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBlbGVtZW50IGlzIG5vdCBiZWluZyBvYnNlcnZlZC5cclxuICAgICAgICBpZiAoIW9ic2VydmF0aW9ucy5oYXModGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIG9ic2VydmF0aW9ucy5kZWxldGUodGFyZ2V0KTtcclxuICAgICAgICBpZiAoIW9ic2VydmF0aW9ucy5zaXplKSB7XHJcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU3RvcHMgb2JzZXJ2aW5nIGFsbCBlbGVtZW50cy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgICAgIHRoaXMub2JzZXJ2YXRpb25zXy5jbGVhcigpO1xyXG4gICAgICAgIHRoaXMuY29udHJvbGxlcl8ucmVtb3ZlT2JzZXJ2ZXIodGhpcyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb2xsZWN0cyBvYnNlcnZhdGlvbiBpbnN0YW5jZXMgdGhlIGFzc29jaWF0ZWQgZWxlbWVudCBvZiB3aGljaCBoYXMgY2hhbmdlZFxyXG4gICAgICogaXQncyBjb250ZW50IHJlY3RhbmdsZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7dm9pZH1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmdhdGhlckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHRoaXMuY2xlYXJBY3RpdmUoKTtcclxuICAgICAgICB0aGlzLm9ic2VydmF0aW9uc18uZm9yRWFjaChmdW5jdGlvbiAob2JzZXJ2YXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKG9ic2VydmF0aW9uLmlzQWN0aXZlKCkpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18ucHVzaChvYnNlcnZhdGlvbik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEludm9rZXMgaW5pdGlhbCBjYWxsYmFjayBmdW5jdGlvbiB3aXRoIGEgbGlzdCBvZiBSZXNpemVPYnNlcnZlckVudHJ5XHJcbiAgICAgKiBpbnN0YW5jZXMgY29sbGVjdGVkIGZyb20gYWN0aXZlIHJlc2l6ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5icm9hZGNhc3RBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiBvYnNlcnZlciBkb2Vzbid0IGhhdmUgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAgICBpZiAoIXRoaXMuaGFzQWN0aXZlKCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY3R4ID0gdGhpcy5jYWxsYmFja0N0eF87XHJcbiAgICAgICAgLy8gQ3JlYXRlIFJlc2l6ZU9ic2VydmVyRW50cnkgaW5zdGFuY2UgZm9yIGV2ZXJ5IGFjdGl2ZSBvYnNlcnZhdGlvbi5cclxuICAgICAgICB2YXIgZW50cmllcyA9IHRoaXMuYWN0aXZlT2JzZXJ2YXRpb25zXy5tYXAoZnVuY3Rpb24gKG9ic2VydmF0aW9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzaXplT2JzZXJ2ZXJFbnRyeShvYnNlcnZhdGlvbi50YXJnZXQsIG9ic2VydmF0aW9uLmJyb2FkY2FzdFJlY3QoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5jYWxsYmFja18uY2FsbChjdHgsIGVudHJpZXMsIGN0eCk7XHJcbiAgICAgICAgdGhpcy5jbGVhckFjdGl2ZSgpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ2xlYXJzIHRoZSBjb2xsZWN0aW9uIG9mIGFjdGl2ZSBvYnNlcnZhdGlvbnMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMge3ZvaWR9XHJcbiAgICAgKi9cclxuICAgIFJlc2l6ZU9ic2VydmVyU1BJLnByb3RvdHlwZS5jbGVhckFjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLmFjdGl2ZU9ic2VydmF0aW9uc18uc3BsaWNlKDApO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVGVsbHMgd2hldGhlciBvYnNlcnZlciBoYXMgYWN0aXZlIG9ic2VydmF0aW9ucy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgICAqL1xyXG4gICAgUmVzaXplT2JzZXJ2ZXJTUEkucHJvdG90eXBlLmhhc0FjdGl2ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5hY3RpdmVPYnNlcnZhdGlvbnNfLmxlbmd0aCA+IDA7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyU1BJO1xyXG59KCkpO1xuXG4vLyBSZWdpc3RyeSBvZiBpbnRlcm5hbCBvYnNlcnZlcnMuIElmIFdlYWtNYXAgaXMgbm90IGF2YWlsYWJsZSB1c2UgY3VycmVudCBzaGltXHJcbi8vIGZvciB0aGUgTWFwIGNvbGxlY3Rpb24gYXMgaXQgaGFzIGFsbCByZXF1aXJlZCBtZXRob2RzIGFuZCBiZWNhdXNlIFdlYWtNYXBcclxuLy8gY2FuJ3QgYmUgZnVsbHkgcG9seWZpbGxlZCBhbnl3YXkuXHJcbnZhciBvYnNlcnZlcnMgPSB0eXBlb2YgV2Vha01hcCAhPT0gJ3VuZGVmaW5lZCcgPyBuZXcgV2Vha01hcCgpIDogbmV3IE1hcFNoaW0oKTtcclxuLyoqXHJcbiAqIFJlc2l6ZU9ic2VydmVyIEFQSS4gRW5jYXBzdWxhdGVzIHRoZSBSZXNpemVPYnNlcnZlciBTUEkgaW1wbGVtZW50YXRpb25cclxuICogZXhwb3Npbmcgb25seSB0aG9zZSBtZXRob2RzIGFuZCBwcm9wZXJ0aWVzIHRoYXQgYXJlIGRlZmluZWQgaW4gdGhlIHNwZWMuXHJcbiAqL1xyXG52YXIgUmVzaXplT2JzZXJ2ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZXNpemVPYnNlcnZlckNhbGxiYWNrfSBjYWxsYmFjayAtIENhbGxiYWNrIHRoYXQgaXMgaW52b2tlZCB3aGVuXHJcbiAgICAgKiAgICAgIGRpbWVuc2lvbnMgb2YgdGhlIG9ic2VydmVkIGVsZW1lbnRzIGNoYW5nZS5cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gUmVzaXplT2JzZXJ2ZXIoY2FsbGJhY2spIHtcclxuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVzaXplT2JzZXJ2ZXIpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Nhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvbi4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJzEgYXJndW1lbnQgcmVxdWlyZWQsIGJ1dCBvbmx5IDAgcHJlc2VudC4nKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNvbnRyb2xsZXIgPSBSZXNpemVPYnNlcnZlckNvbnRyb2xsZXIuZ2V0SW5zdGFuY2UoKTtcclxuICAgICAgICB2YXIgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXJTUEkoY2FsbGJhY2ssIGNvbnRyb2xsZXIsIHRoaXMpO1xyXG4gICAgICAgIG9ic2VydmVycy5zZXQodGhpcywgb2JzZXJ2ZXIpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlc2l6ZU9ic2VydmVyO1xyXG59KCkpO1xyXG4vLyBFeHBvc2UgcHVibGljIG1ldGhvZHMgb2YgUmVzaXplT2JzZXJ2ZXIuXHJcbltcclxuICAgICdvYnNlcnZlJyxcclxuICAgICd1bm9ic2VydmUnLFxyXG4gICAgJ2Rpc2Nvbm5lY3QnXHJcbl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XHJcbiAgICBSZXNpemVPYnNlcnZlci5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICAgICAgcmV0dXJuIChfYSA9IG9ic2VydmVycy5nZXQodGhpcykpW21ldGhvZF0uYXBwbHkoX2EsIGFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG59KTtcblxudmFyIGluZGV4ID0gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIEV4cG9ydCBleGlzdGluZyBpbXBsZW1lbnRhdGlvbiBpZiBhdmFpbGFibGUuXHJcbiAgICBpZiAodHlwZW9mIGdsb2JhbCQxLlJlc2l6ZU9ic2VydmVyICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiBnbG9iYWwkMS5SZXNpemVPYnNlcnZlcjtcclxuICAgIH1cclxuICAgIHJldHVybiBSZXNpemVPYnNlcnZlcjtcclxufSkoKTtcblxuZXhwb3J0IGRlZmF1bHQgaW5kZXg7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js\n");

/***/ })

}]);